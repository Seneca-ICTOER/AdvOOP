"use strict";(self.webpackChunkoop345=self.webpackChunkoop345||[]).push([[932],{3905:function(n,e,t){t.d(e,{Zo:function(){return r},kt:function(){return g}});var o=t(7294);function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,o)}return t}function s(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){a(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function l(n,e){if(null==n)return{};var t,o,a=function(n,e){if(null==n)return{};var t,o,a={},i=Object.keys(n);for(o=0;o<i.length;o++)t=i[o],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(o=0;o<i.length;o++)t=i[o],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}var c=o.createContext({}),m=function(n){var e=o.useContext(c),t=e;return n&&(t="function"==typeof n?n(e):s(s({},e),n)),t},r=function(n){var e=m(n.components);return o.createElement(c.Provider,{value:e},n.children)},d={inlineCode:"code",wrapper:function(n){var e=n.children;return o.createElement(o.Fragment,{},e)}},p=o.forwardRef((function(n,e){var t=n.components,a=n.mdxType,i=n.originalType,c=n.parentName,r=l(n,["components","mdxType","originalType","parentName"]),p=m(t),g=a,b=p["".concat(c,".").concat(g)]||p[g]||d[g]||i;return t?o.createElement(b,s(s({ref:e},r),{},{components:t})):o.createElement(b,s({ref:e},r))}));function g(n,e){var t=arguments,a=e&&e.mdxType;if("string"==typeof n||a){var i=t.length,s=new Array(i);s[0]=p;var l={};for(var c in e)hasOwnProperty.call(e,c)&&(l[c]=e[c]);l.originalType=n,l.mdxType="string"==typeof n?n:a,s[1]=l;for(var m=2;m<i;m++)s[m]=t[m];return o.createElement.apply(null,s)}return o.createElement.apply(null,t)}p.displayName="MDXCreateElement"},6512:function(n,e,t){t.r(e),t.d(e,{assets:function(){return c},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return m}});var o=t(3117),a=(t(7294),t(3905));const i={id:"compositions-aggregations-and-associations",title:"Compositions, Aggregations and Associations",sidebar_position:3,description:"TBD"},s="Compositions, Aggregations and Associations",l={unversionedId:"C-Class-Relationships/compositions-aggregations-and-associations",id:"C-Class-Relationships/compositions-aggregations-and-associations",title:"Compositions, Aggregations and Associations",description:"TBD",source:"@site/docs/C-Class-Relationships/compositions-aggregations-and-associations.md",sourceDirName:"C-Class-Relationships",slug:"/C-Class-Relationships/compositions-aggregations-and-associations",permalink:"/C-Class-Relationships/compositions-aggregations-and-associations",draft:!1,editUrl:"https://github.com/Seneca-ICTOER/AdvOOP/tree/main/docs/C-Class-Relationships/compositions-aggregations-and-associations.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"compositions-aggregations-and-associations",title:"Compositions, Aggregations and Associations",sidebar_position:3,description:"TBD"},sidebar:"courseNotesSidebar",previous:{title:"Class Templates",permalink:"/C-Class-Relationships/class-templates"},next:{title:"Expressions",permalink:"/D-Processing/expressions"}},c={},m=[{value:"Compositions",id:"compositions",level:2},{value:"Aggregations",id:"aggregations",level:2},{value:"Associations",id:"associations",level:2},{value:"Exercises",id:"exercises",level:2}],r={toc:m};function d(n){let{components:e,...i}=n;return(0,a.kt)("wrapper",(0,o.Z)({},r,i,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"compositions-aggregations-and-associations"},"Compositions, Aggregations and Associations"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Design collections of model objects"),(0,a.kt)("li",{parentName:"ul"},"Distinguish class relationships with respect to ownership")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},'"Prefer composition to inheritance" Sutter, Alexandruscu (2005)')),(0,a.kt)("p",null,"The relationships between classes in object-oriented applications, aside from inheritance and parametric polymorphism, exhibit different degrees of ownership. These relationships include compositions, aggregations and associations. Each relationship reflects a different degree of coupling between classes. A composition is a strong relationship: the composer object owns the component object: one class completely contains another class and determines its lifetime. An aggregation is a weaker relationship: the aggregator has an instance of another class, which determines its own lifetime. An association is the weakest relationship of the three: one class accesses or uses another class: neither class exhibit a 'has a' relationship to the other class."),(0,a.kt)("p",null,"These relationships appear in all three forms in the case of class with resources. If a class with a resource is responsible for copying and destroying its resource, then that class is a composition. If the class is not responsible for copying or destroying its resource, then that class is an aggregation or an association."),(0,a.kt)("p",null,"This chapter presents examples of each of these three relationships."),(0,a.kt)("h2",{id:"compositions"},"Compositions"),(0,a.kt)("p",null,"A composition is a ",(0,a.kt)("strong",{parentName:"p"},"has-a")," relationship between classes. It implements complete ownership. The composer object is responsible for destroying its component object(s) at or before its own destruction. A composition is incomplete without its components."),(0,a.kt)("p",null,"Design-wise, composition is more flexible (less coupled) than inheritance. Updates to the component class need not affect the composer class. However, member functions added to the component class require forwarding member functions in the composer class."),(0,a.kt)("p",null,"Consider the relationship between a ",(0,a.kt)("inlineCode",{parentName:"p"},"Person")," class and a ",(0,a.kt)("inlineCode",{parentName:"p"},"Name")," class illustrated below: every person has a name."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Composition",src:t(1041).Z,width:"321",height:"36"})),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"#ifndef NAME_H\n#define NAME_H\n// Composition - Name\n// Name.h\n\nclass Name\n{\n    char* name { nullptr };\npublic:\n    Name(const char*);\n    Name(const Name&);\n\n    Name& operator=(const Name&);\n    ~Name();\n\n    const char* get() const;\n    void set(const char*);\n};\n#endif\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Composition - Name\n// Name.cpp\n\n#include <cstring>\n#include "Name.h"\n\nName::Name(const char* n) : name {new char[std::strlen(n) + 1]}\n{\n    std::strcpy(name, n);\n}\n\nName::Name(const Name& src)\n{\n    *this = src;\n}\n\nName& Name::operator=(const Name&  src)\n{\n    if (this != &src)\n    {\n        delete [] name;\n        name = new char[std::strlen(src.name) + 1];\n        std::strcpy(name, src.name);\n    }\n    return *this;\n}\n\nName::~Name()\n{\n    delete [] name;\n}\n\nconst char* Name::get() const\n{\n    return name;\n}\n\nvoid Name::set(const char* n)\n{\n    delete [] name;\n\n    name = new char[std::strlen(n) + 1];\n    std::strcpy(name, n);\n}\n')),(0,a.kt)("p",null,"We implement this composition using either a ",(0,a.kt)("inlineCode",{parentName:"p"},"Name")," subobject or a pointer to a ",(0,a.kt)("inlineCode",{parentName:"p"},"Name")," object."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Composition - SubObject Version\n// Person-subobject.h\n\n#include "Name.h"\n\nclass Person\n{\n    Name name; // subobject\n    int age;\npublic:\n    Person(const char*, int);\n\n    void display() const;\n    void set(const char*);\n    //...\n};\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Composition - Pointer Version\n// Person-pointer.h\n\n#include "Name.h"\n\nclass Person\n{\n    Name* name { nullptr }; // pointer\n    int age;\npublic:\n    Person(const char*, int);\n\n    // special functions to manage the resource\n    Person(const Person&);\n    Person& operator=(const Person&);\n    ~Person();\n\n    void display() const;\n    void set(const char*);\n    //...\n};\n')),(0,a.kt)("p",null,"The implementation files for both versions are listed below. The ",(0,a.kt)("inlineCode",{parentName:"p"},"Name")," object does not exist apart from the ",(0,a.kt)("inlineCode",{parentName:"p"},"Person")," object. In the subobject version, the default copying and assignment rules apply: the default copy constructor, assignment operator and destructor are sufficient. In the pointer version, deep copying and assignment are required and we must code the copy constructor, assignment operator and destructor. The ",(0,a.kt)("inlineCode",{parentName:"p"},"Person")," constructor creates the ",(0,a.kt)("inlineCode",{parentName:"p"},"Name")," object, the assignment operator destroys the old ",(0,a.kt)("inlineCode",{parentName:"p"},"Name")," object and creates a new one, and the destructor destroys the ",(0,a.kt)("inlineCode",{parentName:"p"},"Name")," object."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Composition - SubObject Version\n// Person-subobject.cpp\n\n#include <iostream>\n#include \"Person-subobject.h\"\n\nPerson::Person(const char* n, int a) : name{n}, age{a} {}\n\nvoid Person::display() const\n{\n    std::cout << age << ' ' << name.get() << std::endl;\n}\n\nvoid Person::set(const char* n)\n{\n    name.set(n); // forwarding\n}\n//...\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Composition - Pointer Version\n// Person-pointer.cpp\n\n#include <iostream>\n#include "Person-pointer.h"\n#include "Name.h"\n\nPerson::Person(const char* n, int a) : name {new Name(n)}, age {a} {}\n\nPerson::Person(const Person& src)\n{\n    *this = src;\n}\n\nPerson& Person::operator=(const Person& src)\n{\n    if (this != &src)\n    {\n        delete name;\n        name = new Name(*src.name);\n        age = src.age;\n    }\n    return *this;\n}\n\nPerson::~Person() { delete name; }\n\nvoid Person::display() const\n{\n    std::cout << age << \' \' <<\n    name->get() << std::endl;\n}\n\nvoid Person::set(const char* n)\n{\n    name->set(n); // forwarding\n}\n//...\n')),(0,a.kt)("p",null,"The following program"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Composition\n// composition.cpp\n\n#include "Person.h"\n\nint main()\n{\n    Person p("Harvey", 23);\n    Person q = p;\n    p.display();\n    q.display();\n\n    q.set("Lawrence");\n    p.display();\n    q.display();\n\n    p = q;\n    p.display();\n}\n')),(0,a.kt)("p",null,"produces the output below for both versions of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Person")," type:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"23 Harvey\n23 Harvey\n\n23 Harvey\n23 Lawrence\n\n23 Lawrence\n")),(0,a.kt)("p",null,"Note that this program is unaware of the implementation of the composition relationship. It makes no reference to the types of subobjects contained in the ",(0,a.kt)("inlineCode",{parentName:"p"},"Person")," type. Changes to these objects and the descriptions of their type(s) are completely hidden within the ",(0,a.kt)("inlineCode",{parentName:"p"},"Person")," type."),(0,a.kt)("h2",{id:"aggregations"},"Aggregations"),(0,a.kt)("p",null,"An aggregation is a composition that does not manage the creation or destruction of the objects that it ",(0,a.kt)("em",{parentName:"p"},"uses"),". The responsibility for creating and destroying the objects lies outside the aggregator type. The aggregator is complete whether or not any of the objects that it uses exist. The objects used survive the destruction of the aggregator."),(0,a.kt)("p",null,"Design-wise, aggregation is more flexible (less coupled) than composition. Updates to any aggregatee type do not interfere with the design of the aggregator type. Member functions added to the aggregatee type do not require forwarding member functions in the aggregator type."),(0,a.kt)("p",null,"Consider the relationship between a club and its members. The relationship is between the club and the names of its members as illustrated below. The club has or may have members, but can exist without any. A member's name can be removed from its list of members before the club is disbanded and that name is not destroyed if the club is disbanded."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Aggregation",src:t(9191).Z,width:"321",height:"52"})),(0,a.kt)("p",null,"The class definition and implementation for a ",(0,a.kt)("inlineCode",{parentName:"p"},"Club")," type might look like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Aggregation\n// Club.h\n\nclass Name;\n\nconstexpr int M { 50 };\n\nclass Club\n{\n    const Name* name[M]{};\n    int m { 0 };\npublic:\n    Club& operator+=(const Name&);\n    Club& operator-=(const Name&);\n    void display() const;\n    //...\n};\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Aggregation\n// Club.cpp\n\n#include <iostream>\n#include <cstring>\n#include "Club.h"\n#include "Name.h"\n\nClub& Club::operator+=(const Name& n)\n{\n    if (m < M)\n        name[m++] = &n;\n    return *this;\n}\n\nClub& Club::operator-=(const Name& t)\n{\n    bool found = false;\n    int i;\n    for (i = 0; i < m && !found; i++)\n        if (!std::strcmp(name[i]->get(),\n            t.get())) found = true;\n\n    if (found)\n    {\n        for (; i < m; i++)\n            name[i - 1] = name[i];\n        if (m)\n        {\n            name[m - 1] = nullptr;\n            m--;\n        }\n    }\n    return *this;\n}\n\nvoid Club::display() const\n{\n    for (int i = 0; i < m; i++)\n        std::cout << name[i]->get() << std::endl;\n}\n//...\n')),(0,a.kt)("p",null,"The following program adds the names of four members to a club, removes two names and generates the output listed below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Aggregation\n// aggregation.cpp\n\n#include "Club.h"\n#include "Name.h"\n\nint main()\n{\n    Name jane("Jane");\n    Name john("John");\n    Name alice("Alice");\n    Name frank("Frank");\n    Name stanley("Stanley");\n\n    Club gameClub;\n\n    gameClub += jane;\n    gameClub += john;\n    gameClub += alice;\n    gameClub += frank;\n    gameClub.display();\n\n    gameClub -= alice;\n    gameClub -= john;\n    gameClub -= stanley;\n    gameClub.display();\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Jane\nJohn\nAlice\nFrank\n\nJane\nFrank\n")),(0,a.kt)("p",null,"Note how the application creates the ",(0,a.kt)("inlineCode",{parentName:"p"},"Name")," objects separately from the ",(0,a.kt)("inlineCode",{parentName:"p"},"Club")," and destroys them separately."),(0,a.kt)("h2",{id:"associations"},"Associations"),(0,a.kt)("p",null,"An association is a service relationship. It does not involve any ownership of one type by another. Each type is independent and complete without the related type."),(0,a.kt)("p",null,"Association is the least coupled relationship between classes. Member functions in an association do not require forwarding member functions in the related type."),(0,a.kt)("p",null,"Consider the relationship between a course and a room in a college. The course uses the room and the room is booked for the course for a certain period. , but both exist independently of one another. A room can be booked for a course and a course can be assigned to a room. Neither is destroyed when the other is destroyed."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Association",src:t(8775).Z,width:"321",height:"31"})),(0,a.kt)("p",null,"The class definition and implementation for a ",(0,a.kt)("inlineCode",{parentName:"p"},"Course")," type might look like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Association\n// Course.h\n\n#include "Name.h"\nclass Room;\n\nclass Course\n{\n    Name name;\n    int code;\n    Room* room { nullptr };\n\npublic:\n    Course(const char*, int);\n\n    void book(Room&);\n    void release();\n    const char* get() const;\n    void display() const;\n    //...\n};\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Association\n// Course.cpp\n\n#include <iostream>\n#include "Course.h"\n#include "Room.h"\n\nCourse::Course(const char* n, int c) : name{n}, code{c} {}\n\nvoid Course::book(Room& r)\n{\n    if (room) room->release();\n    room = &r;\n}\n\nvoid Course::release()\n{\n    room = nullptr;\n}\n\nconst char* Course::get() const\n{\n    return name.get();\n}\n\nvoid Course::display() const\n{\n    std::cout << (room ? room->get() : "*****")\n              << \' \' << code << \' \' << name.get()\n              << std::endl;\n}\n//...\n')),(0,a.kt)("p",null,"The class definition and implementation for a Room type might look like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Association\n// Room.h\n\n#include "Name.h"\nclass Course;\n\nclass Room\n{\n    Name name;\n    Course* course { nullptr };\n\npublic:\n    Room(const char*);\n    void book(Course&);\n    void release();\n    const char* get() const;\n    void display() const;\n    //...\n};\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Association\n// Room.cpp\n\n#include <iostream>\n#include "Room.h"\n#include "Course.h"\n\nRoom::Room(const char* n) : name{n} {}\n\nvoid Room::book(Course& c)\n{\n    if (course) course->release();\n        course = &c;\n}\n\nvoid Room::release()\n{\n    course = nullptr;\n}\n\nconst char* Room::get() const\n{\n    return name.get();\n}\n\nvoid Room::display() const\n{\n    std::cout << name.get() << \' \'\n              << (course ? course->get() : "available")\n              << std::endl;\n}\n//...\n')),(0,a.kt)("p",null,"The following program assigns two of three courses to two of three rooms leaving one course unassigned and one room unbooked:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Association\n// association.cpp\n\n#include "Course.h"\n#include "Room.h"\n\nvoid book(Course& c, Room& r) {\nc.book(r);\nr.book(c);\n}\n\nint main()\n{\n    Room t2108("T2108");\n    Room t2109("T2109");\n    Room t2110("T2110");\n\n    Course btp105("Intro to Programming", 105);\n    Course btp205("Intro to O-O Prg", 205);\n    Course btp305("O-O Programming", 305);\n\n    btp105.display();\n    btp205.display();\n    btp305.display();\n\n    t2108.display();\n    t2109.display();\n    t2110.display();\n\n    book(btp205, t2110);\n    book(btp305, t2108);\n\n    btp105.display();\n    btp205.display();\n    btp305.display();\n\n    t2108.display();\n    t2109.display();\n    t2110.display();\n\n    book(btp205, t2108);\n    book(btp305, t2109);\n\n    btp105.display();\n    btp205.display();\n    btp305.display();\n\n    t2108.display();\n    t2109.display();\n    t2110.display();\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"***** 105 Intro to Programming\n***** 205 Intro to O-O Prg\n***** 305 O-O Programming\nT2108 available\nT2109 available\nT2110 available\n\n\n***** 105 Intro to Programming\nT2110 205 Intro to O-O Prg\nT2108 305 O-O Programming\nT2108 O-O Programming\nT2109 available\nT2110 Intro to O-O Programming\n\n\n***** 105 Intro to Programming\nT2108 205 Intro to O-O Prg\nT2109 305 O-O Programming\nT2108 Intro to O-O Programming\nT2109 O-O Programming\nT2110 available\n")),(0,a.kt)("h2",{id:"exercises"},"Exercises"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Read StackOverFlow on ",(0,a.kt)("a",{parentName:"li",href:"https://stackoverflow.com/questions/885937/difference-between-association-aggregation-and-composition"},"Difference Between Aggregation and Composition")),(0,a.kt)("li",{parentName:"ul"},"Read Software Engineering Stack Exchange on ",(0,a.kt)("a",{parentName:"li",href:"https://softwareengineering.stackexchange.com/questions/235313/uml-class-diagram-notations-differences-between-association-aggregation-and-co"},"Differences between Association, Aggregation and Composition"))))}d.isMDXComponent=!0},9191:function(n,e){e.Z="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCEtLSBEbyBub3QgZWRpdCB0aGlzIGZpbGUgd2l0aCBlZGl0b3JzIG90aGVyIHRoYW4gZGlhZ3JhbXMubmV0IC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZlcnNpb249IjEuMSIgd2lkdGg9IjMyMXB4IiBoZWlnaHQ9IjUycHgiIHZpZXdCb3g9Ii0wLjUgLTAuNSAzMjEgNTIiPjxkZWZzLz48Zz48cmVjdCB4PSIwIiB5PSIxMCIgd2lkdGg9IjEyMCIgaGVpZ2h0PSIzMCIgZmlsbD0iIzAwNTBlZiIgc3Ryb2tlPSIjMDAxZGJjIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTAuNSAtMC41KSI+PHN3aXRjaD48Zm9yZWlnbk9iamVjdCBwb2ludGVyLWV2ZW50cz0ibm9uZSIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5IiBzdHlsZT0ib3ZlcmZsb3c6IHZpc2libGU7IHRleHQtYWxpZ246IGxlZnQ7Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IHVuc2FmZSBjZW50ZXI7IGp1c3RpZnktY29udGVudDogdW5zYWZlIGNlbnRlcjsgd2lkdGg6IDExOHB4OyBoZWlnaHQ6IDFweDsgcGFkZGluZy10b3A6IDI1cHg7IG1hcmdpbi1sZWZ0OiAxcHg7Ij48ZGl2IGRhdGEtZHJhd2lvLWNvbG9ycz0iY29sb3I6ICNmZmZmZmY7ICIgc3R5bGU9ImJveC1zaXppbmc6IGJvcmRlci1ib3g7IGZvbnQtc2l6ZTogMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGZvbnQtc2l6ZTogMjBweDsgZm9udC1mYW1pbHk6IEhlbHZldGljYTsgY29sb3I6IHJnYigyNTUsIDI1NSwgMjU1KTsgbGluZS1oZWlnaHQ6IDEuMjsgcG9pbnRlci1ldmVudHM6IGFsbDsgd2hpdGUtc3BhY2U6IG5vcm1hbDsgb3ZlcmZsb3ctd3JhcDogbm9ybWFsOyI+Q2x1YjwvZGl2PjwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48dGV4dCB4PSI2MCIgeT0iMzEiIGZpbGw9IiNmZmZmZmYiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMjBweCIgdGV4dC1hbmNob3I9Im1pZGRsZSI+Q2x1YjwvdGV4dD48L3N3aXRjaD48L2c+PHJlY3QgeD0iMjAwIiB5PSIxMCIgd2lkdGg9IjEyMCIgaGVpZ2h0PSIzMCIgZmlsbD0iIzAwOGEwMCIgc3Ryb2tlPSIjMDA1NzAwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTAuNSAtMC41KSI+PHN3aXRjaD48Zm9yZWlnbk9iamVjdCBwb2ludGVyLWV2ZW50cz0ibm9uZSIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5IiBzdHlsZT0ib3ZlcmZsb3c6IHZpc2libGU7IHRleHQtYWxpZ246IGxlZnQ7Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IHVuc2FmZSBjZW50ZXI7IGp1c3RpZnktY29udGVudDogdW5zYWZlIGNlbnRlcjsgd2lkdGg6IDExOHB4OyBoZWlnaHQ6IDFweDsgcGFkZGluZy10b3A6IDI1cHg7IG1hcmdpbi1sZWZ0OiAyMDFweDsiPjxkaXYgZGF0YS1kcmF3aW8tY29sb3JzPSJjb2xvcjogI2ZmZmZmZjsgIiBzdHlsZT0iYm94LXNpemluZzogYm9yZGVyLWJveDsgZm9udC1zaXplOiAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IGlubGluZS1ibG9jazsgZm9udC1zaXplOiAyMHB4OyBmb250LWZhbWlseTogSGVsdmV0aWNhOyBjb2xvcjogcmdiKDI1NSwgMjU1LCAyNTUpOyBsaW5lLWhlaWdodDogMS4yOyBwb2ludGVyLWV2ZW50czogYWxsOyB3aGl0ZS1zcGFjZTogbm9ybWFsOyBvdmVyZmxvdy13cmFwOiBub3JtYWw7Ij5OYW1lPC9kaXY+PC9kaXY+PC9kaXY+PC9mb3JlaWduT2JqZWN0Pjx0ZXh0IHg9IjI2MCIgeT0iMzEiIGZpbGw9IiNmZmZmZmYiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMjBweCIgdGV4dC1hbmNob3I9Im1pZGRsZSI+TmFtZTwvdGV4dD48L3N3aXRjaD48L2c+PHBhdGggZD0iTSAyMDAgMjUgTCAxNDUuOTkgMjUiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc3NyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0ic3Ryb2tlIi8+PHBhdGggZD0iTSAxMjAuOTkgMjUgTCAxMzMuNDkgMTcuNjUgTCAxNDUuOTkgMjUgTCAxMzMuNDkgMzIuMzUgWiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNzc3IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48L2c+PHN3aXRjaD48ZyByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiLz48YSB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLC01KSIgeGxpbms6aHJlZj0iaHR0cHM6Ly93d3cuZGlhZ3JhbXMubmV0L2RvYy9mYXEvc3ZnLWV4cG9ydC10ZXh0LXByb2JsZW1zIiB0YXJnZXQ9Il9ibGFuayI+PHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIxMHB4IiB4PSI1MCUiIHk9IjEwMCUiPlRleHQgaXMgbm90IFNWRyAtIGNhbm5vdCBkaXNwbGF5PC90ZXh0PjwvYT48L3N3aXRjaD48L3N2Zz4="},8775:function(n,e){e.Z="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCEtLSBEbyBub3QgZWRpdCB0aGlzIGZpbGUgd2l0aCBlZGl0b3JzIG90aGVyIHRoYW4gZGlhZ3JhbXMubmV0IC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZlcnNpb249IjEuMSIgd2lkdGg9IjMyMXB4IiBoZWlnaHQ9IjMxcHgiIHZpZXdCb3g9Ii0wLjUgLTAuNSAzMjEgMzEiPjxkZWZzLz48Zz48cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMTIwIiBoZWlnaHQ9IjMwIiBmaWxsPSIjMDA1MGVmIiBzdHJva2U9IiMwMDFkYmMiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMC41IC0wLjUpIj48c3dpdGNoPjxmb3JlaWduT2JqZWN0IHBvaW50ZXItZXZlbnRzPSJub25lIiB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiIHN0eWxlPSJvdmVyZmxvdzogdmlzaWJsZTsgdGV4dC1hbGlnbjogbGVmdDsiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogdW5zYWZlIGNlbnRlcjsganVzdGlmeS1jb250ZW50OiB1bnNhZmUgY2VudGVyOyB3aWR0aDogMTE4cHg7IGhlaWdodDogMXB4OyBwYWRkaW5nLXRvcDogMTVweDsgbWFyZ2luLWxlZnQ6IDFweDsiPjxkaXYgZGF0YS1kcmF3aW8tY29sb3JzPSJjb2xvcjogI2ZmZmZmZjsgIiBzdHlsZT0iYm94LXNpemluZzogYm9yZGVyLWJveDsgZm9udC1zaXplOiAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IGlubGluZS1ibG9jazsgZm9udC1zaXplOiAyMHB4OyBmb250LWZhbWlseTogSGVsdmV0aWNhOyBjb2xvcjogcmdiKDI1NSwgMjU1LCAyNTUpOyBsaW5lLWhlaWdodDogMS4yOyBwb2ludGVyLWV2ZW50czogYWxsOyB3aGl0ZS1zcGFjZTogbm9ybWFsOyBvdmVyZmxvdy13cmFwOiBub3JtYWw7Ij5Db3Vyc2U8L2Rpdj48L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iNjAiIHk9IjIxIiBmaWxsPSIjZmZmZmZmIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjIwcHgiIHRleHQtYW5jaG9yPSJtaWRkbGUiPkNvdXJzZTwvdGV4dD48L3N3aXRjaD48L2c+PHJlY3QgeD0iMjAwIiB5PSIwIiB3aWR0aD0iMTIwIiBoZWlnaHQ9IjMwIiBmaWxsPSIjMDA1MGVmIiBzdHJva2U9IiMwMDFkYmMiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMC41IC0wLjUpIj48c3dpdGNoPjxmb3JlaWduT2JqZWN0IHBvaW50ZXItZXZlbnRzPSJub25lIiB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiIHN0eWxlPSJvdmVyZmxvdzogdmlzaWJsZTsgdGV4dC1hbGlnbjogbGVmdDsiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogdW5zYWZlIGNlbnRlcjsganVzdGlmeS1jb250ZW50OiB1bnNhZmUgY2VudGVyOyB3aWR0aDogMTE4cHg7IGhlaWdodDogMXB4OyBwYWRkaW5nLXRvcDogMTVweDsgbWFyZ2luLWxlZnQ6IDIwMXB4OyI+PGRpdiBkYXRhLWRyYXdpby1jb2xvcnM9ImNvbG9yOiAjZmZmZmZmOyAiIHN0eWxlPSJib3gtc2l6aW5nOiBib3JkZXItYm94OyBmb250LXNpemU6IDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDIwcHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiByZ2IoMjU1LCAyNTUsIDI1NSk7IGxpbmUtaGVpZ2h0OiAxLjI7IHBvaW50ZXItZXZlbnRzOiBhbGw7IHdoaXRlLXNwYWNlOiBub3JtYWw7IG92ZXJmbG93LXdyYXA6IG5vcm1hbDsiPlJvb208L2Rpdj48L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iMjYwIiB5PSIyMSIgZmlsbD0iI2ZmZmZmZiIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIyMHB4IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5Sb29tPC90ZXh0Pjwvc3dpdGNoPjwvZz48cGF0aCBkPSJNIDEyMCAxNSBMIDIwMCAxNSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNzc3IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiLz48L2c+PHN3aXRjaD48ZyByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiLz48YSB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLC01KSIgeGxpbms6aHJlZj0iaHR0cHM6Ly93d3cuZGlhZ3JhbXMubmV0L2RvYy9mYXEvc3ZnLWV4cG9ydC10ZXh0LXByb2JsZW1zIiB0YXJnZXQ9Il9ibGFuayI+PHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIxMHB4IiB4PSI1MCUiIHk9IjEwMCUiPlRleHQgaXMgbm90IFNWRyAtIGNhbm5vdCBkaXNwbGF5PC90ZXh0PjwvYT48L3N3aXRjaD48L3N2Zz4="},1041:function(n,e){e.Z="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCEtLSBEbyBub3QgZWRpdCB0aGlzIGZpbGUgd2l0aCBlZGl0b3JzIG90aGVyIHRoYW4gZGlhZ3JhbXMubmV0IC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZlcnNpb249IjEuMSIgd2lkdGg9IjMyMXB4IiBoZWlnaHQ9IjM2cHgiIHZpZXdCb3g9Ii0wLjUgLTAuNSAzMjEgMzYiPjxkZWZzLz48Zz48cmVjdCB4PSIwIiB5PSI0IiB3aWR0aD0iMTIwIiBoZWlnaHQ9IjMwIiBmaWxsPSIjMDA1MGVmIiBzdHJva2U9IiMwMDFkYmMiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMC41IC0wLjUpIj48c3dpdGNoPjxmb3JlaWduT2JqZWN0IHBvaW50ZXItZXZlbnRzPSJub25lIiB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiIHN0eWxlPSJvdmVyZmxvdzogdmlzaWJsZTsgdGV4dC1hbGlnbjogbGVmdDsiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogdW5zYWZlIGNlbnRlcjsganVzdGlmeS1jb250ZW50OiB1bnNhZmUgY2VudGVyOyB3aWR0aDogMTE4cHg7IGhlaWdodDogMXB4OyBwYWRkaW5nLXRvcDogMTlweDsgbWFyZ2luLWxlZnQ6IDFweDsiPjxkaXYgZGF0YS1kcmF3aW8tY29sb3JzPSJjb2xvcjogI2ZmZmZmZjsgIiBzdHlsZT0iYm94LXNpemluZzogYm9yZGVyLWJveDsgZm9udC1zaXplOiAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IGlubGluZS1ibG9jazsgZm9udC1zaXplOiAyMHB4OyBmb250LWZhbWlseTogSGVsdmV0aWNhOyBjb2xvcjogcmdiKDI1NSwgMjU1LCAyNTUpOyBsaW5lLWhlaWdodDogMS4yOyBwb2ludGVyLWV2ZW50czogYWxsOyB3aGl0ZS1zcGFjZTogbm9ybWFsOyBvdmVyZmxvdy13cmFwOiBub3JtYWw7Ij5QZXJzb248L2Rpdj48L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iNjAiIHk9IjI1IiBmaWxsPSIjZmZmZmZmIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjIwcHgiIHRleHQtYW5jaG9yPSJtaWRkbGUiPlBlcnNvbjwvdGV4dD48L3N3aXRjaD48L2c+PHJlY3QgeD0iMjAwIiB5PSI0IiB3aWR0aD0iMTIwIiBoZWlnaHQ9IjMwIiBmaWxsPSIjMDA4YTAwIiBzdHJva2U9IiMwMDU3MDAiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMC41IC0wLjUpIj48c3dpdGNoPjxmb3JlaWduT2JqZWN0IHBvaW50ZXItZXZlbnRzPSJub25lIiB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiIHN0eWxlPSJvdmVyZmxvdzogdmlzaWJsZTsgdGV4dC1hbGlnbjogbGVmdDsiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogdW5zYWZlIGNlbnRlcjsganVzdGlmeS1jb250ZW50OiB1bnNhZmUgY2VudGVyOyB3aWR0aDogMTE4cHg7IGhlaWdodDogMXB4OyBwYWRkaW5nLXRvcDogMTlweDsgbWFyZ2luLWxlZnQ6IDIwMXB4OyI+PGRpdiBkYXRhLWRyYXdpby1jb2xvcnM9ImNvbG9yOiAjZmZmZmZmOyAiIHN0eWxlPSJib3gtc2l6aW5nOiBib3JkZXItYm94OyBmb250LXNpemU6IDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDIwcHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiByZ2IoMjU1LCAyNTUsIDI1NSk7IGxpbmUtaGVpZ2h0OiAxLjI7IHBvaW50ZXItZXZlbnRzOiBhbGw7IHdoaXRlLXNwYWNlOiBub3JtYWw7IG92ZXJmbG93LXdyYXA6IG5vcm1hbDsiPk5hbWU8L2Rpdj48L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iMjYwIiB5PSIyNSIgZmlsbD0iI2ZmZmZmZiIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIyMHB4IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5OYW1lPC90ZXh0Pjwvc3dpdGNoPjwvZz48cGF0aCBkPSJNIDEzNS45OSAxOSBMIDIwMCAxOSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNzc3IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiLz48cGF0aCBkPSJNIDEyMC45OSAxOSBMIDEyOC40OSAxNC41OSBMIDEzNS45OSAxOSBMIDEyOC40OSAyMy40MSBaIiBmaWxsPSIjNzc3IiBzdHJva2U9IiM3NzciIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9ImFsbCIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0wLjUgLTAuNSkiPjxzd2l0Y2g+PGZvcmVpZ25PYmplY3QgcG9pbnRlci1ldmVudHM9Im5vbmUiIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIHJlcXVpcmVkRmVhdHVyZXM9Imh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjRXh0ZW5zaWJpbGl0eSIgc3R5bGU9Im92ZXJmbG93OiB2aXNpYmxlOyB0ZXh0LWFsaWduOiBsZWZ0OyI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgc3R5bGU9ImRpc3BsYXk6IGZsZXg7IGFsaWduLWl0ZW1zOiB1bnNhZmUgZmxleC1lbmQ7IGp1c3RpZnktY29udGVudDogdW5zYWZlIGZsZXgtc3RhcnQ7IHdpZHRoOiAxcHg7IGhlaWdodDogMXB4OyBwYWRkaW5nLXRvcDogMTNweDsgbWFyZ2luLWxlZnQ6IDEyMnB4OyI+PGRpdiBkYXRhLWRyYXdpby1jb2xvcnM9ImNvbG9yOiByZ2IoMCwgMCwgMCk7IGJhY2tncm91bmQtY29sb3I6IHJnYigyNTUsIDI1NSwgMjU1KTsgIiBzdHlsZT0iYm94LXNpemluZzogYm9yZGVyLWJveDsgZm9udC1zaXplOiAwcHg7IHRleHQtYWxpZ246IGxlZnQ7Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGZvbnQtc2l6ZTogMTFweDsgZm9udC1mYW1pbHk6IEhlbHZldGljYTsgY29sb3I6IHJnYigwLCAwLCAwKTsgbGluZS1oZWlnaHQ6IDEuMjsgcG9pbnRlci1ldmVudHM6IGFsbDsgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1NSwgMjU1LCAyNTUpOyB3aGl0ZS1zcGFjZTogbm93cmFwOyI+MTwvZGl2PjwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48dGV4dCB4PSIxMjIiIHk9IjEzIiBmaWxsPSJyZ2IoMCwgMCwgMCkiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMTFweCI+MTwvdGV4dD48L3N3aXRjaD48L2c+PC9nPjxzd2l0Y2g+PGcgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5Ii8+PGEgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwtNSkiIHhsaW5rOmhyZWY9Imh0dHBzOi8vd3d3LmRpYWdyYW1zLm5ldC9kb2MvZmFxL3N2Zy1leHBvcnQtdGV4dC1wcm9ibGVtcyIgdGFyZ2V0PSJfYmxhbmsiPjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTBweCIgeD0iNTAlIiB5PSIxMDAlIj5UZXh0IGlzIG5vdCBTVkcgLSBjYW5ub3QgZGlzcGxheTwvdGV4dD48L2E+PC9zd2l0Y2g+PC9zdmc+"}}]);