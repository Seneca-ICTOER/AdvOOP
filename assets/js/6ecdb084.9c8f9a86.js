"use strict";(self.webpackChunkoop345=self.webpackChunkoop345||[]).push([[895],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return h}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(n),h=i,m=u["".concat(l,".").concat(h)]||u[h]||c[h]||a;return n?r.createElement(m,o(o({ref:t},d),{},{components:n})):r.createElement(m,o({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var p=2;p<a;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4193:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return d},default:function(){return u}});var r=n(7462),i=n(3366),a=(n(7294),n(3905)),o=["components"],s={id:"raw-pointers",title:"Raw Pointers",sidebar_position:1,description:"TBD"},l="Raw Pointers",p={unversionedId:"F-MemoryModel/raw-pointers",id:"F-MemoryModel/raw-pointers",isDocsHomePage:!1,title:"Raw Pointers",description:"TBD",source:"@site/docs/F-MemoryModel/raw-pointers.md",sourceDirName:"F-MemoryModel",slug:"/F-MemoryModel/raw-pointers",permalink:"/F-MemoryModel/raw-pointers",editUrl:"https://github.com/Seneca-ICTOER/AdvOOP/tree/main/docs/F-MemoryModel/raw-pointers.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"raw-pointers",title:"Raw Pointers",sidebar_position:1,description:"TBD"},sidebar:"courseNotesSidebar",previous:{title:"File Stream Objects",permalink:"/E-STL/file-stream-objects"},next:{title:"Smart Pointers",permalink:"/F-MemoryModel/smart-pointers"}},d=[{value:"C-Style Character Strings",id:"c-style-character-strings",children:[{value:"Element Addresses",id:"element-addresses",children:[],level:3},{value:"String Literals",id:"string-literals",children:[{value:"Copying a String Literal",id:"copying-a-string-literal",children:[],level:4},{value:"Pointing to a String Literal",id:"pointing-to-a-string-literal",children:[],level:4}],level:3}],level:2},{value:"Expressions",id:"expressions",children:[{value:"Arithmetic Operations",id:"arithmetic-operations",children:[{value:"Addition",id:"addition",children:[],level:4},{value:"Subtraction",id:"subtraction",children:[],level:4}],level:3},{value:"Postfix Operations",id:"postfix-operations",children:[{value:"Increment and Decrement",id:"increment-and-decrement",children:[],level:4},{value:"Reference to a Pointer",id:"reference-to-a-pointer",children:[],level:4}],level:3}],level:2},{value:"Exercises",id:"exercises",children:[],level:2}],c={toc:d};function u(e){var t=e.components,s=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,r.Z)({},c,s,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"raw-pointers"},"Raw Pointers"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Create program components using raw pointers and pointer arithmetic")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},'"A memory model is an agreement between the machine architects and the compiler writers to ensure that most programmers do not have to think about the details of modern computer hardware."  Stroustrup (2014)')),(0,a.kt)("p",null,"Programming languages associate objects with memory locations in an abstract machine, letting programmers focus on changes to the values stored in those memory locations without regard to the locations in processor memory on the host computer.  A programming language's memory model defines how any compiler should relate the memory locations in the abstract machine to the physical memory locations in any processor.  The simplest memory model is an address space consisting of a contiguous sequence of bytes, with each address referring to its own byte.  Such a model supports direct access to the underlying processor memory. "),(0,a.kt)("p",null,"The type systems of object-oriented languages associate regions of memory with objects.  Each region associated with an object is a contiguous sequence of bytes.  Each object is stored at a unique address and the object's type determines the region of memory occupied by the object. "),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Memory Map",src:n(7911).Z})),(0,a.kt)("p",null,"In C++, a raw pointer is a built-in type that holds an address of a memory location in the abstract machine.  The pointer provides direct access to the object that occupies the region of memory that ",(0,a.kt)("em",{parentName:"p"},"starts at that address"),".  Dereferencing the pointer accesses the value stored in the region of memory starting at the pointer's address. "),(0,a.kt)("p",null,"This chapter reviews that part of the C++ memory model that describes the memory in the abstract machine through a review of raw pointer syntax.  The description covers C-style null-terminated character strings, which are part of the strings category of the Standard Library, and expressions that take pointer types as their operands. "),(0,a.kt)("h2",{id:"c-style-character-strings"},"C-Style Character Strings"),(0,a.kt)("p",null,"A C-style character string provides the simplest possible analogue for describing the memory that a raw pointer accesses.  These strings are arrays of byte-size elements.  The addresses of consecutive elements differ in value by one.  That is, the memory is byte-addressable memory. "),(0,a.kt)("h3",{id:"element-addresses"},"Element Addresses"),(0,a.kt)("p",null,"The following program displays each character of a C-style character string along with its address in memory:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Element Addresses\n// addresses.cpp\n\n#include <iostream>\n\nint main()\n{\n    const char s[] = "A C string"; \n\n    std::cout << std::hex;\n\n    for (int i = 0; s[i]; i++)\n        std::cout << (int*)&s[i] << " : " << s[i] << std::endl; \n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"37FB78 : A\n37FB79 :\n37FB7A : C\n37FB7B :\n37FB7C : s\n37FB7D : t\n37FB7E : r\n37FB7F : i\n37FB80 : n\n37FB81 : g\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"std::hex")," manipulator specifies the current output format as hexadecimal.  Note that in order to display the address of an element we cast it to an ",(0,a.kt)("inlineCode",{parentName:"p"},"int*")," type.  Without the ",(0,a.kt)("inlineCode",{parentName:"p"},"int*")," cast, the substring starting at the address would display as shown below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Substrings\n// substrings.cpp\n\n#include <iostream>\n\nint main()\n{\n    char s[] = "A C string"; \n\n    for (int i = 0; s[i]; i++)\n        std::cout << &s[i] << " : " << s[i] << std::endl; \n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"A C string : A\nC string :\nC string : C\nstring :\nstring : s\ntring : t\nring : r\ning : i\nng : n\ng : g\n")),(0,a.kt)("p",null,"Displaying a substring starts with the value stored at the address of the first element in the substring and ends once the element's value is the null byte (the value of the C-style character string terminator)."),(0,a.kt)("h3",{id:"string-literals"},"String Literals"),(0,a.kt)("p",null,"A sequence of characters surrounded by double quotes is called a string literal.  A string literal is an lvalue.  It is a primary expression stored in the segment of memory that holds global variables.  The lifetime of this segment is the lifetime of the program.  String literals have static duration. "),(0,a.kt)("h4",{id:"copying-a-string-literal"},"Copying a String Literal"),(0,a.kt)("p",null,"The following program defines a string literal, stores its address in a pointer, defines a C-style character string, copies the contents of the string literal into that second string, changes the first character to lower case and displays the updated string along with the addresses of the pointer and the string:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// String Literal\n// stringLiteral.cpp\n\n#include <iostream>\n#include <cstring>\n\nint main()\n{\n    const char* p = "May be overwritten";\n    char s[19];\n    std::strcpy(s, p);\n\n    s[0] = \'m\';  // OK\n    std::cout << std::hex;\n    std::cout << s << std::endl;\n\n    std::cout << "s = " << (int*)s << std::endl; \n    std::cout << "p = " << (int*)p << std::endl;\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"may be overwritten \ns = 0x7ffcbd568e00\np = 0x400b54\n")),(0,a.kt)("p",null,"Note that the program does not alter the string literal itself. The memory for ",(0,a.kt)("inlineCode",{parentName:"p"},"s")," is distinct from the memory for the string literal ",(0,a.kt)("inlineCode",{parentName:"p"},'"May be overwritten"'),", which we can change."),(0,a.kt)("h4",{id:"pointing-to-a-string-literal"},"Pointing to a String Literal"),(0,a.kt)("p",null,"A string literal is an ",(0,a.kt)("strong",{parentName:"p"},"unmodifiable lvalue"),".  We may not change its contents.  Compare the following program which points to a string literal with the program above:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Pointing to a String Literal\n// ptrToStringLiteral.cpp\n\n#include <iostream>\n\nint main()\n{\n    char *p  = \"Avoid overwriting\"; // poor coding style; newer compilers might flag this line\n\n    p[0] = 'a';  // ISO C++ forbids converting a string constant to a 'char*' \n    std::cout << p << std::endl;\n}\n")),(0,a.kt)("p",null,"The message is a warning.  Execution of the compiled code can cause a segmentation fault. "),(0,a.kt)("p",null,"To trap such errors at compile time, we explicitly qualify the pointer as unmodifiable:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// String Constants\n// ptrToConstStringLiteral.cpp\n\n#include <iostream>\n\nint main()\n{\n    const char *p  = \"Avoid overwriting\"; // good coding style \n\n    p[0] = 'a';  // ERROR: assignment of read-only location '*p'\n    std::cout << p << std::endl;\n}\n")),(0,a.kt)("h2",{id:"expressions"},"Expressions"),(0,a.kt)("p",null,"The operands in various expressions can be raw pointers.  These expressions include:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"subscripting"),(0,a.kt)("li",{parentName:"ul"},"function call"),(0,a.kt)("li",{parentName:"ul"},"indirect selection"),(0,a.kt)("li",{parentName:"ul"},"postfix increment, decrement"),(0,a.kt)("li",{parentName:"ul"},"constrained casts"),(0,a.kt)("li",{parentName:"ul"},"prefix increment, decrement"),(0,a.kt)("li",{parentName:"ul"},"sizeof"),(0,a.kt)("li",{parentName:"ul"},"address of"),(0,a.kt)("li",{parentName:"ul"},"indirection"),(0,a.kt)("li",{parentName:"ul"},"type casting"),(0,a.kt)("li",{parentName:"ul"},"object, pointer to member pointer"),(0,a.kt)("li",{parentName:"ul"},"additive"),(0,a.kt)("li",{parentName:"ul"},"relational, equality, inequality"),(0,a.kt)("li",{parentName:"ul"},"logical and, or"),(0,a.kt)("li",{parentName:"ul"},"conditional"),(0,a.kt)("li",{parentName:"ul"},"compound type-wise addition, subtraction")),(0,a.kt)("p",null,"Two groups are of particular interest:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"arithmetic operations"),(0,a.kt)("li",{parentName:"ul"},"postfix operations")),(0,a.kt)("h3",{id:"arithmetic-operations"},"Arithmetic Operations"),(0,a.kt)("h4",{id:"addition"},"Addition"),(0,a.kt)("p",null,"A binary expression with the addition operator (",(0,a.kt)("inlineCode",{parentName:"p"},"+"),") adds the values of its operands.  If one of the operands is of pointer type, the other must be of integral or unscoped enumeration type.  The expression evaluates to the address that is the number of types beyond the address stored in the pointer operand.  That is, the integral operand gives the offset in types (not bytes).  For example,"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Pointer Addition\n// pointerAddition.cpp\n\n#include <iostream>\n\nint main()\n{\n    double a[] = {1.1, 2.2, 3.3, 4.4 , 5.5};\n    int i = 2;\n    double* p;\n\n    p = &a[1];\n    std::cout << std::hex;\n    std::cout << a[0]     << " : " << a     << std::endl; \n    std::cout << *(p + i) << " : " << p + i << std::endl; \n    std::cout << p[i]     << " : " << &p[i] << std::endl;\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"1.1 : 0037F99C \n4.4 : 0037F9B4\n4.4 : 0037F9B4\n")),(0,a.kt)("p",null,"Note that the difference between ",(0,a.kt)("inlineCode",{parentName:"p"},"0037F9B4")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"0037F99C")," is 18 hexadecimal or 24 decimal; that is, 3 doubles."),(0,a.kt)("p",null,"An addition expression with a pointer operand evaluates to a defined value as long as the result of the addition points to an element of the array or to the location that is one element beyond the end of the array.  Otherwise, the expression is ill-defined."),(0,a.kt)("h4",{id:"subtraction"},"Subtraction"),(0,a.kt)("p",null,"A binary expression with the subtraction operator (",(0,a.kt)("inlineCode",{parentName:"p"},"-"),") subtracts the value of rightmost operand from the value of the leftmost operand.  If the left operand is of pointer type, the right operand must be either of integral or of the same pointer type.  The result of subtracting an integral type from a pointer type is the address that is the number of pointed-to types before the address stored in the left operand.  The result of subtracting a pointer type from another pointer type is an integer of synonym type ",(0,a.kt)("inlineCode",{parentName:"p"},"ptrdiff_t"),".  The integer holds the number of types between the two addresses.  ",(0,a.kt)("inlineCode",{parentName:"p"},"ptrdiff_t")," is defined in the ",(0,a.kt)("inlineCode",{parentName:"p"},"<cstddef>")," header file.  For example,"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Pointer Subtraction\n// pointerSubtraction.cpp\n\n#include <iostream>\n#include <cstddef>\n\nint main()\n{\n    int a[] = {1,2,3,4,5}, i = 2, *p, *r;\n    ptrdiff_t k;\n\n    p = &a[4];\n    r = &a[0];\n    k = p - r; // difference between addresses\n    std::cout << *(p - i) << std::endl; // value at address i types before *p \n    std::cout << k << std::endl;\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"3\n4\n")),(0,a.kt)("p",null,"An expression that subtracts one pointer from another has a defined value if both pointers point to elements of the same array or if one points to an element of the array and the other points to the location that is one element beyond the end of the same array.  Otherwise, the expression is ill-defined."),(0,a.kt)("h3",{id:"postfix-operations"},"Postfix Operations"),(0,a.kt)("h4",{id:"increment-and-decrement"},"Increment and Decrement"),(0,a.kt)("p",null,"Postfix expressions are useful for moving between adjacent type.  For example, the following function determines the length of a C-style, null-terminated string.  Execution leaves the ",(0,a.kt)("inlineCode",{parentName:"p"},"while")," loop once it encounters the null byte (",(0,a.kt)("inlineCode",{parentName:"p"},"*s == '\\0'"),").  In this example, each type is of one-byte length:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"unsigned length(const char *s)\n{\n    unsigned len = 0u;\n    while (*s++) len++;\n    return len;\n}\n")),(0,a.kt)("p",null,"Note that the dereferencing operator ",(0,a.kt)("inlineCode",{parentName:"p"},"*")," has lower precedence than the post-fix operator ",(0,a.kt)("inlineCode",{parentName:"p"},"++"),".  This means that the expression ",(0,a.kt)("inlineCode",{parentName:"p"},"*s++")," is evaluated as ",(0,a.kt)("inlineCode",{parentName:"p"},"*(s++)"),".  That is, the condition increments the address stored in pointer ",(0,a.kt)("inlineCode",{parentName:"p"},"s")," to point to the next byte, retrieves the value stored in that address, and checks that value against ",(0,a.kt)("inlineCode",{parentName:"p"},"nullptr"),". "),(0,a.kt)("h4",{id:"reference-to-a-pointer"},"Reference to a Pointer"),(0,a.kt)("p",null,"A reference to a pointer lets us change the address that has been stored in a pointer outside a function from within the function in the same way that a reference to a variable that holds a value.  For example,"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'// Reference to a Pointer\n// ref_to_ptr.cpp\n\n#include <iostream>\n\nvoid swap(int*& a, int*& b)\n{\n    int* t = a;\n    a = b;\n    b = t;\n}\n\nint main()\n{\n    int x, y;\n    int* p = &x;\n    int* q = &y;\n\n    std::cout << "p = " << p << std::endl; \n    std::cout << "q = " << q << std::endl;\n\n    swap(p, q);\n\n    std::cout << "p = " << p << std::endl;\n    std::cout << "q = " << q << std::endl;\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"p = 0040F850\nq = 0040F84C\n\np = 0040F84C \nq = 0040F850\n")),(0,a.kt)("h2",{id:"exercises"},"Exercises"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Read Wikipedia on ",(0,a.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Raw_pointer#raw_pointer"},"Pointers"))))}u.isMDXComponent=!0},7911:function(e,t,n){t.Z=n.p+"assets/images/memory-1c96bdc4575afb11f5ba4f834576ad1e.png"}}]);