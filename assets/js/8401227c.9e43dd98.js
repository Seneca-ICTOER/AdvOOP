"use strict";(self.webpackChunkoop345=self.webpackChunkoop345||[]).push([[465],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return u}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(a),u=i,h=d["".concat(s,".").concat(u)]||d[u]||m[u]||o;return a?n.createElement(h,r(r({ref:t},p),{},{components:a})):n.createElement(h,r({ref:t},p))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var c=2;c<o;c++)r[c]=a[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},9312:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return p},default:function(){return d}});var n=a(7462),i=a(3366),o=(a(7294),a(3905)),r=["components"],l={id:"overview",title:"Overview",sidebar_position:1,description:"TBD"},s="Overview",c={unversionedId:"A-Introduction/overview",id:"A-Introduction/overview",isDocsHomePage:!1,title:"Overview",description:"TBD",source:"@site/docs/A-Introduction/overview.md",sourceDirName:"A-Introduction",slug:"/A-Introduction/overview",permalink:"/A-Introduction/overview",editUrl:"https://github.com/Seneca-ICTOER/AdvOOP/tree/main/docs/A-Introduction/overview.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"overview",title:"Overview",sidebar_position:1,description:"TBD"},sidebar:"courseNotesSidebar",previous:{title:"Table of contents",permalink:"/"},next:{title:"C++ Building Blocks",permalink:"/A-Introduction/cpp-building-blocks"}},p=[{value:"Introduction",id:"introduction",children:[],level:2},{value:"OBJECT-ORIENTED PARADIGM",id:"object-oriented-paradigm",children:[{value:"Three Concepts",id:"three-concepts",children:[{value:"Encapsulation",id:"encapsulation",children:[],level:4},{value:"Inheritance",id:"inheritance",children:[],level:4},{value:"Polymorphism",id:"polymorphism",children:[],level:4}],level:3},{value:"Modularity",id:"modularity",children:[],level:3}],level:2},{value:"BUILDING BLOCKS",id:"building-blocks",children:[{value:"Types",id:"types",children:[{value:"Type Categories",id:"type-categories",children:[],level:4}],level:3},{value:"Declarations",id:"declarations",children:[{value:"Scope",id:"scope",children:[],level:4},{value:"Linkage",id:"linkage",children:[],level:4}],level:3}],level:2},{value:"COMPILERS",id:"compilers",children:[{value:"Type System",id:"type-system",children:[],level:3},{value:"Compiling, Linking and Executing",id:"compiling-linking-and-executing",children:[{value:"Statically and Dynamically Allocated",id:"statically-and-dynamically-allocated",children:[],level:4},{value:"Memory Distinctions",id:"memory-distinctions",children:[],level:4}],level:3}],level:2},{value:"THE TOPIC GROUPINGS",id:"the-topic-groupings",children:[],level:2},{value:"EXERCISES",id:"exercises",children:[],level:2}],m={toc:p};function d(e){var t=e.components,l=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,n.Z)({},m,l,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"overview"},"Overview"),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Review object-oriented concepts"),(0,o.kt)("li",{parentName:"ul"},"Introduce terms that describe the building blocks of an object-oriented language"),(0,o.kt)("li",{parentName:"ul"},"Review the role of compilers"),(0,o.kt)("li",{parentName:"ul"},"Present an overview of the course")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},'"Surprisingly, C++11 feels like a new language: The pieces just fit together better than they used to and I find a higher-level style of programming more natural than before and as efficient as ever. If you timidly approach C++ as just a better C or as an object-oriented language, you are going to miss the point. The abstractions are simply more flexible and affordable than before." Stroustrup (2014)')),(0,o.kt)("p",null,"Object-oriented programming is a computer programming paradigm for solving problems using objects and relationships between them.  The objects are designed independently of one another and can be shared across a range of solutions that satisfy similar requirements.  Object-oriented programming is well suited to application development, notably, large-scale application development. "),(0,o.kt)("p",null,"This chapter reviews the object-oriented programming paradigm, introduces some of the building blocks common to many object-oriented languages, reviews the role of the compiler and summarizes the topics covered in this volume."),(0,o.kt)("h2",{id:"object-oriented-paradigm"},"OBJECT-ORIENTED PARADIGM"),(0,o.kt)("p",null,"The object-oriented paradigm frames programming solutions as sets of objects that interact with one another in their problem domain.  Objects are instances of classes, where a class defines the structure of an object.  Each object has its own ",(0,o.kt)("strong",{parentName:"p"},"state"),", which is stored in the form of the values of its ",(0,o.kt)("em",{parentName:"p"},"instance variables")," or ",(0,o.kt)("em",{parentName:"p"},"attributes"),".  The functions that operate on an object's state are the ",(0,o.kt)("em",{parentName:"p"},"member functions")," or ",(0,o.kt)("em",{parentName:"p"},"methods")," of the class to which the object belongs."),(0,o.kt)("h3",{id:"three-concepts"},"Three Concepts"),(0,o.kt)("p",null,"Object-oriented languages offer three high-level features for programming solutions:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"encapsulation"),(0,o.kt)("li",{parentName:"ul"},"inheritance"),(0,o.kt)("li",{parentName:"ul"},"polymorphism")),(0,o.kt)("h4",{id:"encapsulation"},"Encapsulation"),(0,o.kt)("p",null,"Encapsulation couples an object's data to the logic of its class.  The class' member functions or methods define its logic.  Typically, an object's data remains private to its class.  Privacy helps preserve the object's integrity. "),(0,o.kt)("p",null,"Encapsulation can be either weak or strong:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"weak encapsulation")," couples state and logic without implementing privacy;"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"strong encapsulation")," couples state and logic and restricts access to an object's state. ")),(0,o.kt)("h4",{id:"inheritance"},"Inheritance"),(0,o.kt)("p",null,"Inheritance is the relationship between classes where one class inherits the entire structure of another class.  The base class defines the structure to be inherited by derived classes or sub-classes. Each derived class defines the features to be added to the base class.  The inherited features are the instance variables and logic of the base class.  The additional features are the added instance variables and added logic. "),(0,o.kt)("h4",{id:"polymorphism"},"Polymorphism"),(0,o.kt)("p",null,"Polymorphism supports the multiplicity of behaviors for an identifier in an inheritance hierarchy.  Multiple behaviors are associated with the same identifier.  These behaviors are distinguished through an object's dynamic type.  The language selects the behavior for the identifier that is appropriate to the dynamic type.  The dynamic type of an object may change throughout the identifier's lifetime.  As the type changes, the behavior associated with the identifier may change. "),(0,o.kt)("p",null,"This flexibility is a distinguishing feature of object-oriented languages."),(0,o.kt)("h3",{id:"modularity"},"Modularity"),(0,o.kt)("p",null,"Object-oriented solutions lend themselves naturally to modular partitioning of source code.  Modules define classes and their implementations.  The source code for a module is stored in a file or file set.  The file or file set holds a self-contained partition of that source code.  Each module is compiled separately."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"&quot;TODO&quot;",src:a(669).Z})),(0,o.kt)("p",null,"Updates to a specific module only require recompilation of that module along with those directly affected by the changes in the class definition.  All other modules need not be recompiled."),(0,o.kt)("h2",{id:"building-blocks"},"BUILDING BLOCKS"),(0,o.kt)("p",null,"The common building blocks of an object-oriented language include:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"values"),(0,o.kt)("li",{parentName:"ul"},"objects"),(0,o.kt)("li",{parentName:"ul"},"variables"),(0,o.kt)("li",{parentName:"ul"},"references"),(0,o.kt)("li",{parentName:"ul"},"functions"),(0,o.kt)("li",{parentName:"ul"},"types"),(0,o.kt)("li",{parentName:"ul"},"class members"),(0,o.kt)("li",{parentName:"ul"},"templates"),(0,o.kt)("li",{parentName:"ul"},"namespaces")),(0,o.kt)("p",null,"An ",(0,o.kt)("em",{parentName:"p"},"object")," occupies a region of memory, holds a value and may have a name, but does not necessarily have a name."),(0,o.kt)("p",null,"A ",(0,o.kt)("em",{parentName:"p"},"variable")," is a named object.  It occupies a region of memory, holds a value and has a name. "),(0,o.kt)("p",null,"The ",(0,o.kt)("em",{parentName:"p"},"value")," that an object holds is the contents of the memory region allocated to the object and defines its current state."),(0,o.kt)("h3",{id:"types"},"Types"),(0,o.kt)("p",null,"The type of an object relates the object to its underlying implementation and identifies the operations that the object can perform."),(0,o.kt)("p",null,'!["Object Type Implementation"]',"(/img/type definition.png)"),(0,o.kt)("h4",{id:"type-categories"},"Type Categories"),(0,o.kt)("p",null,"The types supported by an object-oriented language can be classified into categories based on their relationship to the underlying hardware facilities:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"fundamental types: correspond directly to the hardware facilities"),(0,o.kt)("li",{parentName:"ul"},"built-in types: reflect the capabilities of the hardware facilities directly and efficiently"),(0,o.kt)("li",{parentName:"ul"},"user-defined types",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"concrete types: their representation is part of their definition and is known"),(0,o.kt)("li",{parentName:"ul"},"abstract types: their representation is not part of their definition and is unknown")))),(0,o.kt)("h3",{id:"declarations"},"Declarations"),(0,o.kt)("p",null,"A declaration introduces a name into a program and associates that name with a type.  The name is visible within the part of the program.  That part of the program is called the name's ",(0,o.kt)("em",{parentName:"p"},"scope"),"."),(0,o.kt)("h4",{id:"scope"},"Scope"),(0,o.kt)("p",null,"The scope of a name extends from its declaration to the end of the code block within which the name has been declared.  A ",(0,o.kt)("em",{parentName:"p"},"block")," is a delimited set of program instructions.  Methods of delimiting a block vary across languages. "),(0,o.kt)("p",null,"The scope of a name may be any one of:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"local scope: the name has been declared within a function or code block"),(0,o.kt)("li",{parentName:"ul"},"class scope: the name has been declared as a member of a class"),(0,o.kt)("li",{parentName:"ul"},"namespace scope: the name has been declared as a member of a named block"),(0,o.kt)("li",{parentName:"ul"},"global scope: the name has not been declared in any one of the above scopes")),(0,o.kt)("h4",{id:"linkage"},"Linkage"),(0,o.kt)("p",null,"A name has a ",(0,o.kt)("em",{parentName:"p"},"linkage")," if it can refer to an identical name declared in another scope.  Linkage is optional.  That is, the same name may refer to the same entity across different scopes.  The name's linkage identifies its connectivity."),(0,o.kt)("p",null,"The linkage of a name may be"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"external - connected across different scopes in different modules\n",'!["External Linkage"]',"(/img/external linkage.png)"),(0,o.kt)("li",{parentName:"ul"},"internal - connected across different scopes within the same module\n",'!["Internal Linkage"]',"(/img/Internal linkage.png)"),(0,o.kt)("li",{parentName:"ul"},"non-existent - not connected to any entity outside its own scope\n",'!["No Linkage"]',"(/img/no linkage.png)")),(0,o.kt)("h2",{id:"compilers"},"COMPILERS"),(0,o.kt)("p",null,"Compilers translate the source code of modules into binary code that is assembled to form a single executable version of program.  The source code of a module is written in a specific language.  Compilers are language specific programs. "),(0,o.kt)("p",null,"Many languages are defined by an international standard.  A language standard is an agreement amongst compiler writers, consultants, application programmers, and academics to implement a well-defined, minimal subset of the language used by the programming community at large.  Coding to a language standard maximizes source code ",(0,o.kt)("em",{parentName:"p"},"portability"),": a fully portable program compiles and runs without modification in a switch from one compiler to another. "),(0,o.kt)("h3",{id:"type-system"},"Type System"),(0,o.kt)("p",null,"Compilers use the type system of their programming language to translate source code into binary code.  The type system provides consistency across the language's building blocks and identifies the operations that are admissible in forming expressions.  The type system enables the compiler to check whether or not the relations between the building blocks are well-formed.  The type system describes how to interpret the bit strings in memory.  Source code that breaks the type system exposes the underlying bit strings in memory and thereby introduces uncertainty.  In such cases how the compiler interprets the contents of memory is undefined. "),(0,o.kt)("p",null,"The admissible operations on fundamental and built-in types are defined as part of the core of a language.  The admissible operations on the user-defined types of an object-oriented language are specified by the programmer in the definition of those types.  The compiler reports errors where the relations between these types are ill-formed. "),(0,o.kt)("h3",{id:"compiling-linking-and-executing"},"Compiling, Linking and Executing"),(0,o.kt)("p",null,"Source code may include some instructions that depend on information that is only available during the execution of the binary code.  Programming such source code involves distinguishing times at which to check for compliance with the type system."),(0,o.kt)("p",null,"Verification of type compliance can occur at"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"compile-time - during the compiler's translation of a module's source code into binary code"),(0,o.kt)("li",{parentName:"ul"},"link-time - during the linker's assembly of the binary code components for the modules that constitute an application, or"),(0,o.kt)("li",{parentName:"ul"},"run-time - during the user's execution of the binary executable. ")),(0,o.kt)("h4",{id:"statically-and-dynamically-allocated"},"Statically and Dynamically Allocated"),(0,o.kt)("p",null,"In these notes, the terms ",(0,o.kt)("em",{parentName:"p"},"statically")," and ",(0,o.kt)("em",{parentName:"p"},"dynamically")," distinguish what can be determined at compile-time from what needs to be determined at run-time."),(0,o.kt)("p",null,"The term ",(0,o.kt)("em",{parentName:"p"},"statically")," refers to anything that the compiler itself can determine for the module being translated without any link-time or run-time information.  As programmers, we seek to translate and type-check as much of the source code as possible at compile-time.  We refer to this as static type-checking and refer to a language that performs type-checking at compile-time as a statically typed language."),(0,o.kt)("p",null,"The term ",(0,o.kt)("em",{parentName:"p"},"dynamically")," refers to anything that is determined during execution.  As programmers, we refer to type-checking of dynamically allocated memory as dynamic type-checking and refer to a language that performs type-checking at run-time as a dynamically typed language."),(0,o.kt)("h4",{id:"memory-distinctions"},"Memory Distinctions"),(0,o.kt)("p",null,"When an operating system loads an executable program into memory, it places the different parts of the program into different segments:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"code segment - stores the program instructions"),(0,o.kt)("li",{parentName:"ul"},"data segments - store data that survives the lifetime of the program"),(0,o.kt)("li",{parentName:"ul"},"stack segment - stores local data that is statically allocated"),(0,o.kt)("li",{parentName:"ul"},"heap segment - stores local data that is dynamically allocated")),(0,o.kt)("p",null,"The size of ",(0,o.kt)("em",{parentName:"p"},"statically allocated memory")," is known at compile-time.  The compiler inserts the code to allocate this memory on the stack or data segment.  Statically allocated memory is fast and deallocates automatically but cannot grow or shrink in size. "),(0,o.kt)("p",null,"The size of ",(0,o.kt)("em",{parentName:"p"},"dynamically allocated memory")," may be of variable size.  This memory is allocated at run-time.  The operating system provides this memory to the executable program in the size requested at that time.  This memory is allocated on the heap, managed by the freestore manager and needs to be returned to the manager before it can be reused by the executable for some other purpose. "),(0,o.kt)("p",null,"Most systems allocate heap and stack memory for an executable next to one another.  In fact, on most systems, heap and stack memory expand in one another's direction as required. "),(0,o.kt)("p",null,"Memory organization varies between operating systems and compilers.  Possible organizations are shown below."),(0,o.kt)("p",null,'!["Allocation of Memory for an Application by the Operating System"]',"(/img/memory organization.png)"),(0,o.kt)("h2",{id:"the-topic-groupings"},"THE TOPIC GROUPINGS"),(0,o.kt)("p",null,"The material covered in these notes is organized under six groups.  Each group addresses a distinct aspect of object-oriented programming and is a collection of several chapters.  These groups are entitled:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Introduction - this overview, the building blocks of C++ and the compilation process"),(0,o.kt)("li",{parentName:"ul"},"Types - fundamental types, built-in types, class and enumeration types"),(0,o.kt)("li",{parentName:"ul"},"Class Relationships - inheritance, templates, compositions, aggregations and associations"),(0,o.kt)("li",{parentName:"ul"},"Processing - expressions, functions and error handling and reporting"),(0,o.kt)("li",{parentName:"ul"},"The C++ Standard Library - containers, iterators, algorithms, streams, pointers, and threads"),(0,o.kt)("li",{parentName:"ul"},"Deeper Detail - pre-processor directives, arrays and pointers, multiple inheritance, bit-wise expressions, linked list technologies")),(0,o.kt)("h2",{id:"exercises"},"EXERCISES"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Install the ",(0,o.kt)("inlineCode",{parentName:"li"},"Microsoft Visual Studio")," compiler on your Windows computer"),(0,o.kt)("li",{parentName:"ul"},"Install an ",(0,o.kt)("inlineCode",{parentName:"li"},"ssh")," client on your local computer to access a ",(0,o.kt)("inlineCode",{parentName:"li"},"GCC")," platform"),(0,o.kt)("li",{parentName:"ul"},"Read ",(0,o.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Object-oriented_programming"},"Wikipedia")," on Object-Oriented Languages."),(0,o.kt)("li",{parentName:"ul"},"Read ",(0,o.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/C%2B%2B"},"Wikipedia")," on C++.")))}d.isMDXComponent=!0},669:function(e,t,a){t.Z=a.p+"assets/images/application-ad7d21941338fc7ad1a799b316c9a179.png"}}]);