"use strict";(self.webpackChunkoop345=self.webpackChunkoop345||[]).push([[420],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var a=t(7294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,s=function(e,n){if(null==e)return{};var t,a,s={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,s=e.mdxType,i=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=c(t),m=s,h=p["".concat(l,".").concat(m)]||p[m]||d[m]||i;return t?a.createElement(h,r(r({ref:n},u),{},{components:t})):a.createElement(h,r({ref:n},u))}));function m(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var i=t.length,r=new Array(i);r[0]=p;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o.mdxType="string"==typeof e?e:s,r[1]=o;for(var c=2;c<i;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},4539:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return p}});var a=t(7462),s=t(3366),i=(t(7294),t(3905)),r=["components"],o={id:"classes-and-scoped-enumerations",title:"Classes and Scoped Enumerations",sidebar_position:3,description:"TBD"},l="Classes and Scoped Enumerations",c={unversionedId:"B-Types/classes-and-scoped-enumerations",id:"B-Types/classes-and-scoped-enumerations",isDocsHomePage:!1,title:"Classes and Scoped Enumerations",description:"TBD",source:"@site/docs/B-Types/classes-and-scoped-enumerations.md",sourceDirName:"B-Types",slug:"/B-Types/classes-and-scoped-enumerations",permalink:"/B-Types/classes-and-scoped-enumerations",editUrl:"https://github.com/Seneca-ICTOER/AdvOOP/tree/main/docs/B-Types/classes-and-scoped-enumerations.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"classes-and-scoped-enumerations",title:"Classes and Scoped Enumerations",sidebar_position:3,description:"TBD"},sidebar:"courseNotesSidebar",previous:{title:"Pointers, References and Arrays",permalink:"/B-Types/pointers-references-and-arrays"},next:{title:"Inheritance and Inclusion Polymorphism",permalink:"/C-Class-Relationships/inheritance-and-inclusion-polymorphism"}},u=[{value:"Class Basics",id:"class-basics",children:[{value:"Declarations and Definitions",id:"declarations-and-definitions",children:[{value:"Class Definitions",id:"class-definitions",children:[],level:4},{value:"Sub-Object Declarations",id:"sub-object-declarations",children:[],level:4},{value:"Forward Declarations",id:"forward-declarations",children:[],level:4},{value:"Instance Definitions",id:"instance-definitions",children:[],level:4}],level:3},{value:"Data Member Initialization",id:"data-member-initialization",children:[{value:"Default Member Initializers",id:"default-member-initializers",children:[],level:4},{value:"Member List Initializers",id:"member-list-initializers",children:[],level:4},{value:"Example",id:"example",children:[],level:4}],level:3},{value:"Copying",id:"copying",children:[{value:"Copy Construction and Copy Assignment",id:"copy-construction-and-copy-assignment",children:[],level:4}],level:3},{value:"Anonymous Classes",id:"anonymous-classes",children:[],level:3}],level:2},{value:"Move Operators",id:"move-operators",children:[],level:2},{value:"Class Members",id:"class-members",children:[{value:"Class Variables",id:"class-variables",children:[],level:3},{value:"Class Functions",id:"class-functions",children:[],level:3}],level:2},{value:"Structs and Unions",id:"structs-and-unions",children:[{value:"Structs",id:"structs",children:[],level:3},{value:"Unions",id:"unions",children:[],level:3}],level:2},{value:"Enumerations",id:"enumerations",children:[{value:"Plain Enumerations",id:"plain-enumerations",children:[],level:3},{value:"Tracking Access in Unions Using Structs and Enumerations",id:"tracking-access-in-unions-using-structs-and-enumerations",children:[],level:3},{value:"Scoped Enumerations",id:"scoped-enumerations",children:[],level:3},{value:"Underlying Types",id:"underlying-types",children:[],level:3},{value:"Modifying an Enumeration",id:"modifying-an-enumeration",children:[],level:3},{value:"Exercises",id:"exercises",children:[],level:3}],level:2}],d={toc:u};function p(e){var n=e.components,t=(0,s.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"classes-and-scoped-enumerations"},"Classes and Scoped Enumerations"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Describe user-defined types including both class and enumerator types"),(0,i.kt)("li",{parentName:"ul"},"Introduce move constructors and move assignment operators for class types")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'"The C++ programming language ... provides powerful and flexible mechanisms for abstraction; that is, language constructs that allow the programmer to introduce and use new types of objects that match the concepts of an application." Stroustrup (1999)')),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"User-defined types")," are types that we construct from fundamental, built-in and possibly other user-defined types, using the abstraction mechanisms of the programming language. The user-defined types of the C++ language can be divided into two groups: ",(0,i.kt)("strong",{parentName:"p"},"classes")," and ",(0,i.kt)("strong",{parentName:"p"},"enumerations"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Class types represent data that has its own dedicated logic. Class types encapsulate their own logic, protect their objects' data through access modifiers and manage access to that data through public member functions."),(0,i.kt)("li",{parentName:"ul"},"Enumeration types represent sets of discrete values using symbolic names, which makes the source code more readable and less error-prone.")),(0,i.kt)("p",null,"This chapter reviews class definitions, construction, copying and assigning of objects that are instances of classes, and introduces move-constructors and move-assignment operators along with class variables, class functions. This chapter concludes with an introduction to enumerations: both plain and scoped."),(0,i.kt)("h2",{id:"class-basics"},"Class Basics"),(0,i.kt)("p",null,"A class is a set of types. Unlike an array, the data types defined in a class need not be identical. The function types define the class logic. The data and function types constitute the ",(0,i.kt)("em",{parentName:"p"},"members")," of the class. A class does not necessarily store its data members contiguously in a region of memory. Gaps may exist between the data members to satisfy alignment requirements. The compiler inserts holes/padding between the data members or between the last data member and the end of the class instance, as required. Such holes/padding are unpredictable and implementation defined."),(0,i.kt)("p",null,"C++ specifies a class type using one of three class-keys:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"class")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"struct")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"union"))),(0,i.kt)("p",null,"The class-key class identifies a class that is strongly encapsulated. The members of a ",(0,i.kt)("inlineCode",{parentName:"p"},"class")," are private by default, which facilitates the hiding of their information."),(0,i.kt)("p",null,"The class-keys ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"union")," identify classes that are weakly encapsulated. The members of a ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"union")," are public by default, which facilitates the sharing of their information."),(0,i.kt)("h3",{id:"declarations-and-definitions"},"Declarations and Definitions"),(0,i.kt)("h4",{id:"class-definitions"},"Class Definitions"),(0,i.kt)("p",null,"A class definition introduces a type into a scope. The definition declares the sub-objects of the class and its member function types. The definition takes the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class-key Identifier\n{\n    sub-object declarations\n\n    member function declarations\n};\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"Identifier")," is the name of the class."),(0,i.kt)("h4",{id:"sub-object-declarations"},"Sub-Object Declarations"),(0,i.kt)("p",null,"The sub-object declarations in a class definition refer to other types (data members), which may including types that point to instances of the class itself. For example, the definition of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Subject")," class may include a data member of ",(0,i.kt)("inlineCode",{parentName:"p"},"Subject*")," type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Subject\n{\n    unsigned number;\n    char desc[41];\n    Subject* prerequisite; // OK\n};\n")),(0,i.kt)("p",null,"A class definition may not include a sub-object declaration the same type. For example, the definition of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Subject")," class may not declare a sub-object of ",(0,i.kt)("inlineCode",{parentName:"p"},"Subject")," type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Subject\n{\n    unsigned number;\n    char desc[41];\n    Subject subject; // ERROR\n};\n")),(0,i.kt)("p",null,"Such an inclusion would be infinitely recursive: the type would include itself, which would include itself, ... and the amount of memory required by an instance of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Subject")," cannot be calculated."),(0,i.kt)("h4",{id:"forward-declarations"},"Forward Declarations"),(0,i.kt)("p",null,"A forward class declaration introduces a new type to a scope, without declaring the sub-objects or member function types of that class. The declaration simply informs the compiler that the name of the class is a valid name. A forward declaration takes the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class-key Identifier;\n")),(0,i.kt)("h4",{id:"instance-definitions"},"Instance Definitions"),(0,i.kt)("p",null,"We may combine a class definition with the definition of one or more instances of that class in a single compound statement. We do so by inserting the instance identifier between the closing brace of the definition and the semi-colon:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class-key Identifier\n{\n    sub-object declarations\n\n    member function declarations\n} object;\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"object")," is the name of the instance of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Identifier"),"."),(0,i.kt)("p",null,"The following class definition defines both an instance named ",(0,i.kt)("inlineCode",{parentName:"p"},"subject")," and a pointer to an instance named ",(0,i.kt)("inlineCode",{parentName:"p"},"pSubject"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Subject\n{\n    unsigned number;\n    char desc[41];\n} subject, *pSubject;\n")),(0,i.kt)("h3",{id:"data-member-initialization"},"Data Member Initialization"),(0,i.kt)("p",null,"We can initialize modifiable non-static data members in three ways:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"in the member declaration (default member initializers)"),(0,i.kt)("li",{parentName:"ul"},"in the member-list initializers when implementing the constructor"),(0,i.kt)("li",{parentName:"ul"},"in the constructor body")),(0,i.kt)("p",null,"We cannot initialize unmodifiable data members in the constructor's body, but can initialize them in the first two ways."),(0,i.kt)("h4",{id:"default-member-initializers"},"Default Member Initializers"),(0,i.kt)("p",null,"A class definition can initialize its data members directly through default member initializers, which are either a braces-enclosed values or lists of comma-separated values or an equals initializers on the member declaration itself."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class-key Identifier\n{\n    sub-object declaration   {initial value}; // braces-enclosed - type-safe\n    sub-object declaration = {initial value}; // braces-enclosed - type-safe\n    sub-object declaration =  initial value;  // equals initializer\n    sub-object declaration   {initial value, ... }; // braces-enclosed list\n    sub-object declaration = {initial value, ... }; // braces-enclosed list\n\n    member function declarations\n};\n")),(0,i.kt)("p",null,"The comma and ellipsis denote further initial values."),(0,i.kt)("h4",{id:"member-list-initializers"},"Member List Initializers"),(0,i.kt)("p",null,"Any constructor of a class can initialize a data member directly. Initialization takes the form of the data member's name followed by the initial value enclosed within braces. Initializations can happen ",(0,i.kt)("strong",{parentName:"p"},"only")," when implementing the constructor, are comma-separated, and follow a single colon after the closing parenthesis of the constructor's prototype:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"Class-name(type x, ...) : data-member-name{x},...\n{\n    // any logic\n}\n")),(0,i.kt)("p",null,"The comma and ellipsis denote further initializations."),(0,i.kt)("h4",{id:"example"},"Example"),(0,i.kt)("p",null,"The program"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Initializing Data Members\n// initialize.cpp\n\n#include <iostream>\n#include <string>\n\nint nItems = 0;\n\nclass Item\n{\n    int item = ++nItems;              // default initializer\n    const std::string name {\"empty\"}; // default initializer\npublic:\n    Item() {}                                        // 2 defaults\n    Item(const char* n) : name{n} {}                 // 1 member-list initializer, 1 default\n    Item(const char* n, int i) : name{n}, item{i} {} // 2 member-list initializers, 0 defaults\n\n    const char* itemName() const { return name.c_str(); }\n    int itemNo() const { return item; }\n};\n\nint main()\n{\n    std::cout << nItems << std::endl;\n    Item a;\n    std::cout << a.itemName() << ' ' << a.itemNo() << '\\n';\n\n    Item b(\"apple\");\n    std::cout << b.itemName() << ' ' << b.itemNo() << '\\n';\n\n    Item c(\"grape\", 6);\n    std::cout << c.itemName() << ' ' << c.itemNo() << '\\n';\n\n    std::cout << nItems << std::endl;\n}\n")),(0,i.kt)("p",null,"produces the output"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"0\nempty 1\napple 2\ngrape 6\n2\n")),(0,i.kt)("p",null,"A data initializer on an instance variable is slightly more efficient than the equivalent logic within the constructor's body."),(0,i.kt)("h3",{id:"copying"},"Copying"),(0,i.kt)("h4",{id:"copy-construction-and-copy-assignment"},"Copy Construction and Copy Assignment"),(0,i.kt)("p",null,"Classes that include resources manage them through user-defined copy constructors, copy-assignment operators and destructors. In the following example, member initialization syntax simplifies the coding of these special member functions. The C++ language allows dynamic memory allocation of 0 (zero) elements, but requires its destruction to complement it."),(0,i.kt)("p",null,"The program below"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Copy-Construction, Copy-Assignment and Subscripting Operator\n// copy_assign.cpp\n#include <iostream>\n\nclass Array\n{\n    int* a = nullptr;\n    unsigned n = 0u;\n    int dummy = 0;\n\npublic:\n    Array(){}\n    Array(unsigned no) : a(new int[no]), n(no) {}\n    Array(const Array& src) { *this = src; }\n\n    Array& operator=(const Array& src)\n    {\n        if (this != &src)\n        {\n            delete [] a;\n            n = src.n;\n            dummy = src.dummy;\n            a = new int[src.n];\n            for (unsigned i = 0u; i < src.n; ++i)\n                a[i] = src.a[i];\n        }\n        return *this;\n    }\n\n    ~Array() { delete [] a; }\n\n    int& operator[](unsigned i)\n    {\n        return n > 0u && i < n ? a[i] : dummy;\n    }\n\n    int operator[](unsigned i) const\n    {\n        return n > 0u && i < n ? a[i] : dummy;\n    }\n\n    unsigned size() const { return n; }\n};\n\n\nint main()\n{\n    const unsigned size = 5;\n    Array a(size), b;\n\n    for (unsigned i = 0u; i < a.size(); ++i)\n        a[i] = 3 * i;\n\n    for (unsigned i = 0u; i < a.size(); ++i)\n        std::cout << a[i] << ' ';\n    std::cout << std::endl;\n\n    b = a;\n\n    for (unsigned i = 0u; i < b.size(); ++i)\n        std::cout << a[i] << ' ';\n    std::cout << std::endl;\n}\n")),(0,i.kt)("p",null,"produces the output"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"0 3 6 9 12\n0 3 6 9 12\n")),(0,i.kt)("p",null,"This example also shows how to code ",(0,i.kt)("em",{parentName:"p"},"lvalue")," and ",(0,i.kt)("em",{parentName:"p"},"rvalue")," versions of the subscripting operator (",(0,i.kt)("inlineCode",{parentName:"p"},"[]"),"). The ",(0,i.kt)("em",{parentName:"p"},"lvalue")," version returns a reference to either an element of the array or to the ",(0,i.kt)("inlineCode",{parentName:"p"},"dummy")," instance variable. Both versions check that the index received is within bounds and if outside refer to this ",(0,i.kt)("inlineCode",{parentName:"p"},"dummy")," variable. This ensures that any change by the ",(0,i.kt)("em",{parentName:"p"},"lvalue")," version of the subscripting operator does not corrupt memory outside the memory referred to by the object."),(0,i.kt)("p",null,"Identify which member operator is called at which statement in ",(0,i.kt)("inlineCode",{parentName:"p"},"main()"),"."),(0,i.kt)("h3",{id:"anonymous-classes"},"Anonymous Classes"),(0,i.kt)("p",null,"If we never refer to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Identifier")," of a class, we may omit the name in the definition of the class. This occurs in the definition of type synonyms and structures or unions nested within a class definition. A class without an ",(0,i.kt)("inlineCode",{parentName:"p"},"Identifier")," is called an ",(0,i.kt)("strong",{parentName:"p"},"anonymous")," class."),(0,i.kt)("p",null,"In defining an anonymous type, we must include either the instance's identifier or the synonym name. That is, the definition of an anonymous type is also either the definition of an instance of that type or the declaration of a synonym type."),(0,i.kt)("p",null,"For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// defining an instance of an anonymous type (name)\nstruct // definition - no tag\n{\n    char shortName[7];\n    char fullName[41];\n} name;\n\n\n// declaring a synonym type (Course)\ntypedef struct // definition - no tag\n{\n    unsigned number;\n    char desc[41];\n} Course; // "Course" is a synonym for the structure\n')),(0,i.kt)("h2",{id:"move-operators"},"Move Operators"),(0,i.kt)("p",null,"In cases where an instance of ",(0,i.kt)("strong",{parentName:"p"},"a class with resources")," will no longer be referred to once it has been copied or assigned, we may move that object's resources by a simple copying of their addresses. This copying is an efficient alternative to copying the members of the to-be-moved object to new locations in the current object."),(0,i.kt)("p",null,"The C++ move facilities implement this alternative solution for objects that are near the end of their lifetime."),(0,i.kt)("p",null,"The prototype for a move-constructor takes the form"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class-name(class-name&&);\n")),(0,i.kt)("p",null,"The prototype for a move-assignment operator takes the form"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"class-name& operator=(class-name&&);\n")),(0,i.kt)("p",null,"These special member functions receive ",(0,i.kt)("em",{parentName:"p"},"rvalue")," references to the source object (the object whose content is to be moved) and perform the swapping of addresses between the objects' resources."),(0,i.kt)("p",null,"For example, these operators are defined below for the ",(0,i.kt)("inlineCode",{parentName:"p"},"copy_assign.cpp")," program listed above."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Copy and Move\n// copy_move.cpp\n#include <iostream>\n#include <utility>\n\nclass Array\n{\n    int* a = nullptr;\n    unsigned n = 0u;\n    int dummy = 0;\n\npublic:\n    Array(){}\n    Array(unsigned no) : a(new int[no]), n(no) {}\n\n    // the COPY constructor\n    Array(const Array& src) { *this = src; }\n\n    // the MOVE constructor\n    Array(Array&& src) { *this = std::move(src); }\n\n    // the COPY assignment operator\n    Array& operator=(const Array& src)\n    {\n        // 1. check for self-assignment\n        if (this != &src)\n        {\n            // 2. clean-up the resource used by the current instance\n            delete [] a;\n\n            // 3. shallow copy\n            n = src.n;\n            dummy = src.dummy;\n\n            // 4. deep copy\n            a = new int[src.n];\n            for (unsigned i = 0u; i < src.n; ++i)\n                a[i] = src.a[i];\n        }\n        return *this;\n    }\n\n    // the MOVE assignment operator\n    Array& operator=(Array&& src)\n    {\n        // 1. check for self-assignment\n        if (this != &src)\n        {\n            // 2. clean-up the resource used by the current instance\n            delete [] a;\n\n            // 3. shallow copy\n            n = src.n;\n            dummy = src.dummy;\n\n            // 4. move the resource from parameter into current instance\n            a = src.a;       // copy address to current object\n            src.a = nullptr; // the parameter doesn\'t have the resource anymore\n        }\n        return *this;\n    }\n\n    ~Array() { delete [] a; }\n\n    int& operator[](unsigned i)\n    {\n        return n > 0u && i < n ? a[i] : dummy;\n    }\n\n    int operator[](unsigned i) const\n    {\n        return n > 0u && i < n ? a[i] : dummy;\n    }\n\n    unsigned size() const { return n; }\n};\n\n\nint main()\n{\n    const unsigned size = 5;\n\n    Array a(size), b;\n    for (unsigned i = 0u; i < a.size(); ++i)\n        a[i] = 3 * i;\n\n\n    std::cout << "Copy-Assignment\\n";\n\n    std::cout << "a : ";\n    for (unsigned i = 0u; i < a.size(); ++i)\n        std::cout << a[i] << \' \';\n    std::cout << std::endl;\n\n    b = a; // calls copy-assignment\n\n    std::cout << "b : ";\n    for (unsigned i = 0u; i < b.size(); ++i)\n        std::cout << b[i] << \' \';\n    std::cout << std::endl;\n\n    std::cout << "a : ";\n    for (unsigned i = 0u; i < a.size(); ++i)\n        std::cout << a[i] << \' \';\n    std::cout << std::endl;\n\n\n    std::cout << "Move-Assignment\\n";\n\n    std::cout << "a : ";\n    for (unsigned i = 0u; i < a.size(); ++i)\n        std::cout << a[i] << \' \';\n    std::cout << std::endl;\n\n    b = std::move(a); // calls move-assignment\n\n    std::cout << "b : ";\n    for (unsigned i = 0u; i < b.size(); ++i)\n        std::cout << b[i] << \' \';\n    std::cout << std::endl;\n\n    std::cout << "a : ";\n    for (unsigned i = 0u; i < a.size(); ++i)\n        std::cout << a[i] << \' \';\n    std::cout << std::endl;\n}\n')),(0,i.kt)("p",null,"The output of the program above is"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Copy-Assignment\na : 0 3 6 9 12\nb : 0 3 6 9 12\na : 0 3 6 9 12\nMove-Assignment\na : 0 3 6 9 12\nb : 0 3 6 9 12\na :\n")),(0,i.kt)("h2",{id:"class-members"},"Class Members"),(0,i.kt)("p",null,"A class can include data members that hold the same information for ",(0,i.kt)("strong",{parentName:"p"},"all instances")," of the class and access that information regardless of the number of instances that currently exist. These are called ",(0,i.kt)("strong",{parentName:"p"},"class variables"),". Class functions can access these variables at any time."),(0,i.kt)("h3",{id:"class-variables"},"Class Variables"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"class variable")," lasts the lifetime of the program and holds a value that all instances of the class share. Application examples include the interest on a savings account for customers of a non-discriminating bank or counters that keep track of the number of objects instantiated but not yet destroyed."),(0,i.kt)("p",null,"The keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"static")," declares a variable in a class definition to be a class variable. We define and initialize the class variable in the implementation file for the module. For example, the program"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Class Variables - Header\n// classVariable.h\n\nclass Horse\n{\n    unsigned age;             // <-- this is an instance variable\n    unsigned id;              // <-- this is an instance variable\npublic:\n    static unsigned noHorses; // <-- this is a class variable\n\n    Horse(unsigned a);\n    ~Horse();\n\n    void display() const;\n};\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Class Variables - Implementation\n// classVariable.cpp\n\n#include <iostream>\n#include "classVariable.h"\n\nunsigned Horse::noHorses = 0; // this is how class variables are initialized\n\n// the constructor increments the class variable, but is not initialize it\nHorse::Horse(unsigned a) : age{a}, no{++Horse::noHorses} {}\n\n// the destructor decrements the class variable\nHorse::~Horse() { --Horse::noHorses; }\n\nvoid Horse::display() const\n{\n    std::cout << "Horse " << no << " is " << age << " years old\\n";\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Class Variables - Application\n// classVariableMain.cpp\n\n#include <iostream>\n#include "classVariable.h"\n\nint main()\n{\n    // no need for an instance to access the class variable\n    std::cout << Horse::noHorses << " horses\\n";\n\n    {\n        // create a local scope\n        Horse silver(3), northernDancer(4);\n\n        silver.display();\n        northernDancer.display();\n\n        std::cout << Horse::noHorses << " horses" << std::endl;\n        std::cout << silver.noHorses << " horses" << std::endl;\n        std::cout << northernDancer.noHorses << " horses" << std::endl;\n\n        // local scope ends: variables created in this scope will be destroyed\n    }\n\n    std::cout << Horse::noHorses << " horses" << std::endl;\n}\n')),(0,i.kt)("p",null,"outputs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"0 horses\nHorse 1 is 3 years old\nHorse 2 is 4 years old\n2 horses\n2 horses\n2 horses\n0 horses\n")),(0,i.kt)("p",null,"We can refer to a class variable through its class name or through anyone of its objects' names. We can access a class variable even if there are no instances of the class at the time."),(0,i.kt)("h3",{id:"class-functions"},"Class Functions"),(0,i.kt)("p",null,"A class function provides access to private class variables. The keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"static")," declares a function in a class definition to be a class function. We define the class function in the implementation file. For example, the program"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"}," // Class Functions - Header\n // classFunction.h\n\n class Horse {\n     unsigned age;              // <-- instance variable\n     unsigned no;               // <-- instance variable\n     static unsigned noHorses;  // <-- PRIVATE class variable, cannot be accessed from outside the class\n public:\n     Horse(unsigned a);\n     ~Horse();\n\n     void display() const;      // <-- instance function\n\n     static unsigned howMany(); // <-- PUBLIC class function\n };\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Class Functions - Implementation\n// classFunctioncpp\n\n#include <iostream>\n#include "classFunction.h"\n\nunsigned Horse::noHorses = 0;  // initialize the class variable\n\nHorse::Horse(unsigned a) : age{a}, no{++noHorses} {}\n\nHorse::~Horse() { --noHorses; }\n\nvoid Horse::display() const\n{\n    std::cout << "Horse " << no << " is " << age << " years old\\n";\n}\n\nunsigned Horse::howMany() { return noHorses; }\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Class Functions - Application\n// classFunctionMain.cpp\n\n#include <iostream>\n#include "classFunction.h"\n\nint main()\n{\n    std::cout << Horse::howMany() << " horses\\n";\n\n    {\n        Horse silver(3), northernDancer(4);\n        silver.display();\n        northernDancer.display();\n\n        std::cout << Horse::howMany() << " horses" << std::endl;\n        std::cout << silver.howMany() << " horses" << std::endl;\n        std::cout << northernDancer.howMany() << " horses" << std::endl;\n    }\n\n    std::cout << Horse::howMany() << " horses\\n";\n}\n')),(0,i.kt)("p",null,"outputs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"0 horses\nHorse 1 is 3 years old\nHorse 2 is 4 years old\n2 horses\n2 horses\n2 horses\n0 horses\n")),(0,i.kt)("p",null,"All data members of class scope to which a class function refers must be class variables. A class function may not refer to any instance variable."),(0,i.kt)("h2",{id:"structs-and-unions"},"Structs and Unions"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"union")," is a class that is weakly encapsulated. Its members are public by default. Just like for ",(0,i.kt)("inlineCode",{parentName:"p"},"class"),", the data members of a ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"union")," can be of different types."),(0,i.kt)("h3",{id:"structs"},"Structs"),(0,i.kt)("p",null,"The members of a ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," are arranged ",(0,i.kt)("strong",{parentName:"p"},"sequentially")," but not necessarily contiguously in memory."),(0,i.kt)("h3",{id:"unions"},"Unions"),(0,i.kt)("p",null,"The members of a union are arranged ",(0,i.kt)("strong",{parentName:"p"},"in parallel")," in memory. Unlike the members in a ",(0,i.kt)("inlineCode",{parentName:"p"},"class")," or a ",(0,i.kt)("inlineCode",{parentName:"p"},"struct"),", the members in a ",(0,i.kt)("inlineCode",{parentName:"p"},"union")," share the same address in memory."),(0,i.kt)("p",null,"An object of ",(0,i.kt)("inlineCode",{parentName:"p"},"union")," type can only hold the value of one of its members at any particular time. For example, the program"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Unions\n// union.cpp\n\n#include <iostream>\n#include <cstring>\n\nunion Product // some instances have skus, other have upcs, but not both\n{\n    int sku;\n    char upc[13];\n};\n\nint main()\n{\n    Product cereal, tissue;\n\n    cereal.sku = 4789;\n    std::strcpy(tissue.upc, "0360002607555");\n\n    std::cout << cereal.sku << std::endl;\n    std::cout << tissue.upc << std::endl;\n}\n')),(0,i.kt)("p",null,"outputs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"4789\n0360002607555\n")),(0,i.kt)("p",null,"Note that only the value of the member that was most recently assigned is stored in memory. Attempting to access the memory of a union using a different member than the one assigned will produce a value that doesn't make sense."),(0,i.kt)("h2",{id:"enumerations"},"Enumerations"),(0,i.kt)("p",null,"An enumeration is a type that holds a discrete set of symbolic constants. These constants can simplify the readability and the upgradability of an application significantly."),(0,i.kt)("p",null,"Each enumeration definition declares a type that is different from all other types and has an underlying type. The default underlying type of an enumeration in an ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),"."),(0,i.kt)("h3",{id:"plain-enumerations"},"Plain Enumerations"),(0,i.kt)("p",null,"The definition of a plain enumeration type lists the symbolic constants in the following form"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"enum Type\n{\n    symbolic_constant_1,\n    symbolic_constant_2,\n    symbolic_constant_3,\n    ...\n};\n")),(0,i.kt)("p",null,"The keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"enum")," distinguishes the enumerated type from any other type. ",(0,i.kt)("inlineCode",{parentName:"p"},"Type")," is the name of the enumerated type. Each symbolic constant in the list is an ",(0,i.kt)("strong",{parentName:"p"},"enumeration constant"),"."),(0,i.kt)("p",null,"We define a variable of enumeration type using a declaration of the form"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Type identifier;\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"identifier")," is the name of the variable that holds one of the symbolic constants of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Type"),"."),(0,i.kt)("p",null,"For example, the program"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Plain Enumerations\n// plain_enum.cpp\n\n#include <iostream>\n#include <string>\n\n// define the Colour enumeration type\nenum Colour { white, red, green, blue };\n\nstd::ostream& operator<<(std::ostream& os, const Colour& colour)\n{\n    std::string str;\n\n    switch(colour)\n    {\n    case white: // symbolic constant\n        str = "white";\n        break;\n    case red: // symbolic constant\n        str = "red";\n        break;\n    case green: // symbolic constant\n        str = "green";\n        break;\n    case blue: // symbolic constant\n        str = "blue";\n        break;\n    default:\n        str = "none";\n    }\n\n    os << str;\n\n    return os;\n}\n\nint main()\n{\n    Colour wall, ceiling, door; // define Colour variables\n    wall = red;\n    ceiling = white;\n    door = green;\n\n    std::cout << wall << \' \' << ceiling << \' \' << door << std::endl;\n}\n')),(0,i.kt)("p",null,"outputs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"red white green\n")),(0,i.kt)("h3",{id:"tracking-access-in-unions-using-structs-and-enumerations"},"Tracking Access in Unions Using Structs and Enumerations"),(0,i.kt)("p",null,"There is no independent way of identifying a union's most recently accessed member. To address this ambiguity, we wrap a union type within a struct type and declare an enumerator as a member of the struct type. The enumerator identifies the most recently accessed member within the union type. For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Structs with Unions\n// struct_union.cpp\n\n#include <iostream>\n#include <cstring>\n\nenum ProductId { sku, upc };\n\ntypedef struct\n{\n    ProductId id; // enumeration type holds a symbolic constant\n    union // some have skus, some upcs\n    {\n        int  sku;\n        char upc[13];\n    } code;\n    char desc[100];\n} Product;\n\n\nint main()\n{\n    Product p[2];\n\n    p[0].id = sku;\n    p[0].code.sku = 4789;\n    std::strcpy(p[0].desc, "A history book about ancient Rome.");\n\n    p[1].id = upc;\n    std::strcpy(p[1].desc, "A universal remote control for TVs.");\n    std::strcpy(p[1].code.upc, "0360002607555");\n\n    for (int i = 0; i < 2; i++)\n    {\n        switch(p[i].id)\n        {\n        case sku:\n            std::cout << p[i].code.sku << std::endl;\n            break;\n        case upc:\n            std::cout << p[i].code.upc << std::endl;\n            break;\n        }\n    }\n}\n')),(0,i.kt)("p",null,"outputs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"4789\n0360002607555\n")),(0,i.kt)("p",null,"Note the type definitions and the two anonymous types in this example."),(0,i.kt)("h3",{id:"scoped-enumerations"},"Scoped Enumerations"),(0,i.kt)("p",null,"A scoped enumeration is an enumeration that restricts access to its symbolic constant based on its scope. Symbolic constants with the same name but different scopes are distinct from one another."),(0,i.kt)("p",null,"The definition of a scoped enumeration type lists the symbolic constants and takes the following form. The keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"class")," identifies a scoped enumeration:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"enum class Type\n{\n    symbolic_constant_1,\n    symbolic_constant_2,\n    symbolic_constant_3,\n    ...\n};\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Type")," is the name of the enumerated type. Each symbolic constant in the list is an ",(0,i.kt)("strong",{parentName:"p"},"enumeration constant"),"."),(0,i.kt)("p",null,"We define a variable of enumerator type using a declaration of the form"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"Type identifier;\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"identifier")," is the name of the variable that will hold one of the symbolic constants of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Type"),"."),(0,i.kt)("p",null,"For example, the program"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Scoped Enumerations\n// scoped_enum.cpp\n\n#include <iostream>\n#include <string>\n\n// define the Colour type\nenum class Colour { white, red, green, blue };\n\nstd::ostream& operator<<(std::ostream& os, const Colour& colour)\n{\n    std::string str;\n\n    switch(colour)\n    {\n    case Colour::white:\n        str = "white";\n        break;\n    case Colour::red:\n        str = "red";\n        break;\n    case Colour::green:\n        str = "green";\n        break;\n    case Colour::blue:\n        str = "blue";\n        break;\n    default:\n    str = "none";\n    }\n\n    os << str;\n    return os;\n}\n\nint main()\n{\n    Colour wall, ceiling, door; // define Colour variables\n\n    wall = Colour::red;\n    ceiling = Colour::white;\n    door = Colour::green;\n\n    std::cout << wall << \' \' << ceiling << \' \' << door << std::endl;\n}\n')),(0,i.kt)("p",null,"outputs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"red white green\n")),(0,i.kt)("h3",{id:"underlying-types"},"Underlying Types"),(0,i.kt)("p",null,"The compiler associates each symbolic constant of an enumeration with a unique value of the enumeration's underlying type. By default, the compiler assigns the value 0 to the first constant in the list and a value 1 greater than the preceding value to each successive constant."),(0,i.kt)("p",null,"We may assign our own value to an enumeration constant provided that each value is unique within the list for that type. For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"enum class Colour\n{\n    white = 0x01,\n    red   = 0x02,\n    green = 0x04,\n    blue  = 0x08\n};\n")),(0,i.kt)("p",null,"Note that the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"red")," is 2, which is 1 greater than ",(0,i.kt)("inlineCode",{parentName:"p"},"white"),", but the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"blue")," is 8, which is 4 greater than ",(0,i.kt)("inlineCode",{parentName:"p"},"green"),"."),(0,i.kt)("h3",{id:"modifying-an-enumeration"},"Modifying an Enumeration"),(0,i.kt)("p",null,"Enumeration syntax simplifies upgradability. If we insert a new symbolic constant into the enumeration, the compiler renumbers the underlying types for the subsequent constants in the list without requiring any further modification:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Inserting Enumeration Constants\n// insert_enum.cpp\n\n#include <iostream>\n#include <string>\n\n// define the Colour type\nenum class Colour { white, yellow, red, green, blue };\n\nstd::ostream& operator<<(std::ostream& os, const Colour& colour)\n{\n    std::string str;\n\n    switch(colour)\n    {\n    case Colour::white:\n        str = "white";\n        break;\n    case Colour::yellow:\n        str = "yellow";\n        break;\n    case Colour::red:\n        str = "red";\n        break;\n    case Colour::green:\n        str = "green";\n        break;\n    case Colour::blue:\n        str = "blue";\n        break;\n    default:\n        str = "none";\n    }\n\n    os << str;\n    return os;\n}\n\nint main()\n{\n    Colour wall, ceiling, door, window;\n\n    wall = Colour::red;\n    ceiling = Colour::white;\n    door = Colour::green;\n    window = Colour::yellow;\n\n    std::cout << wall    << \' \' << window << \' \'\n              << ceiling << \' \' << door   << std::endl;\n}\n')),(0,i.kt)("p",null,"outputs"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"red yellow white green\n")),(0,i.kt)("p",null,"Note that the only changes required for inserting the new symbolic constant ",(0,i.kt)("inlineCode",{parentName:"p"},"yellow")," were adding it to the enumeration definition and adding a corresponding ",(0,i.kt)("inlineCode",{parentName:"p"},"case")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"switch-case")," construct."),(0,i.kt)("h3",{id:"exercises"},"Exercises"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Read Wikipedia on ",(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Class_variable"},"Class Variables"))))}p.isMDXComponent=!0}}]);