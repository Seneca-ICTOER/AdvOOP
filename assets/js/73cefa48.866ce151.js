"use strict";(self.webpackChunkoop345=self.webpackChunkoop345||[]).push([[580],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return c}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=s(n),c=i,h=u["".concat(p,".").concat(c)]||u[c]||m[c]||r;return n?a.createElement(h,l(l({ref:t},d),{},{components:n})):a.createElement(h,l({ref:t},d))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=u;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var s=2;s<r;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9868:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return p},metadata:function(){return s},toc:function(){return d},default:function(){return u}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),l=["components"],o={id:"expressions",title:"Expressions",sidebar_position:1,description:"TBD"},p="Expressions",s={unversionedId:"D-Processing/expressions",id:"D-Processing/expressions",isDocsHomePage:!1,title:"Expressions",description:"TBD",source:"@site/docs/D-Processing/expressions.md",sourceDirName:"D-Processing",slug:"/D-Processing/expressions",permalink:"/D-Processing/expressions",editUrl:"https://github.com/Seneca-ICTOER/AdvOOP/tree/main/docs/D-Processing/expressions.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"expressions",title:"Expressions",sidebar_position:1,description:"TBD"},sidebar:"courseNotesSidebar",previous:{title:"Compositions, Aggregations and Associations",permalink:"/C-Class-Relationships/compositions-aggregations-and-associations"},next:{title:"Functions",permalink:"/D-Processing/functions"}},d=[{value:"Value Categories",id:"value-categories",children:[{value:"lvalue Operands",id:"lvalue-operands",children:[],level:3}],level:2},{value:"Operator Precedence",id:"operator-precedence",children:[{value:"Order of Evaluation",id:"order-of-evaluation",children:[],level:3}],level:2},{value:"Postfix Expressions",id:"postfix-expressions",children:[{value:"Subscripting Operator",id:"subscripting-operator",children:[],level:3},{value:"Member Selection",id:"member-selection",children:[{value:"Direct Selection",id:"direct-selection",children:[],level:4},{value:"Indirect Selection",id:"indirect-selection",children:[],level:4}],level:3},{value:"Postfix Increment and Decrement",id:"postfix-increment-and-decrement",children:[{value:"Results at Integer Limits",id:"results-at-integer-limits",children:[],level:4}],level:3},{value:"<code>typeid()</code> Operator (optional for OOP345)",id:"typeid-operator-optional-for-oop345",children:[],level:3},{value:"Constrained Cast Operators",id:"constrained-cast-operators",children:[{value:"<code>static_cast</code> Operator",id:"static_cast-operator",children:[],level:4},{value:"<code>reinterpret_cast</code> Operator",id:"reinterpret_cast-operator",children:[],level:4},{value:"<code>const_cast</code> Operator",id:"const_cast-operator",children:[],level:4},{value:"<code>dynamic_cast</code> Operator (optional for OOP345)",id:"dynamic_cast-operator-optional-for-oop345",children:[],level:4}],level:3}],level:2},{value:"Prefix Expressions",id:"prefix-expressions",children:[{value:"Prefix Increment and Decrement",id:"prefix-increment-and-decrement",children:[{value:"Results at the Limit",id:"results-at-the-limit",children:[],level:4}],level:3}],level:2},{value:"Unary Expressions",id:"unary-expressions",children:[{value:"<code>sizeof()</code>, <code>sizeof</code>",id:"sizeof-sizeof",children:[],level:3},{value:"Logical Negation",id:"logical-negation",children:[],level:3},{value:"Bit-Wise Negation",id:"bit-wise-negation",children:[],level:3},{value:"Arithmetic Negation",id:"arithmetic-negation",children:[{value:"Results for Unsigned Types",id:"results-for-unsigned-types",children:[],level:4}],level:3},{value:"Arithmetic Plus",id:"arithmetic-plus",children:[],level:3},{value:"Address of",id:"address-of",children:[],level:3},{value:"Indirection",id:"indirection",children:[],level:3},{value:"Cast",id:"cast",children:[],level:3},{value:"<code>alignof()</code> Operator",id:"alignof-operator",children:[],level:3},{value:"<code>decltype()</code> Specifier",id:"decltype-specifier",children:[],level:3},{value:"<code>noexcept()</code> Operator",id:"noexcept-operator",children:[],level:3},{value:"<code>throw</code> Operator",id:"throw-operator",children:[],level:3}],level:2},{value:"Binary Expressions",id:"binary-expressions",children:[{value:"Arithmetic",id:"arithmetic",children:[{value:"Multiplicative",id:"multiplicative",children:[],level:4},{value:"Addition",id:"addition",children:[],level:4},{value:"Subtraction",id:"subtraction",children:[],level:4}],level:3},{value:"Bit-Shifting",id:"bit-shifting",children:[],level:3},{value:"Relational",id:"relational",children:[{value:"Less-Than",id:"less-than",children:[],level:4},{value:"Greater-Than",id:"greater-than",children:[],level:4},{value:"Equality",id:"equality",children:[],level:4},{value:"Inequality",id:"inequality",children:[],level:4}],level:3},{value:"Bit-Wise and",id:"bit-wise-and",children:[],level:3},{value:"Bit-Wise or",id:"bit-wise-or",children:[],level:3},{value:"Bit-Wise Exclusive or",id:"bit-wise-exclusive-or",children:[],level:3},{value:"Logical",id:"logical",children:[{value:"Intersection and Union",id:"intersection-and-union",children:[],level:4},{value:"Left to Right",id:"left-to-right",children:[],level:4},{value:"Order Matters",id:"order-matters",children:[],level:4}],level:3},{value:"Assignment Expressions",id:"assignment-expressions",children:[{value:"Simple Assignment",id:"simple-assignment",children:[],level:4},{value:"Compound Assignment",id:"compound-assignment",children:[],level:4}],level:3},{value:"Sequential Expressions",id:"sequential-expressions",children:[],level:3},{value:"Mixed-Type Binary Expressions",id:"mixed-type-binary-expressions",children:[{value:"The Unsigned Trap",id:"the-unsigned-trap",children:[],level:4}],level:3},{value:"Good Design Practice",id:"good-design-practice",children:[{value:"Avoid Implicit Promotions",id:"avoid-implicit-promotions",children:[],level:4},{value:"Sub-Divide Complex Binary Expressions",id:"sub-divide-complex-binary-expressions",children:[],level:4}],level:3}],level:2},{value:"Ternary Expression",id:"ternary-expression",children:[],level:2}],m={toc:d};function u(e){var t=e.components,o=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},m,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"expressions"},"Expressions"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Classify operations into categories under rules of precedence"),(0,r.kt)("li",{parentName:"ul"},"Categorize expressions as lvalues, xvalues and prvalues"),(0,r.kt)("li",{parentName:"ul"},"Describe the features of expressions for each type-wise operator")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},'"C ',"[and hence C++]",' has an unusually rich set of operators that provide access to most of the operations provided by the underlying hardware." Harbison and Steele (2002)')),(0,r.kt)("p",null,"Expressions specify computations.  They consist of sequences of operators and operands and may produce a result, possibly with side effects.  A C++ expression has a non-reference type and belongs to a value category.  The expression may be primary or compound as illustrated below.  A compound expression consists of an operator and one or more operands.  A compound expression is ultimately decomposable into a set of primary expressions connected by operators. "),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Expressions",src:n(5888).Z})),(0,r.kt)("p",null,"The order of evaluation of the operations in a compound expression determines the value of the expression.  C++ defines this order through precedence rules for all of its operators. "),(0,r.kt)("p",null,"This chapter describes the value categories of C++ expressions, the precedence rules that apply to operators in compound expressions and the specific features associated with each operator.  Expressions based on bit-wise operators are described in a later chapter entitled ",(0,r.kt)("a",{parentName:"p",href:"/H-Deeper-Detail/bit-wise-expressions"},"Bit-Wise Expressions"),"."),(0,r.kt)("h2",{id:"value-categories"},"Value Categories"),(0,r.kt)("p",null,"The value categories of C++ expressions are the basis for rules that compilers follow when creating, copying, and moving temporary objects during the evaluation of expressions.  Awareness of these categories helps the programmer understand how the compiler evaluates expressions and interpret error messages that the compiler generates. "),(0,r.kt)("p",null,"Any C++ expression is one of:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"prvalue")," - a value that does not occupy a location in storage"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"xvalue")," - an expiring value that does occupy a location in storage (an object near the end of its lifetime)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"lvalue")," - a locator value that occupies a location in storage")),(0,r.kt)("p",null,"When the compiler creates a temporary object it converts a prvalue into an xvalue, which is temporarily located in memory - this is called a ",(0,r.kt)("em",{parentName:"p"},"temporary materialization conversion"),"."),(0,r.kt)("p",null,"Both lvalues and xvalues occupy a region of memory and together are called glvalues.  A glvalue is a generalized lvalue.  It evaluates to an object or a function.  On the other hand, prvalues and xvalues are called rvalues.  An rvalue is a temporary object or subobject, or a value not assocaited with an object. "),(0,r.kt)("p",null,"In summary, C++17 categorizes expressions according to the taxonomy illustrated below.  Any expression is either a glvalue or an rvalue. "),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Value Categories",src:n(579).Z})),(0,r.kt)("p",null,"Many expressions evaluate to prvalues, some to lvalues, some to xvalues and some to no value.  The specific descriptions below identify the category to which each expression evaluates. "),(0,r.kt)("h3",{id:"lvalue-operands"},"lvalue Operands"),(0,r.kt)("p",null,"lvalue operands include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a name that is not an array name"),(0,r.kt)("li",{parentName:"ul"},"an array element - ",(0,r.kt)("inlineCode",{parentName:"li"},"a[i]")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(expression)")," - where ",(0,r.kt)("inlineCode",{parentName:"li"},"expression")," is itself an lvalue"),(0,r.kt)("li",{parentName:"ul"},"a direct member selection - ",(0,r.kt)("inlineCode",{parentName:"li"},"expression.member")," - where expression is itself an lvalue"),(0,r.kt)("li",{parentName:"ul"},"an indirect member selection - ",(0,r.kt)("inlineCode",{parentName:"li"},"expression->member")," - where expression points to an lvalue"),(0,r.kt)("li",{parentName:"ul"},"a dereferenced address - ",(0,r.kt)("inlineCode",{parentName:"li"},"*expression")),(0,r.kt)("li",{parentName:"ul"},"a string literal (actually an array of characters)")),(0,r.kt)("p",null,"The operands associated with the following three operators must be lvalues:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"&")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"++")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"--"))),(0,r.kt)("p",null,"The left operands associated with the assignment operators must be lvalues:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"=")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"+=")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"-=")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"*=")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"/=")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"%="))),(0,r.kt)("h2",{id:"operator-precedence"},"Operator Precedence"),(0,r.kt)("p",null,"Expressions are divided into six operand-related classifications:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"primary"),(0,r.kt)("li",{parentName:"ul"},"postfix"),(0,r.kt)("li",{parentName:"ul"},"prefix"),(0,r.kt)("li",{parentName:"ul"},"unary"),(0,r.kt)("li",{parentName:"ul"},"binary"),(0,r.kt)("li",{parentName:"ul"},"ternary")),(0,r.kt)("p",null,"Primary expressions are the fundamental expressions from which all other expressions are built.  A primary expression consists of a single operand without any operator.  The operand may be the name of an entity or a literal.  Non-primary expressions consist of one operator and one or more operands.  The operands may be primary or compound expressions."),(0,r.kt)("h3",{id:"order-of-evaluation"},"Order of Evaluation"),(0,r.kt)("p",null,"A compound expression evaluates according to rules defined through the precedence table below.  These rules cannot be changed.  The compiler evaluates the expression with the operator that has a higher precedence before evaluating any other expression.  Some operators associate from left to right, while other operators associate from right to left. "),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Precedence"),(0,r.kt)("th",{parentName:"tr",align:null},"Class"),(0,r.kt)("th",{parentName:"tr",align:null},"Operator"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Associates"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"18"),(0,r.kt)("td",{parentName:"tr",align:null},"primary"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"name, literal"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"18"),(0,r.kt)("td",{parentName:"tr",align:null},"binary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"::")),(0,r.kt)("td",{parentName:"tr",align:null},"scope resolution"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"17"),(0,r.kt)("td",{parentName:"tr",align:null},"postfix"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"[]")),(0,r.kt)("td",{parentName:"tr",align:null},"array subscripting"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"17"),(0,r.kt)("td",{parentName:"tr",align:null},"postfix"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"( )")),(0,r.kt)("td",{parentName:"tr",align:null},"function call"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"17"),(0,r.kt)("td",{parentName:"tr",align:null},"postfix"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},".")),(0,r.kt)("td",{parentName:"tr",align:null},"direct selection"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"17"),(0,r.kt)("td",{parentName:"tr",align:null},"postfix"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"->")),(0,r.kt)("td",{parentName:"tr",align:null},"indirect selection"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"17"),(0,r.kt)("td",{parentName:"tr",align:null},"postfix"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"++")," ",(0,r.kt)("inlineCode",{parentName:"td"},"--")),(0,r.kt)("td",{parentName:"tr",align:null},"postfix increment, decrement"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"17"),(0,r.kt)("td",{parentName:"tr",align:null},"postfix"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"typeid()")),(0,r.kt)("td",{parentName:"tr",align:null},"type name"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"17"),(0,r.kt)("td",{parentName:"tr",align:null},"postfix"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"const_cast")),(0,r.kt)("td",{parentName:"tr",align:null},"constant type conversion"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"17"),(0,r.kt)("td",{parentName:"tr",align:null},"postfix"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"dynamic_cast")),(0,r.kt)("td",{parentName:"tr",align:null},"dynamic type conversion"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"17"),(0,r.kt)("td",{parentName:"tr",align:null},"postfix"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"reinterpret_cast")),(0,r.kt)("td",{parentName:"tr",align:null},"reinterpreted type conversion"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"17"),(0,r.kt)("td",{parentName:"tr",align:null},"postfix"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"static_cast")),(0,r.kt)("td",{parentName:"tr",align:null},"static type conversion"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"prefix"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"++")," ",(0,r.kt)("inlineCode",{parentName:"td"},"--")),(0,r.kt)("td",{parentName:"tr",align:null},"prefix increment, decrement"),(0,r.kt)("td",{parentName:"tr",align:null},"right-to-left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"unary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"sizeof")),(0,r.kt)("td",{parentName:"tr",align:null},"size"),(0,r.kt)("td",{parentName:"tr",align:null},"right-to-left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"unary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"!")),(0,r.kt)("td",{parentName:"tr",align:null},"logical negation"),(0,r.kt)("td",{parentName:"tr",align:null},"right-to-left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"unary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"~")),(0,r.kt)("td",{parentName:"tr",align:null},"bit-wise negation"),(0,r.kt)("td",{parentName:"tr",align:null},"right-to-left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"unary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"-")," ",(0,r.kt)("inlineCode",{parentName:"td"},"+")),(0,r.kt)("td",{parentName:"tr",align:null},"arithmetic negation, plus"),(0,r.kt)("td",{parentName:"tr",align:null},"right-to-left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"unary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"&")),(0,r.kt)("td",{parentName:"tr",align:null},"address of"),(0,r.kt)("td",{parentName:"tr",align:null},"right-to-left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"unary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"*")),(0,r.kt)("td",{parentName:"tr",align:null},"indirection"),(0,r.kt)("td",{parentName:"tr",align:null},"right-to-left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"unary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"new")," ",(0,r.kt)("inlineCode",{parentName:"td"},"new[]")),(0,r.kt)("td",{parentName:"tr",align:null},"dynamic memory allocation"),(0,r.kt)("td",{parentName:"tr",align:null},"right-to-left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"unary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"delete")," ",(0,r.kt)("inlineCode",{parentName:"td"},"delete[]")),(0,r.kt)("td",{parentName:"tr",align:null},"dynamic memory deallocation"),(0,r.kt)("td",{parentName:"tr",align:null},"right-to-left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"unary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"alignof(type)")),(0,r.kt)("td",{parentName:"tr",align:null},"alignment requirement"),(0,r.kt)("td",{parentName:"tr",align:null},"right-to-left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"unary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"noexcept()")),(0,r.kt)("td",{parentName:"tr",align:null},"controls exception throwing"),(0,r.kt)("td",{parentName:"tr",align:null},"right-to-left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"unary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(type)")),(0,r.kt)("td",{parentName:"tr",align:null},"type casting"),(0,r.kt)("td",{parentName:"tr",align:null},"right-to-left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"15"),(0,r.kt)("td",{parentName:"tr",align:null},"binary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},".*")),(0,r.kt)("td",{parentName:"tr",align:null},"object to member pointer"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"15"),(0,r.kt)("td",{parentName:"tr",align:null},"binary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"->*")),(0,r.kt)("td",{parentName:"tr",align:null},"pointer to member pointer"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"14"),(0,r.kt)("td",{parentName:"tr",align:null},"binary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"*")," ",(0,r.kt)("inlineCode",{parentName:"td"},"/")," ",(0,r.kt)("inlineCode",{parentName:"td"},"%")),(0,r.kt)("td",{parentName:"tr",align:null},"multiplicative"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"13"),(0,r.kt)("td",{parentName:"tr",align:null},"binary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"+")," ",(0,r.kt)("inlineCode",{parentName:"td"},"-")),(0,r.kt)("td",{parentName:"tr",align:null},"additive"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"12"),(0,r.kt)("td",{parentName:"tr",align:null},"binary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<<")," ",(0,r.kt)("inlineCode",{parentName:"td"},">>")),(0,r.kt)("td",{parentName:"tr",align:null},"left and right bit shifting"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"11"),(0,r.kt)("td",{parentName:"tr",align:null},"binary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<")," ",(0,r.kt)("inlineCode",{parentName:"td"},">")," ",(0,r.kt)("inlineCode",{parentName:"td"},"<=")," ",(0,r.kt)("inlineCode",{parentName:"td"},">=")),(0,r.kt)("td",{parentName:"tr",align:null},"relational"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"10"),(0,r.kt)("td",{parentName:"tr",align:null},"binary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"==")," ",(0,r.kt)("inlineCode",{parentName:"td"},"!=")),(0,r.kt)("td",{parentName:"tr",align:null},"equality, inequality"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"9"),(0,r.kt)("td",{parentName:"tr",align:null},"binary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"&")),(0,r.kt)("td",{parentName:"tr",align:null},"bit-wise logical and"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"8"),(0,r.kt)("td",{parentName:"tr",align:null},"binary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"^")),(0,r.kt)("td",{parentName:"tr",align:null},"bit-wise logical exclusive or"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"7"),(0,r.kt)("td",{parentName:"tr",align:null},"binary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"\u01c0")),(0,r.kt)("td",{parentName:"tr",align:null},"bit-wise logical or"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},"binary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"&&")),(0,r.kt)("td",{parentName:"tr",align:null},"logical and"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},"binary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"\u01c0\u01c0")),(0,r.kt)("td",{parentName:"tr",align:null},"logical or"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"ternary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"?:")),(0,r.kt)("td",{parentName:"tr",align:null},"conditional"),(0,r.kt)("td",{parentName:"tr",align:null},"right-to-left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"binary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"+=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"-=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"*=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"/=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"%=")),(0,r.kt)("td",{parentName:"tr",align:null},"compound type-wise assignment"),(0,r.kt)("td",{parentName:"tr",align:null},"right-to-left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"binary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"~=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"&=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"^=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"\u01c0=")," ",(0,r.kt)("inlineCode",{parentName:"td"},">>=")," ",(0,r.kt)("inlineCode",{parentName:"td"},"<<=")),(0,r.kt)("td",{parentName:"tr",align:null},"compound bit-wise assignment"),(0,r.kt)("td",{parentName:"tr",align:null},"right-to-left")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"unary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"throw")),(0,r.kt)("td",{parentName:"tr",align:null},"transfers control to exception handler"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"binary"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},",")),(0,r.kt)("td",{parentName:"tr",align:null},"sequencing"),(0,r.kt)("td",{parentName:"tr",align:null},"left-to-right")))),(0,r.kt)("p",null,"To override the order defined in this table, we enclose the expressions to be evaluated first within parentheses."),(0,r.kt)("h2",{id:"postfix-expressions"},"Postfix Expressions"),(0,r.kt)("p",null,"Postfix expressions are expressions in which a postfix operator follows a single operand or the first operand of two operands.  Postfix operators include the subscripting operator, the function call operator, the member selection operator, the postfix increment operator, and the postfix decrement operator. "),(0,r.kt)("h3",{id:"subscripting-operator"},"Subscripting Operator"),(0,r.kt)("p",null,"The subscripting operator takes as its left operand a pointer of type ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," and as its right operand a value of integral type.  The expression identifies a modifiable lvalue at the offset from the address stored in the first operand specified by the second operand.  The result of the operation is an lvalue of type ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),".  For example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"double a[10];\nint i = 2;\n\na[i] = 6; // lvalue\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"a")," holds the address of array ",(0,r.kt)("inlineCode",{parentName:"p"},"a[10]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," is an integral type, and ",(0,r.kt)("inlineCode",{parentName:"p"},"a[i]")," refers to the ",(0,r.kt)("inlineCode",{parentName:"p"},"i"),"-th element beyond the start of ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),". "),(0,r.kt)("p",null,"C++ accepts negative subscripts provided that the element is within the array's bounds.  For example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'char  name[] = "Jane Doe";\nchar* surname = nullptr;\n\nsurname = &name[5];\nsurname[-1] = \'.\';  // changes "Jane Doe" to "Jane.Doe" \n')),(0,r.kt)("h3",{id:"member-selection"},"Member Selection"),(0,r.kt)("p",null,"The member selection operators identify an object by their left operand and the name of a member by their right operand.  A selection operation takes either of two forms: direct selection and indirect selection. "),(0,r.kt)("h4",{id:"direct-selection"},"Direct Selection"),(0,r.kt)("p",null,"The direct selection operator (",(0,r.kt)("inlineCode",{parentName:"p"},"."),") takes an object of complete class type as its left operand and the member name as its right operand:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// Direct Selection\n// direct.cpp\n\n#include <iostream>\n\ntypedef struct\n{\n    int x;\n    double y;\n} S;\n\nint main()\n{\n    S s = {0, 0.0};\n\n    s.x = 1; // lvalue\n    std::cout << "x = " << s.x << "; y = " << s.y << std::endl;\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"x = 1; y = 0\n")),(0,r.kt)("h4",{id:"indirect-selection"},"Indirect Selection"),(0,r.kt)("p",null,"The indirect selection operator (",(0,r.kt)("inlineCode",{parentName:"p"},"->"),") takes a pointer to an object of complete class type as its left operand and the member name as its right operand "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// Indirect Selection\n// indirect.cpp\n\n#include <iostream>\n\ntypedef struct\n{\n    int x;\n    double y;\n} S;\n\nS* add2(S *s)\n{\n    s->x += 2;\n    s->y += 2;\n    return s;\n}\n\nint main()\n{\n    S s = {0, 0};\n\n    add2(&s)->x++;  // add2(&s) is modifiable\n    std::cout << "x = " << s.x << "; y = " << s.y << std::endl;\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"x = 3; y = 2\n")),(0,r.kt)("h3",{id:"postfix-increment-and-decrement"},"Postfix Increment and Decrement"),(0,r.kt)("p",null,"The postfix increment and decrement operators change an lvalue by one unit ",(0,r.kt)("em",{parentName:"p"},"after")," accessing the value.  The operand is of integral, floating-point, or pointer type and followed by the increment (",(0,r.kt)("inlineCode",{parentName:"p"},"++"),") or decrement (",(0,r.kt)("inlineCode",{parentName:"p"},"--"),") operator.  The operand must be a modifiable lvalue and the expression itself is a prvalue."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// Post-Fix Operators\n// postfix.cpp\n\n#include <iostream>\n\nint main()\n{\n    int i = 10;\n\n    std::cout << i++ << std::endl;\n    (i++)++;           // ERROR (i++) is a prvalue, not an lvalue \n    std::cout << i << std::endl;\n}\n")),(0,r.kt)("h4",{id:"results-at-integer-limits"},"Results at Integer Limits"),(0,r.kt)("p",null,"If the operand is of ",(0,r.kt)("inlineCode",{parentName:"p"},"unsigned")," type and its value is ",(0,r.kt)("inlineCode",{parentName:"p"},"0u"),", the decrement operator changes the lvalue to the largest storable value.  If the operand is of ",(0,r.kt)("inlineCode",{parentName:"p"},"unsigned")," type and its value is the largest storable value, the increment operator changes the lvalue to 0u."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// Post-Fix Operators on Unsigned Values\n// unsigned.cpp\n\n#include <iostream>\n\nint main()\n{\n    unsigned i = 0u;\n\n    i--;\n    std::cout << i++ << std::endl;\n    std::cout << i << std::endl;\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"4294967295\n0\n")),(0,r.kt)("p",null,"If the operand is of ",(0,r.kt)("inlineCode",{parentName:"p"},"signed")," integral type, floating-point type, or pointer type, and the increment/decrement operation produces an overflow/underflow, the result is undefined."),(0,r.kt)("h3",{id:"typeid-operator-optional-for-oop345"},(0,r.kt)("inlineCode",{parentName:"h3"},"typeid()")," Operator (optional for OOP345)"),(0,r.kt)("p",null,"The type identifier operator queries information about a type.  The operator takes either a type or an expression and refers to a ",(0,r.kt)("inlineCode",{parentName:"p"},"std::type_info")," that represents the dynamic type of the expression.  The ",(0,r.kt)("inlineCode",{parentName:"p"},"std::type_info")," object holds implementation-specific information about a type, which includes its name and the means to compare for equality.  For an example of how this operator is used see the section entitled ",(0,r.kt)("a",{parentName:"p",href:"/C-Class-Relationships/inheritance-and-inclusion-polymorphism#dynamic-type-identification-optional"},"Dynamic Type Identification")," in the Chapter ",(0,r.kt)("a",{parentName:"p",href:"/C-Class-Relationships/inheritance-and-inclusion-polymorphism"},"Inheritance and Inclusion Polymorphism"),"."),(0,r.kt)("h3",{id:"constrained-cast-operators"},"Constrained Cast Operators"),(0,r.kt)("h4",{id:"static_cast-operator"},(0,r.kt)("inlineCode",{parentName:"h4"},"static_cast")," Operator"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"static_cast<T>(v)")," operator converts expression ",(0,r.kt)("inlineCode",{parentName:"p"},"v")," to type ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),".  If ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is an lvalue reference type or an rvalue reference to a function type, the result is an lvalue.  If ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is an rvalue reference to an object type, the result is an xvalue.  Otherwise, the result is a prvalue."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"static_cast<T>(v)")," operator can perform the following conversions"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Standard (Implicit) Conversions and their opposite",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"lvalue to rvalue"),(0,r.kt)("li",{parentName:"ul"},"integral or floating-point promotions"),(0,r.kt)("li",{parentName:"ul"},"conversions: integral, floating-point, floating-point to integral, integral to floating-point, pointer, pointer to member, boolean"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"void*")," to pointer type"))),(0,r.kt)("li",{parentName:"ul"},"between related classes"),(0,r.kt)("li",{parentName:"ul"},"enumerator to integral or floating-point"),(0,r.kt)("li",{parentName:"ul"},"scoped enumerator to integral or floating-point"),(0,r.kt)("li",{parentName:"ul"},"rvalue references"),(0,r.kt)("li",{parentName:"ul"},"any type to void discarding the value")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"static_cast<T>(v)")," operator cannot cast away ",(0,r.kt)("inlineCode",{parentName:"p"},"const"),"-ness."),(0,r.kt)("h4",{id:"reinterpret_cast-operator"},(0,r.kt)("inlineCode",{parentName:"h4"},"reinterpret_cast")," Operator"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"reinterpret_cast<T>(v)")," operator converts expression ",(0,r.kt)("inlineCode",{parentName:"p"},"v")," to type ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),".  If ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is an lvalue reference type or an rvalue reference to a function type, the result is an lvalue.  If ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is an rvalue reference to an object type, the result is an xvalue.  Otherwise, the result is a prvalue. "),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"reinterpret_cast<T>(v)")," operator can perform the following conversions"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"pointer to member to pointer to member of different type"),(0,r.kt)("li",{parentName:"ul"},"pointer to integral, integral or enumeration type to pointer"),(0,r.kt)("li",{parentName:"ul"},"function pointer to function pointer of different type"),(0,r.kt)("li",{parentName:"ul"},"object pointer to an object pointer of different type"),(0,r.kt)("li",{parentName:"ul"},"function pointer to object pointer (conditionally supported)")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"reinterpret_cast<T>(v)")," operator cannot cast away ",(0,r.kt)("inlineCode",{parentName:"p"},"const"),"-ness."),(0,r.kt)("h4",{id:"const_cast-operator"},(0,r.kt)("inlineCode",{parentName:"h4"},"const_cast")," Operator"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"const_cast<T>(v)")," operator converts expression ",(0,r.kt)("inlineCode",{parentName:"p"},"v")," to type ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),".  If ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is an lvalue reference to an object type, the result is an lvalue.  If ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is an rvalue reference to an object type, the result is an xvalue.  Otherwise, the result is a prvalue."),(0,r.kt)("h4",{id:"dynamic_cast-operator-optional-for-oop345"},(0,r.kt)("inlineCode",{parentName:"h4"},"dynamic_cast")," Operator (optional for OOP345)"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"dynamic_cast<T>(v)")," operator converts expression ",(0,r.kt)("inlineCode",{parentName:"p"},"v")," to type ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),".  ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is a pointer or reference to a complete type.  If ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is a pointer type, ",(0,r.kt)("inlineCode",{parentName:"p"},"v")," shall be an lvalue of a complete class and the result is an lvalue of the type referred to by ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),".  If ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is an rvalue reference to an object type, ",(0,r.kt)("inlineCode",{parentName:"p"},"v")," shall be an glvalue of a complete class and the result is an xvalue of the type referred to by ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),". "),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"dynamic_cast<T>(v)")," operator cannot cast away ",(0,r.kt)("inlineCode",{parentName:"p"},"const"),"-ness."),(0,r.kt)("p",null,"For an example of how this operator is used see the section entitled ",(0,r.kt)("a",{parentName:"p",href:"/C-Class-Relationships/inheritance-and-inclusion-polymorphism#specializing-an-operation-for-a-dynamic-type-optional"},"Specializing an Operation for a Dynamic Type")," in the Chapter ",(0,r.kt)("a",{parentName:"p",href:"/C-Class-Relationships/inheritance-and-inclusion-polymorphism"},"Inheritance and Inclusion Polymorphism"),"."),(0,r.kt)("h2",{id:"prefix-expressions"},"Prefix Expressions"),(0,r.kt)("p",null,"The prefix expressions are increment and decrement expressions in which the operator precedes the operand and associates from right to left. "),(0,r.kt)("h3",{id:"prefix-increment-and-decrement"},"Prefix Increment and Decrement"),(0,r.kt)("p",null,"The prefix increment (",(0,r.kt)("inlineCode",{parentName:"p"},"++"),") and decrement (",(0,r.kt)("inlineCode",{parentName:"p"},"--"),") operators change an lvalue by one unit before accessing the value.  The result of the operation is an lvalue, unlike their post-fix counterparts.  The operand may be of any integral type, floating-point type, or pointer type, but must be a modifiable lvalue.  For example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// Pre-Fix Operators\n// prefix.cpp\n\n#include <iostream>\n\nint main()\n{\n    int i = 10;\n\n    std::cout << ++i << std::endl;\n    ++(++i);           // OK (++i) is an lvalue \n    std::cout << i << std::endl;\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"11\n13\n")),(0,r.kt)("h4",{id:"results-at-the-limit"},"Results at the Limit"),(0,r.kt)("p",null,"The results of a prefix increment and decrement operation on upper and lower limit values of ",(0,r.kt)("inlineCode",{parentName:"p"},"unsigned")," types and signed types are similar to those for postfix increment and decrement operations."),(0,r.kt)("p",null,"If the operand is of ",(0,r.kt)("inlineCode",{parentName:"p"},"unsigned")," type and its value is 0, the decrement operation evaluates to the largest storable value.  If the operand in a prefix expression is of ",(0,r.kt)("inlineCode",{parentName:"p"},"unsigned")," type and its value is the largest storable value, the increment operation evaluates to 0. "),(0,r.kt)("p",null,"If the operand is of ",(0,r.kt)("inlineCode",{parentName:"p"},"signed")," integral type, floating-point type, or pointer type, and the increment/decrement operation produces an overflow/underflow, the result is undefined."),(0,r.kt)("h2",{id:"unary-expressions"},"Unary Expressions"),(0,r.kt)("p",null,"The unary expressions are expressions in which the operator precedes a single operand.  They include size evaluation, logical and bit-wise negation, arithmetic plus and negation, addressing, indirection, and type casting.  Unary operators associate from right to left. "),(0,r.kt)("h3",{id:"sizeof-sizeof"},(0,r.kt)("inlineCode",{parentName:"h3"},"sizeof()"),", ",(0,r.kt)("inlineCode",{parentName:"h3"},"sizeof")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"sizeof()")," operator evaluates the ",(0,r.kt)("strong",{parentName:"p"},"type")," of its operand and returns its size in bytes.  The ",(0,r.kt)("inlineCode",{parentName:"p"},"sizeof")," operator (without the parentheses) returns the number of bytes used by a variable, object, or expression.  The result of either ",(0,r.kt)("inlineCode",{parentName:"p"},"sizeof")," operation is a constant of type ",(0,r.kt)("inlineCode",{parentName:"p"},"size_t")," (an unsigned integral type).  For example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// Size of a Type\n// sizeof.cpp\n\n#include <iostream>\n\nint main()\n{\n    double x;\n\n    std::cout << "On this machine, \\n"\n                 "the size of an int is " << sizeof(int) \n              << "bytes,\\nthe size of x is "\n              << sizeof x << "bytes" << std::endl;\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"On this machine,\nthe size of an int is 4 bytes,\nthe size of x is 8 bytes.\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"sizeof()")," takes a type, while ",(0,r.kt)("inlineCode",{parentName:"p"},"sizeof")," takes a variable, object, or expression.  With some compilers, the syntax is interchangeable. "),(0,r.kt)("p",null,"The compiler evaluates ",(0,r.kt)("inlineCode",{parentName:"p"},"sizeof")," expressions at compile time.  If its operand is an expression, the compiler does not evaluate that expression:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// sizeof Operator\n// sizeof.cpp\n\n#include <iostream>\n\nint main()\n{\n    int j = 1;\n\n    std::cout << sizeof j++ << std::endl;\n    std::cout << j << std::endl; // j is still 1 \n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"4\n1\n")),(0,r.kt)("p",null,"If the operand is an array name and the size of the array is within the scope of the expression, the ",(0,r.kt)("inlineCode",{parentName:"p"},"sizeof")," operator returns the size of the array in bytes; that is, the number of elements in the array times the size of the type of one array element.  However, if the operand is a function parameter that holds the address of an array, the operator returns the size of the pointer that holds the address, and not the size of the array: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// sizeof Operator\n// sizeofArray.cpp\n\n#include <iostream>\n\nint foo(double a[])\n{\n    a[0] = 1.0;\n    return sizeof a;\n}\n\nint main()\n{\n    double a[] = {1.1, 2.2, 3.3, 4.4};\n\n    std::cout << sizeof a << std::endl;\n    std::cout << foo(a) << std::endl;\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"32\n4\n")),(0,r.kt)("p",null,"If the operand is an object of class type, the operation returns the sum of the sizes of the subobjects including any padding.  The result is implementation dependent.  For example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// sizeof Operator\n// sizeofStruct.cpp\n\n#include <iostream>\n\ntypedef struct\n{\n    char a;\n    int b;\n} A;\n\nint main()\n{\n    A s;\n\n    std::cout << sizeof s << std::endl;\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"8\n")),(0,r.kt)("h3",{id:"logical-negation"},"Logical Negation"),(0,r.kt)("p",null,"The logical negation operator (",(0,r.kt)("inlineCode",{parentName:"p"},"!"),") converts its operand to a ",(0,r.kt)("inlineCode",{parentName:"p"},"bool")," value and returns the converse of that value.  The operand may be of integral type, floating-point type, or pointer type.  The expression evaluates to a prvalue.  If the operand is ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"0.0")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"nullptr"),", the expression evaluates to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),".  If the operand is any value other, the expression evaluates to ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,r.kt)("h3",{id:"bit-wise-negation"},"Bit-Wise Negation"),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"/H-Deeper-Detail/bit-wise-expressions"},"Bit-Wise Operators")," for the bit-wise operator (",(0,r.kt)("inlineCode",{parentName:"p"},"~"),"). "),(0,r.kt)("h3",{id:"arithmetic-negation"},"Arithmetic Negation"),(0,r.kt)("p",null,"The unary negation operator (",(0,r.kt)("inlineCode",{parentName:"p"},"-"),") evaluates to its operand with its sign reversed.  The result is a prvalue of the same type as the operand after any promotions. "),(0,r.kt)("h4",{id:"results-for-unsigned-types"},"Results for Unsigned Types"),(0,r.kt)("p",null,"The negation operator (",(0,r.kt)("inlineCode",{parentName:"p"},"-"),") applied to an operand of unsigned type deserves special attention.  The result of the expression is of unsigned type and equal to $2^n$-operand where $n$ is the number of bits used to store the operand: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// Arithmetic Negation\n// minus.cpp\n\n#include <iostream>\n#include <iomanip>\n\nint main()\n{\n    unsigned a = 2u;\n    unsigned c = 1u;\n    unsigned e = 0u;\n\n    std::cout << a << std::setw(11) << -a << std::endl; \n    std::cout << c << std::setw(11) << -c << std::endl;\n    std::cout << e << std::setw(11) << -e << std::endl;\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"2 4294967294\n1 4294967295\n0          0 \n")),(0,r.kt)("p",null,"The arithmetic negation of an operand of signed integer type or floating-point type is undefined if overflow occurs. "),(0,r.kt)("h3",{id:"arithmetic-plus"},"Arithmetic Plus"),(0,r.kt)("p",null,"The unary plus operator (",(0,r.kt)("inlineCode",{parentName:"p"},"+"),") evaluates to its operand.  The result is a prvalue of the same type as the operand after any promotions.  The operator is present in the language for symmetry. "),(0,r.kt)("h3",{id:"address-of"},"Address of"),(0,r.kt)("p",null,"The address-of operator (",(0,r.kt)("inlineCode",{parentName:"p"},"&"),") returns a pointer to its operand: the value is the address of the operand.  The operand must be an lvalue that is not of storage class ",(0,r.kt)("inlineCode",{parentName:"p"},"register"),".  The expression is a prvalue."),(0,r.kt)("p",null,"We cannot take the address of a bit field and there are no pointers to bit fields of user-defined type. "),(0,r.kt)("h3",{id:"indirection"},"Indirection"),(0,r.kt)("p",null,"The indirection operator (",(0,r.kt)("inlineCode",{parentName:"p"},"*"),") returns the value stored in the address that the operand contains.  The expression is itself an lvalue. "),(0,r.kt)("p",null,"The indirection and address-of operators are inverses of one another.  The result of ",(0,r.kt)("inlineCode",{parentName:"p"},"*&x")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),". "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// Indirection\n// indirection.cpp\n\n#include <iostream>\n#include <iomanip>\n\nint main()\n{\n    int x = 3;\n    int* p = &x;\n    std::cout << x << std::setw(11) << p << std::endl; \n\n    *&x = 4;\n    std::cout << x << std::setw(11) << p << std::endl; \n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"3   002BF824\n4   002BF824\n")),(0,r.kt)("h3",{id:"cast"},"Cast"),(0,r.kt)("p",null,"The type-cast operator consists of a type name followed by an operand and converts the operand to the specified type.  The operand may not be the name of an array.  The expression is a prvalue. "),(0,r.kt)("p",null,"There are two styles of casting:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"C-style casts - enclose the target type within parentheses"),(0,r.kt)("li",{parentName:"ul"},"C++-function-style casts - enclose the operand within parentheses")),(0,r.kt)("p",null,"We may C-style cast an operand of integral or floating-point type to an integral or floating-point type; an operand of pointer type to any other pointer type or any integral type; and an operand of integral type, generic pointer type, or non-generic pointer type to a pointer type. "),(0,r.kt)("p",null,"We may function-style cast an operand of integral or floating-point type to an integral or floating-point type; and an operand of pointer type to any integral type. "),(0,r.kt)("h3",{id:"alignof-operator"},(0,r.kt)("inlineCode",{parentName:"h3"},"alignof()")," Operator"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"alignof()")," operator returns the alignment requirement of its operand.  The operand may be a type identifier representing the type of a complete object, or an array or a reference to one of those types.  The operation returns an integral constant of type ",(0,r.kt)("inlineCode",{parentName:"p"},"std::size_t"),". "),(0,r.kt)("p",null,"For an example, see section entitled ",(0,r.kt)("a",{parentName:"p",href:"/B-Types/fundamental-types#type-alignment"},"Type Alignment")," in the Chapter ",(0,r.kt)("a",{parentName:"p",href:"/B-Types/fundamental-types"},"Fundamental Types"),"."),(0,r.kt)("h3",{id:"decltype-specifier"},(0,r.kt)("inlineCode",{parentName:"h3"},"decltype()")," Specifier"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"decltype()")," specifier evaluates to the type and value category of its argument.  The operand may be an entity or an expression.  The value category of the expression affects the type:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"if the value category of the expression is an xvalue, then the type is ",(0,r.kt)("inlineCode",{parentName:"li"},"T&&")),(0,r.kt)("li",{parentName:"ul"},"if the value category of the expression is an lvalue, then the type is ",(0,r.kt)("inlineCode",{parentName:"li"},"T&")),(0,r.kt)("li",{parentName:"ul"},"if the value category of the expression is a prvalue, then the type is ",(0,r.kt)("inlineCode",{parentName:"li"},"T"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// decltype with expressions\n// decltype_expre.cpp\n\n#include <iostream>\n\nint main()\n{\n    int i = 3, j = 6;\n    double x = 4.5;\n    double& r = x;\n\n    decltype(i + j) y = i + j; // int y\n    decltype(i + x) z = i + x; // double z\n    decltype(r) s = r;         // double& s \n\n    std::cout << y << std::endl;\n    std::cout << z << std::endl;\n    std::cout << s << std::endl;\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"9\n7.5\n4.5 \n")),(0,r.kt)("h3",{id:"noexcept-operator"},(0,r.kt)("inlineCode",{parentName:"h3"},"noexcept()")," Operator"),(0,r.kt)("p",null,"The no exception operator (",(0,r.kt)("inlineCode",{parentName:"p"},"noexcept()"),") returns true if the argument does not throw an exception.  This compile-time function evaluates to a prvalue of type ",(0,r.kt)("inlineCode",{parentName:"p"},"bool"),".  This operator does not evaluate the argument passed to it.  This operator returns ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," if the expression contains:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a call to function that does not have a non-throwing exception specification (",(0,r.kt)("inlineCode",{parentName:"li"},"noexcept"),"), unless it is a constant expression"),(0,r.kt)("li",{parentName:"ul"},"a throw expression"),(0,r.kt)("li",{parentName:"ul"},"a ",(0,r.kt)("inlineCode",{parentName:"li"},"dynamic_cast")," expression when the target type is a reference type and conversion needs a run-time check"),(0,r.kt)("li",{parentName:"ul"},"a ",(0,r.kt)("inlineCode",{parentName:"li"},"typeid")," expression when the argument is a polymorphic type")),(0,r.kt)("p",null,"A function with a ",(0,r.kt)("inlineCode",{parentName:"p"},"noexcept")," specification in its declaration should be a non-throwing function.  If a function marked ",(0,r.kt)("inlineCode",{parentName:"p"},"noexcept")," allows an uncaught exception to escape at run-time, the program terminates immediately.  For further details, see the section on ",(0,r.kt)("a",{parentName:"p",href:"/D-Processing/error-handling#noexcept"},"No Exceptions")," in the Chapter entitled ",(0,r.kt)("a",{parentName:"p",href:"/D-Processing/error-handling"},"Error Handling"),"."),(0,r.kt)("h3",{id:"throw-operator"},(0,r.kt)("inlineCode",{parentName:"h3"},"throw")," Operator"),(0,r.kt)("p",null,"The throw operator (",(0,r.kt)("inlineCode",{parentName:"p"},"throw"),") identifies an exception to normal execution.  The operator creates a temporary object from its operand and transfers control to the exception handler.  The exception object is an lvalue of the type of the operand of the throw expression.  This operand is analogous to an argument passed to a function and received in its parameter.  For example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// Throw Operator\n// throw.cpp\n\n#include <iostream>\n\nint divide(int x, int y)\n{\n    if (y == 0)\n        throw "divide by zero inadmissible";\n    else\n        return x / y;\n}\n\nint main ()\n{\n    int dividend, divisor, quotient = 0;\n\n    std::cout << "Enter dividend : ";\n    std::cin >> dividend;\n    std::cout << "Enter divisor  : ";\n    std::cin >> divisor;\n\n    //... execute function successfully or throw exception \n\n    quotient = divide(dividend, divisor);\n\n    // ... handle exception\n\n    std::cout << "Quotient = " << quotient << std::endl;\n}\n')),(0,r.kt)("p",null,"For details on handling an exception that has been thrown see the section on ",(0,r.kt)("a",{parentName:"p",href:"/D-Processing/error-handling#exceptions"},"Exceptions")," in the Chapter entitled ",(0,r.kt)("a",{parentName:"p",href:"/D-Processing/error-handling"},"Error Handling"),"."),(0,r.kt)("h2",{id:"binary-expressions"},"Binary Expressions"),(0,r.kt)("p",null,"Binary expressions consist of two operands and one operator.  They include arithmetic, relative, logical, and bit-wise expressions.  They evaluate to prvalues."),(0,r.kt)("h3",{id:"arithmetic"},"Arithmetic"),(0,r.kt)("h4",{id:"multiplicative"},"Multiplicative"),(0,r.kt)("p",null,"A multiplicative expression evaluates the product, quotient, or remainder of its operands.  The operator separates the operands.  The operands are of integral or floating-point type for product and quotient operations (",(0,r.kt)("inlineCode",{parentName:"p"},"*")," ",(0,r.kt)("inlineCode",{parentName:"p"},"/"),").  The operands for the remainder operation (",(0,r.kt)("inlineCode",{parentName:"p"},"%"),") are of integral or unscoped enumeration type; the remainder operation (",(0,r.kt)("inlineCode",{parentName:"p"},"%"),") is undefined for operands of floating-point type."),(0,r.kt)("h4",{id:"addition"},"Addition"),(0,r.kt)("p",null,"The addition operator (",(0,r.kt)("inlineCode",{parentName:"p"},"+"),") adds the values of its operands.  The operands may be of integral type, floating-point type, or non-generic pointer type.  If one operand is of pointer type, the other must be of integral or unscoped enumeration type.  For additions to an operand of pointer type see the section entitled ",(0,r.kt)("a",{parentName:"p",href:"/F-MemoryModel/raw-pointers#expressions"},"Expressions")," in the chapter ",(0,r.kt)("a",{parentName:"p",href:"/F-MemoryModel/raw-pointers"},"Raw Pointers"),"."),(0,r.kt)("h4",{id:"subtraction"},"Subtraction"),(0,r.kt)("p",null,"The subtraction operator (",(0,r.kt)("inlineCode",{parentName:"p"},"-"),") subtracts the value of its second operand from the value of its first operand.  The operands may be of integral type, floating-point type, or non-generic pointer type.  If the left operand is of pointer type, the right operand must be of integral, unscoped enumeration or pointer type.  For subtractions from an operand of pointer type see the section entitled ",(0,r.kt)("a",{parentName:"p",href:"/F-MemoryModel/raw-pointers#expressions"},"Expressions")," in the chapter ",(0,r.kt)("a",{parentName:"p",href:"/F-MemoryModel/raw-pointers"},"Raw Pointers"),"."),(0,r.kt)("h3",{id:"bit-shifting"},"Bit-Shifting"),(0,r.kt)("p",null,"See the chapter entitled ",(0,r.kt)("a",{parentName:"p",href:"/H-Deeper-Detail/bit-wise-expressions"},"Bit-Wise Expressions")," for the bit-shifting operators (",(0,r.kt)("inlineCode",{parentName:"p"},"<<")," ",(0,r.kt)("inlineCode",{parentName:"p"},">>"),")."),(0,r.kt)("h3",{id:"relational"},"Relational"),(0,r.kt)("p",null,"A relational expression compares the values of two operands for relative magnitude, equality, or inequality.  The operands are of arithmetic, enumeration, or pointer type.  If one of the operands is of pointer type, then the other operand must be of compatible pointer type or the ",(0,r.kt)("inlineCode",{parentName:"p"},"nullptr")," constant.  A relational expression is of type ",(0,r.kt)("inlineCode",{parentName:"p"},"bool")," and evaluates to either ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),". "),(0,r.kt)("h4",{id:"less-than"},"Less-Than"),(0,r.kt)("p",null,"The less-than operators (",(0,r.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"<="),") compare the relative magnitude of their operands' values. "),(0,r.kt)("h4",{id:"greater-than"},"Greater-Than"),(0,r.kt)("p",null,"The greater-than operators (",(0,r.kt)("inlineCode",{parentName:"p"},">"),", ",(0,r.kt)("inlineCode",{parentName:"p"},">="),") compare the relative magnitude of their operands' values. "),(0,r.kt)("h4",{id:"equality"},"Equality"),(0,r.kt)("p",null,"The equality operator (",(0,r.kt)("inlineCode",{parentName:"p"},"=="),") compares the values of its operands for identity. "),(0,r.kt)("h4",{id:"inequality"},"Inequality"),(0,r.kt)("p",null,"The inequality operator (",(0,r.kt)("inlineCode",{parentName:"p"},"!="),") compares the values of its operands for lack of identity."),(0,r.kt)("p",null,"If the right operand is zero-valued, we may omit it and the operator and thereby convert the left operand into a truth evaluation.  That is, the expression in the first sample below evaluates to the same result as the expression on the second one:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"if (x != 0)\n{\n    // ...\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"if (x)\n{\n    // ...\n}\n")),(0,r.kt)("h3",{id:"bit-wise-and"},"Bit-Wise and"),(0,r.kt)("p",null,"See the chapter entitled ",(0,r.kt)("a",{parentName:"p",href:"/H-Deeper-Detail/bit-wise-expressions"},"Bit-Wise Expressions")," for the bit-wise and operator (",(0,r.kt)("inlineCode",{parentName:"p"},"&"),"). "),(0,r.kt)("h3",{id:"bit-wise-or"},"Bit-Wise or"),(0,r.kt)("p",null,"See the chapter entitled ",(0,r.kt)("a",{parentName:"p",href:"/H-Deeper-Detail/bit-wise-expressions"},"Bit-Wise Expressions")," for the bit-wise or operator (",(0,r.kt)("inlineCode",{parentName:"p"},"|"),"). "),(0,r.kt)("h3",{id:"bit-wise-exclusive-or"},"Bit-Wise Exclusive or"),(0,r.kt)("p",null,"See the chapter entitled ",(0,r.kt)("a",{parentName:"p",href:"/H-Deeper-Detail/bit-wise-expressions"},"Bit-Wise Expressions")," for the bit-wise exclusive or operator (",(0,r.kt)("inlineCode",{parentName:"p"},"^"),"). "),(0,r.kt)("h3",{id:"logical"},"Logical"),(0,r.kt)("p",null,"Binary logical expressions evaluate the combined truthfulness of their operands.  The operands may be of integral type, floating-point type, or pointer type.  The type of one operand may differ from the type of the other.  Logical expressions evaluate to values of type ",(0,r.kt)("inlineCode",{parentName:"p"},"bool"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),". "),(0,r.kt)("h4",{id:"intersection-and-union"},"Intersection and Union"),(0,r.kt)("p",null,"The logical 'and' operator (",(0,r.kt)("inlineCode",{parentName:"p"},"&&"),") compares its operands and returns their intersection.  The following rules apply:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"true"),", if both operands are ",(0,r.kt)("inlineCode",{parentName:"li"},"true")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"false"),", if either of the operands is ",(0,r.kt)("inlineCode",{parentName:"li"},"false"))),(0,r.kt)("p",null,"The logical 'or' operator (",(0,r.kt)("inlineCode",{parentName:"p"},"||"),") compares its operands and returns their union.  The following rules apply:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"true"),", if either operand is ",(0,r.kt)("inlineCode",{parentName:"li"},"true")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"false"),", if both of the operands are ",(0,r.kt)("inlineCode",{parentName:"li"},"false"))),(0,r.kt)("h4",{id:"left-to-right"},"Left to Right"),(0,r.kt)("p",null,"Logical expressions evaluate their operands left-to-right as necessary.  In this respect, they differ from other binary expressions.  If the left operand determines the result, the right operand is ",(0,r.kt)("strong",{parentName:"p"},"not")," evaluated.  For instance, if the left operand is ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," and the operator is ",(0,r.kt)("inlineCode",{parentName:"p"},"&&"),", the right operand is not evaluated.  Similarly, if the left operand is true and operator is ",(0,r.kt)("inlineCode",{parentName:"p"},"||"),", the right operand is not evaluated. "),(0,r.kt)("p",null,"The following program does not increment either ",(0,r.kt)("inlineCode",{parentName:"p"},"j")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"i"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// Logical Expressions\n// logical.cpp\n\n#include <iostream>\n\nint main()\n{\n    int i = 1, j = 1;\n\n    std::cout << (i < 2 || j++ == 1) << ' ' << j << std::endl;\n    std::cout << (j == 2 && i++ == 1) << ' ' << i << std::endl; \n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"1 1\n0 1\n")),(0,r.kt)("h4",{id:"order-matters"},"Order Matters"),(0,r.kt)("p",null,"Because logical expressions guarantee left to right evaluation, the order of their operands matters.  Consider the expression"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'int* a = nullptr;\nif ( nullptr != a && 6 == a[i] ) // OK - Correct Order\n    std::cout << "a[" << i << "] is " << a[i] << std::endl;\nelse\n    std::cout << "Memory not allocated!" << std::endl;\n')),(0,r.kt)("p",null,"This code will not crash since ",(0,r.kt)("inlineCode",{parentName:"p"},"a != nullptr"),".  However, if we switched the order of the two conditions, we would expose the possibility of a crash at the evaluation of ",(0,r.kt)("inlineCode",{parentName:"p"},"a[i]"),": "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'int* a = nullptr;\nif ( 6 == a[i] && nullptr != a ) // ERROR - Wrong Order\n    std::cout << "a[" << i << "] is " << a[i] << std::endl;\nelse\n    std::cout << "Memory not allocated!" << std::endl;\n')),(0,r.kt)("h3",{id:"assignment-expressions"},"Assignment Expressions"),(0,r.kt)("p",null,"An assignment expression copies from the right operand to the left operand.  The left operand must be a modifiable lvalue.  Because assignment expressions associate from right to left, cascading is possible.  The expressions may be simple or compound. "),(0,r.kt)("h4",{id:"simple-assignment"},"Simple Assignment"),(0,r.kt)("p",null,"The simple assignment operator (",(0,r.kt)("inlineCode",{parentName:"p"},"="),") copies the value of the right operand without modification into the left operand.  We can cascade the assignment to several variables of a single value:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// Assignment Expressions\n// assignment.cpp\n\n#include <iostream>\n\nint main()\n{\n    int i, j, k;\n\n    i = j = k = 3;\n    std::cout << i << ' ' << j << ' ' << k << std::endl; \n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"3 3 3\n")),(0,r.kt)("p",null,"If we encapsulate an array in a class type, we can copy all of its elements in a simple assignment.  For example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// Assignment Expressions\n// copyArray.cpp\n\n#include <iostream>\n\ntypedef struct\n{\n    int a[20];\n} Array;\n\nint main()\n{\n    Array original = {1, 2, 3, 4, 5}, copy;\n\n    copy = original;\n\n    for (int i = 0; i < 5; i++)\n        std::cout << copy.a[i] << ' ';\n    std::cout << std::endl;\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"1 2 3 4 5\n")),(0,r.kt)("h4",{id:"compound-assignment"},"Compound Assignment"),(0,r.kt)("p",null,"The compound operators (",(0,r.kt)("inlineCode",{parentName:"p"},"+=")," ",(0,r.kt)("inlineCode",{parentName:"p"},"-=")," ",(0,r.kt)("inlineCode",{parentName:"p"},"*=")," ",(0,r.kt)("inlineCode",{parentName:"p"},"/=")," ",(0,r.kt)("inlineCode",{parentName:"p"},"%=")," ",(0,r.kt)("inlineCode",{parentName:"p"},">>=")," ",(0,r.kt)("inlineCode",{parentName:"p"},"<<=")," ",(0,r.kt)("inlineCode",{parentName:"p"},"~=")," ",(0,r.kt)("inlineCode",{parentName:"p"},"&=")," ",(0,r.kt)("inlineCode",{parentName:"p"},"|=")," ",(0,r.kt)("inlineCode",{parentName:"p"},"^="),") perform the operation specified by the first character in the operator on the two operands before copying the result into the left operand."),(0,r.kt)("h3",{id:"sequential-expressions"},"Sequential Expressions"),(0,r.kt)("p",null,"The comma operator (",(0,r.kt)("inlineCode",{parentName:"p"},","),") divides expressions for separate evaluation in sequence from the left.  The operands may be expressions themselves and may be of any type.  The type and value of the result of a sequential expression is that of its rightmost operand. "),(0,r.kt)("p",null,"A common use of the comma operator is in definitions and iteration constructs"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void reverse(char *s)\n{\n    char t;\n\n    for (int i = 0, j = strlen(s) - 1; i < j; i++, j--)\n    {\n        t = s[i];\n        s[i] = s[j];\n        s[j] = t;\n    }\n}\n")),(0,r.kt)("h3",{id:"mixed-type-binary-expressions"},"Mixed-Type Binary Expressions"),(0,r.kt)("p",null,"The above descriptions apply to binary expressions on operands of compatible type.  If the operands in the expression are not of the type defined for the operator, one of the operands must be converted to a compatible type.  The compiler promotes operands types if necessary to evaluate a binary expression.  It converts the operand of lower type to a higher type using the following hierarchy:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"long double")),(0,r.kt)("td",{parentName:"tr",align:null},"highest")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"double")),(0,r.kt)("td",{parentName:"tr",align:null},"...")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"float")),(0,r.kt)("td",{parentName:"tr",align:null},"...")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"unsigned long long")),(0,r.kt)("td",{parentName:"tr",align:null},"...")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"long long")),(0,r.kt)("td",{parentName:"tr",align:null},"...")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"unsigned long")),(0,r.kt)("td",{parentName:"tr",align:null},"...")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"long")),(0,r.kt)("td",{parentName:"tr",align:null},"...")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"unsigned int")),(0,r.kt)("td",{parentName:"tr",align:null},"...")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"...")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"unsigned char")),(0,r.kt)("td",{parentName:"tr",align:null},"...")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"char")),(0,r.kt)("td",{parentName:"tr",align:null},"...")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},"lowest")))),(0,r.kt)("p",null,"If one pointer is of generic (",(0,r.kt)("inlineCode",{parentName:"p"},"void*"),") type and the operation requires pointers of compatible type, the compiler converts the non-generic pointer to generic (",(0,r.kt)("inlineCode",{parentName:"p"},"void*"),") type. "),(0,r.kt)("h4",{id:"the-unsigned-trap"},"The Unsigned Trap"),(0,r.kt)("p",null,"If one of the operands is of ",(0,r.kt)("inlineCode",{parentName:"p"},"unsigned")," integral type and the other is of a ",(0,r.kt)("inlineCode",{parentName:"p"},"signed")," integral type, the compiler promotes the value of the ",(0,r.kt)("inlineCode",{parentName:"p"},"signed")," type to a value of ",(0,r.kt)("inlineCode",{parentName:"p"},"unsigned")," type.  This particular promotion may produce a counter-intuitive result.  For example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// Relational Expressions\n// relational.cpp\n\n#include <iostream>\n\nint main()\n{\n    unsigned len = 0u;\n\n    std::cout << (len > -1) << std::endl; // might expect true\n                                          // evaluates to false \n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0\n")),(0,r.kt)("p",null,"The expression in parentheses has a value of ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," (0) because the compiler promoted -1 to the largest unsigned integer 4294967295u before evaluating the expression."),(0,r.kt)("h3",{id:"good-design-practice"},"Good Design Practice"),(0,r.kt)("h4",{id:"avoid-implicit-promotions"},"Avoid Implicit Promotions"),(0,r.kt)("p",null,"Implicit promotions are not necessarily portable.  Type promotions may vary across platforms.  Hence, it is preferable to cast the operand of lower type explicitly. "),(0,r.kt)("h4",{id:"sub-divide-complex-binary-expressions"},"Sub-Divide Complex Binary Expressions"),(0,r.kt)("p",null,"Complex binary expressions are not always portable.  Consider"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int x = 3;\nx = x + ++x;  // the result may be either 7 or 8 \n")),(0,r.kt)("p",null,"The order of evaluation of the operands in a binary expression is implementation dependent.  To ensure identical results on all platforms, we subdivide complex binary expressions into multiple statements that clarify our intent:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int x = 3;\n++x;\nx = x + x;  // increment first = 8 \n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int x = 3, y;\ny = ++x;\nx = x + y;  // add first = 7 \n")),(0,r.kt)("h2",{id:"ternary-expression"},"Ternary Expression"),(0,r.kt)("p",null,"The ternary expression is a conditional expression.  The first operator (",(0,r.kt)("inlineCode",{parentName:"p"},"?"),") identifies the expression as a selection construct; the second operator (",(0,r.kt)("inlineCode",{parentName:"p"},":"),") separates the choices. "),(0,r.kt)("p",null,"The leftmost operand may be of integral type, floating-point or pointer type.  If it evaluates to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", the expression evaluates the second operand, but not the third operand.  If the leftmost operand evaluates to ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),", the expression evaluates the third operand, but not the second operand.  The result is a value of the type of the evaluated operand. "),(0,r.kt)("p",null,"The conditional expression provides a simple method of avoiding multiple returns:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int sign(int x)\n{\n    return x < 0 ? -1 : 1;\n}\n")),(0,r.kt)("p",null,"If the second or third operands are not primary expressions, the compiler introduces run-time code to evaluate them based upon the truth value of the leftmost operand.  Some compilers require that the second and third operands be of compatible type. "),(0,r.kt)("p",null,"Since the conditional operator has low precedence, using it within another expression usually requires enclosure within parentheses."))}u.isMDXComponent=!0},5888:function(e,t,n){t.Z=n.p+"assets/images/expressions-c5e9ed5288bc895ce1fea799ccd8bbad.svg"},579:function(e,t){t.Z="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCEtLSBEbyBub3QgZWRpdCB0aGlzIGZpbGUgd2l0aCBlZGl0b3JzIG90aGVyIHRoYW4gZGlhZ3JhbXMubmV0IC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZlcnNpb249IjEuMSIgd2lkdGg9IjQ0MXB4IiBoZWlnaHQ9IjI0MXB4IiB2aWV3Qm94PSItMC41IC0wLjUgNDQxIDI0MSI+PGRlZnMvPjxnPjxyZWN0IHg9IjAiIHk9IjIxMCIgd2lkdGg9IjEyMCIgaGVpZ2h0PSIzMCIgZmlsbD0iIzAwNTBlZiIgc3Ryb2tlPSIjMDAxZGJjIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTAuNSAtMC41KSI+PHN3aXRjaD48Zm9yZWlnbk9iamVjdCBwb2ludGVyLWV2ZW50cz0ibm9uZSIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5IiBzdHlsZT0ib3ZlcmZsb3c6IHZpc2libGU7IHRleHQtYWxpZ246IGxlZnQ7Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IHVuc2FmZSBjZW50ZXI7IGp1c3RpZnktY29udGVudDogdW5zYWZlIGNlbnRlcjsgd2lkdGg6IDExOHB4OyBoZWlnaHQ6IDFweDsgcGFkZGluZy10b3A6IDIyNXB4OyBtYXJnaW4tbGVmdDogMXB4OyI+PGRpdiBkYXRhLWRyYXdpby1jb2xvcnM9ImNvbG9yOiAjZmZmZmZmOyAiIHN0eWxlPSJib3gtc2l6aW5nOiBib3JkZXItYm94OyBmb250LXNpemU6IDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDIwcHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiByZ2IoMjU1LCAyNTUsIDI1NSk7IGxpbmUtaGVpZ2h0OiAxLjI7IHBvaW50ZXItZXZlbnRzOiBhbGw7IHdoaXRlLXNwYWNlOiBub3JtYWw7IG92ZXJmbG93LXdyYXA6IG5vcm1hbDsiPmx2YWx1ZTwvZGl2PjwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48dGV4dCB4PSI2MCIgeT0iMjMxIiBmaWxsPSIjZmZmZmZmIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjIwcHgiIHRleHQtYW5jaG9yPSJtaWRkbGUiPmx2YWx1ZTwvdGV4dD48L3N3aXRjaD48L2c+PHJlY3QgeD0iODAiIHk9IjkwIiB3aWR0aD0iMTIwIiBoZWlnaHQ9IjMwIiBmaWxsPSIjNmQ4NzY0IiBzdHJva2U9IiMzYTU0MzEiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMC41IC0wLjUpIj48c3dpdGNoPjxmb3JlaWduT2JqZWN0IHBvaW50ZXItZXZlbnRzPSJub25lIiB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiIHN0eWxlPSJvdmVyZmxvdzogdmlzaWJsZTsgdGV4dC1hbGlnbjogbGVmdDsiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogdW5zYWZlIGNlbnRlcjsganVzdGlmeS1jb250ZW50OiB1bnNhZmUgY2VudGVyOyB3aWR0aDogMTE4cHg7IGhlaWdodDogMXB4OyBwYWRkaW5nLXRvcDogMTA1cHg7IG1hcmdpbi1sZWZ0OiA4MXB4OyI+PGRpdiBkYXRhLWRyYXdpby1jb2xvcnM9ImNvbG9yOiAjZmZmZmZmOyAiIHN0eWxlPSJib3gtc2l6aW5nOiBib3JkZXItYm94OyBmb250LXNpemU6IDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDIwcHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiByZ2IoMjU1LCAyNTUsIDI1NSk7IGxpbmUtaGVpZ2h0OiAxLjI7IHBvaW50ZXItZXZlbnRzOiBhbGw7IHdoaXRlLXNwYWNlOiBub3JtYWw7IG92ZXJmbG93LXdyYXA6IG5vcm1hbDsiPjxzcGFuIHN0eWxlPSIiPmdsdmFsdWU8L3NwYW4+PC9kaXY+PC9kaXY+PC9kaXY+PC9mb3JlaWduT2JqZWN0Pjx0ZXh0IHg9IjE0MCIgeT0iMTExIiBmaWxsPSIjZmZmZmZmIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjIwcHgiIHRleHQtYW5jaG9yPSJtaWRkbGUiPmdsdmFsdWU8L3RleHQ+PC9zd2l0Y2g+PC9nPjxyZWN0IHg9IjE2MCIgeT0iMCIgd2lkdGg9IjEyMCIgaGVpZ2h0PSIzMCIgZmlsbD0iI2EyMDAyNSIgc3Ryb2tlPSIjNmYwMDAwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTAuNSAtMC41KSI+PHN3aXRjaD48Zm9yZWlnbk9iamVjdCBwb2ludGVyLWV2ZW50cz0ibm9uZSIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5IiBzdHlsZT0ib3ZlcmZsb3c6IHZpc2libGU7IHRleHQtYWxpZ246IGxlZnQ7Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IHVuc2FmZSBjZW50ZXI7IGp1c3RpZnktY29udGVudDogdW5zYWZlIGNlbnRlcjsgd2lkdGg6IDExOHB4OyBoZWlnaHQ6IDFweDsgcGFkZGluZy10b3A6IDE1cHg7IG1hcmdpbi1sZWZ0OiAxNjFweDsiPjxkaXYgZGF0YS1kcmF3aW8tY29sb3JzPSJjb2xvcjogI2ZmZmZmZjsgIiBzdHlsZT0iYm94LXNpemluZzogYm9yZGVyLWJveDsgZm9udC1zaXplOiAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IGlubGluZS1ibG9jazsgZm9udC1zaXplOiAyMHB4OyBmb250LWZhbWlseTogSGVsdmV0aWNhOyBjb2xvcjogcmdiKDI1NSwgMjU1LCAyNTUpOyBsaW5lLWhlaWdodDogMS4yOyBwb2ludGVyLWV2ZW50czogYWxsOyB3aGl0ZS1zcGFjZTogbm9ybWFsOyBvdmVyZmxvdy13cmFwOiBub3JtYWw7Ij5FeHByZXNzaW9uPC9kaXY+PC9kaXY+PC9kaXY+PC9mb3JlaWduT2JqZWN0Pjx0ZXh0IHg9IjIyMCIgeT0iMjEiIGZpbGw9IiNmZmZmZmYiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMjBweCIgdGV4dC1hbmNob3I9Im1pZGRsZSI+RXhwcmVzc2lvbjwvdGV4dD48L3N3aXRjaD48L2c+PHBhdGggZD0iTSAyMjAgMzAgTCAxNDUuMDkgODYuMTgiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc3NyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0ic3Ryb2tlIi8+PHBhdGggZD0iTSAxNDAuODkgODkuMzMgTCAxNDQuMzkgODIuMzMgTCAxNDUuMDkgODYuMTggTCAxNDguNTkgODcuOTMgWiIgZmlsbD0iIzc3NyIgc3Ryb2tlPSIjNzc3IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48cmVjdCB4PSIyNDAiIHk9IjkwIiB3aWR0aD0iMTIwIiBoZWlnaHQ9IjMwIiBmaWxsPSIjNmQ4NzY0IiBzdHJva2U9IiMzYTU0MzEiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMC41IC0wLjUpIj48c3dpdGNoPjxmb3JlaWduT2JqZWN0IHBvaW50ZXItZXZlbnRzPSJub25lIiB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiIHN0eWxlPSJvdmVyZmxvdzogdmlzaWJsZTsgdGV4dC1hbGlnbjogbGVmdDsiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogdW5zYWZlIGNlbnRlcjsganVzdGlmeS1jb250ZW50OiB1bnNhZmUgY2VudGVyOyB3aWR0aDogMTE4cHg7IGhlaWdodDogMXB4OyBwYWRkaW5nLXRvcDogMTA1cHg7IG1hcmdpbi1sZWZ0OiAyNDFweDsiPjxkaXYgZGF0YS1kcmF3aW8tY29sb3JzPSJjb2xvcjogI2ZmZmZmZjsgIiBzdHlsZT0iYm94LXNpemluZzogYm9yZGVyLWJveDsgZm9udC1zaXplOiAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IGlubGluZS1ibG9jazsgZm9udC1zaXplOiAyMHB4OyBmb250LWZhbWlseTogSGVsdmV0aWNhOyBjb2xvcjogcmdiKDI1NSwgMjU1LCAyNTUpOyBsaW5lLWhlaWdodDogMS4yOyBwb2ludGVyLWV2ZW50czogYWxsOyB3aGl0ZS1zcGFjZTogbm9ybWFsOyBvdmVyZmxvdy13cmFwOiBub3JtYWw7Ij48c3BhbiBzdHlsZT0iIj5ydmFsdWU8L3NwYW4+PC9kaXY+PC9kaXY+PC9kaXY+PC9mb3JlaWduT2JqZWN0Pjx0ZXh0IHg9IjMwMCIgeT0iMTExIiBmaWxsPSIjZmZmZmZmIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjIwcHgiIHRleHQtYW5jaG9yPSJtaWRkbGUiPnJ2YWx1ZTwvdGV4dD48L3N3aXRjaD48L2c+PHJlY3QgeD0iMTYwIiB5PSIyMTAiIHdpZHRoPSIxMjAiIGhlaWdodD0iMzAiIGZpbGw9IiMwMDUwZWYiIHN0cm9rZT0iIzAwMWRiYyIgcG9pbnRlci1ldmVudHM9ImFsbCIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0wLjUgLTAuNSkiPjxzd2l0Y2g+PGZvcmVpZ25PYmplY3QgcG9pbnRlci1ldmVudHM9Im5vbmUiIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIHJlcXVpcmVkRmVhdHVyZXM9Imh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjRXh0ZW5zaWJpbGl0eSIgc3R5bGU9Im92ZXJmbG93OiB2aXNpYmxlOyB0ZXh0LWFsaWduOiBsZWZ0OyI+PGRpdiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIgc3R5bGU9ImRpc3BsYXk6IGZsZXg7IGFsaWduLWl0ZW1zOiB1bnNhZmUgY2VudGVyOyBqdXN0aWZ5LWNvbnRlbnQ6IHVuc2FmZSBjZW50ZXI7IHdpZHRoOiAxMThweDsgaGVpZ2h0OiAxcHg7IHBhZGRpbmctdG9wOiAyMjVweDsgbWFyZ2luLWxlZnQ6IDE2MXB4OyI+PGRpdiBkYXRhLWRyYXdpby1jb2xvcnM9ImNvbG9yOiAjZmZmZmZmOyAiIHN0eWxlPSJib3gtc2l6aW5nOiBib3JkZXItYm94OyBmb250LXNpemU6IDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyI+PGRpdiBzdHlsZT0iZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6IDIwcHg7IGZvbnQtZmFtaWx5OiBIZWx2ZXRpY2E7IGNvbG9yOiByZ2IoMjU1LCAyNTUsIDI1NSk7IGxpbmUtaGVpZ2h0OiAxLjI7IHBvaW50ZXItZXZlbnRzOiBhbGw7IHdoaXRlLXNwYWNlOiBub3JtYWw7IG92ZXJmbG93LXdyYXA6IG5vcm1hbDsiPnh2YWx1ZTwvZGl2PjwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48dGV4dCB4PSIyMjAiIHk9IjIzMSIgZmlsbD0iI2ZmZmZmZiIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIyMHB4IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj54dmFsdWU8L3RleHQ+PC9zd2l0Y2g+PC9nPjxyZWN0IHg9IjMyMCIgeT0iMjEwIiB3aWR0aD0iMTIwIiBoZWlnaHQ9IjMwIiBmaWxsPSIjMDA1MGVmIiBzdHJva2U9IiMwMDFkYmMiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMC41IC0wLjUpIj48c3dpdGNoPjxmb3JlaWduT2JqZWN0IHBvaW50ZXItZXZlbnRzPSJub25lIiB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiIHN0eWxlPSJvdmVyZmxvdzogdmlzaWJsZTsgdGV4dC1hbGlnbjogbGVmdDsiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogdW5zYWZlIGNlbnRlcjsganVzdGlmeS1jb250ZW50OiB1bnNhZmUgY2VudGVyOyB3aWR0aDogMTE4cHg7IGhlaWdodDogMXB4OyBwYWRkaW5nLXRvcDogMjI1cHg7IG1hcmdpbi1sZWZ0OiAzMjFweDsiPjxkaXYgZGF0YS1kcmF3aW8tY29sb3JzPSJjb2xvcjogI2ZmZmZmZjsgIiBzdHlsZT0iYm94LXNpemluZzogYm9yZGVyLWJveDsgZm9udC1zaXplOiAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IGlubGluZS1ibG9jazsgZm9udC1zaXplOiAyMHB4OyBmb250LWZhbWlseTogSGVsdmV0aWNhOyBjb2xvcjogcmdiKDI1NSwgMjU1LCAyNTUpOyBsaW5lLWhlaWdodDogMS4yOyBwb2ludGVyLWV2ZW50czogYWxsOyB3aGl0ZS1zcGFjZTogbm9ybWFsOyBvdmVyZmxvdy13cmFwOiBub3JtYWw7Ij5wcnZhbHVlPC9kaXY+PC9kaXY+PC9kaXY+PC9mb3JlaWduT2JqZWN0Pjx0ZXh0IHg9IjM4MCIgeT0iMjMxIiBmaWxsPSIjZmZmZmZmIiBmb250LWZhbWlseT0iSGVsdmV0aWNhIiBmb250LXNpemU9IjIwcHgiIHRleHQtYW5jaG9yPSJtaWRkbGUiPnBydmFsdWU8L3RleHQ+PC9zd2l0Y2g+PC9nPjxwYXRoIGQ9Ik0gMjIwIDMwIEwgMjk0LjkxIDg2LjE4IiBmaWxsPSJub25lIiBzdHJva2U9IiM3NzciIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gMjk5LjExIDg5LjMzIEwgMjkxLjQxIDg3LjkzIEwgMjk0LjkxIDg2LjE4IEwgMjk1LjYxIDgyLjMzIFoiIGZpbGw9IiM3NzciIHN0cm9rZT0iIzc3NyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PHBhdGggZD0iTSAxNDAgMTIwIEwgNjQuMjMgMjA1LjI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM3NzciIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gNjAuNzQgMjA5LjE2IEwgNjIuNzggMjAxLjYxIEwgNjQuMjMgMjA1LjI0IEwgNjguMDEgMjA2LjI2IFoiIGZpbGw9IiM3NzciIHN0cm9rZT0iIzc3NyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PHBhdGggZD0iTSAzMDAgMTIwIEwgMjI0LjIzIDIwNS4yNCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNzc3IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiLz48cGF0aCBkPSJNIDIyMC43NCAyMDkuMTYgTCAyMjIuNzggMjAxLjYxIEwgMjI0LjIzIDIwNS4yNCBMIDIyOC4wMSAyMDYuMjYgWiIgZmlsbD0iIzc3NyIgc3Ryb2tlPSIjNzc3IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48cGF0aCBkPSJNIDE0MCAxMjAgTCAyMTUuNzcgMjA1LjI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM3NzciIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9InN0cm9rZSIvPjxwYXRoIGQ9Ik0gMjE5LjI2IDIwOS4xNiBMIDIxMS45OSAyMDYuMjYgTCAyMTUuNzcgMjA1LjI0IEwgMjE3LjIyIDIwMS42MSBaIiBmaWxsPSIjNzc3IiBzdHJva2U9IiM3NzciIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgcG9pbnRlci1ldmVudHM9ImFsbCIvPjxwYXRoIGQ9Ik0gMzAwIDEyMCBMIDM3NS43NyAyMDUuMjQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzc3NyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0ic3Ryb2tlIi8+PHBhdGggZD0iTSAzNzkuMjYgMjA5LjE2IEwgMzcxLjk5IDIwNi4yNiBMIDM3NS43NyAyMDUuMjQgTCAzNzcuMjIgMjAxLjYxIFoiIGZpbGw9IiM3NzciIHN0cm9rZT0iIzc3NyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PC9nPjxzd2l0Y2g+PGcgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5Ii8+PGEgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwtNSkiIHhsaW5rOmhyZWY9Imh0dHBzOi8vd3d3LmRpYWdyYW1zLm5ldC9kb2MvZmFxL3N2Zy1leHBvcnQtdGV4dC1wcm9ibGVtcyIgdGFyZ2V0PSJfYmxhbmsiPjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTBweCIgeD0iNTAlIiB5PSIxMDAlIj5UZXh0IGlzIG5vdCBTVkcgLSBjYW5ub3QgZGlzcGxheTwvdGV4dD48L2E+PC9zd2l0Y2g+PC9zdmc+"}}]);