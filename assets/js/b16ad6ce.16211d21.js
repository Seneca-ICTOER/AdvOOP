"use strict";(self.webpackChunkoop345=self.webpackChunkoop345||[]).push([[432],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=p(n),u=a,k=m["".concat(s,".").concat(u)]||m[u]||c[u]||r;return n?i.createElement(k,l(l({ref:t},d),{},{components:n})):i.createElement(k,l({ref:t},d))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6159:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return d},default:function(){return m}});var i=n(7462),a=n(3366),r=(n(7294),n(3905)),l=["components"],o={id:"standard-library",title:"Standard Library",sidebar_position:1,description:"TBD"},s="Introduction to the Standard Library",p={unversionedId:"E-STL/standard-library",id:"E-STL/standard-library",isDocsHomePage:!1,title:"Standard Library",description:"TBD",source:"@site/docs/E-STL/standard-library.md",sourceDirName:"E-STL",slug:"/E-STL/standard-library",permalink:"/E-STL/standard-library",editUrl:"https://github.com/Seneca-ICTOER/AdvOOP/tree/main/docs/E-STL/standard-library.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"standard-library",title:"Standard Library",sidebar_position:1,description:"TBD"},sidebar:"courseNotesSidebar",previous:{title:"Error Handling",permalink:"/D-Processing/error-handling"},next:{title:"Containers and Iterations",permalink:"/E-STL/containers-and-iterations"}},d=[{value:"Categories of the Standard Library",id:"categories-of-the-standard-library",children:[],level:2},{value:"String Library",id:"string-library",children:[{value:"String Classes",id:"string-classes",children:[],level:3},{value:"String View Module",id:"string-view-module",children:[],level:3}],level:2},{value:"Standard Template Library",id:"standard-template-library",children:[],level:2},{value:"Recent Facilities",id:"recent-facilities",children:[{value:"C++11 Facilities",id:"c11-facilities",children:[{value:"lvalue and rvalue Distinction",id:"lvalue-and-rvalue-distinction",children:[],level:4}],level:3},{value:"C++17 Facilities",id:"c17-facilities",children:[{value:"Type-Safe Unions",id:"type-safe-unions",children:[],level:4}],level:3}],level:2},{value:"Exercises",id:"exercises",children:[],level:2}],c={toc:d};function m(e){var t=e.components,o=(0,a.Z)(e,l);return(0,r.kt)("wrapper",(0,i.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"introduction-to-the-standard-library"},"Introduction to the Standard Library"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Review standard library facilities and introduce some new facilities"),(0,r.kt)("li",{parentName:"ul"},"Provide an overview of the Standard Template Library")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},'"The Standard Template Library provides a set of well-structured generic components that work together in a seamless way" Stepanov and Lee (1995)')),(0,r.kt)("p",null,"An object-oriented programming language like C++ relies significantly on libraries that support its non-library core. These libraries implement programming solutions for much of the repetitive detail encountered in the development of modern applications. The libraries that support the C++ language core include a broad variety of types, a framework of containers and algorithms for all user-defined types, and support for resource management and multi-threading. Two-thirds of the C++17 standard is devoted to detailed descriptions of library support facilities."),(0,r.kt)("p",null,"This chapter introduces the categories of the C++ standard library and summarizes their contents. It includes overviews of the string library, facilities added to the Standard Libraries with C++11 and the framework of containers and algorithms for user-defined types called the Standard Template Library. The chapter entitled ",(0,r.kt)("a",{parentName:"p",href:"/H-Deeper-Detail/linked-list-technology"},"Introduction to Linked Lists")," describes the technology that underlies some of the containers."),(0,r.kt)("h2",{id:"categories-of-the-standard-library"},"Categories of the Standard Library"),(0,r.kt)("p",null,"The categories of the C++ standard library are listed below. The header files for the components of these categories are listed alongside. Examples of facilities referred to in these notes are listed below each entry. The categories and components that are not covered in these notes are marked 'beyond scope':"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"language support (functions and types of objects generated implicitly)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"common definitions ",(0,r.kt)("inlineCode",{parentName:"li"},"<cstddef>")," ",(0,r.kt)("inlineCode",{parentName:"li"},"<cstdlib>"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"size_t ptrdiff_t")))),(0,r.kt)("li",{parentName:"ul"},"start and termination ",(0,r.kt)("inlineCode",{parentName:"li"},"<cstdlib>"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"atoi()")," ",(0,r.kt)("inlineCode",{parentName:"li"},"abort()")," ",(0,r.kt)("inlineCode",{parentName:"li"},"atexit()")," ",(0,r.kt)("inlineCode",{parentName:"li"},"exit()")))),(0,r.kt)("li",{parentName:"ul"},"dynamic memory ",(0,r.kt)("inlineCode",{parentName:"li"},"<new>"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"new")," ",(0,r.kt)("inlineCode",{parentName:"li"},"new[]")," ",(0,r.kt)("inlineCode",{parentName:"li"},"delete")," ",(0,r.kt)("inlineCode",{parentName:"li"},"delete[]")," ",(0,r.kt)("inlineCode",{parentName:"li"},"bad_alloc")))),(0,r.kt)("li",{parentName:"ul"},"dynamic type identification ",(0,r.kt)("inlineCode",{parentName:"li"},"<typeinfo>"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"type_info")))),(0,r.kt)("li",{parentName:"ul"},"exception handling ",(0,r.kt)("inlineCode",{parentName:"li"},"<exception>"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bad_exception")," ",(0,r.kt)("inlineCode",{parentName:"li"},"terminate()")))),(0,r.kt)("li",{parentName:"ul"},"implementation properties (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<limits>")," ",(0,r.kt)("inlineCode",{parentName:"li"},"<climits>")," ",(0,r.kt)("inlineCode",{parentName:"li"},"<cfloat>")),(0,r.kt)("li",{parentName:"ul"},"integer types (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<cstdint>")),(0,r.kt)("li",{parentName:"ul"},"initializer lists (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<initializer_list>")),(0,r.kt)("li",{parentName:"ul"},"other run-time support (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<csignal>")," ",(0,r.kt)("inlineCode",{parentName:"li"},"<csetjmp>")," ",(0,r.kt)("inlineCode",{parentName:"li"},"<cstdalign>")," ",(0,r.kt)("inlineCode",{parentName:"li"},"<cstdarg>")," ",(0,r.kt)("inlineCode",{parentName:"li"},"<cstdbool>")," ",(0,r.kt)("inlineCode",{parentName:"li"},"<cstdlib>")))),(0,r.kt)("li",{parentName:"ul"},"diagnostics (for detecting and reporting error conditions)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"exception classes (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<stdexcept>")),(0,r.kt)("li",{parentName:"ul"},"assertions (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<cassert>")),(0,r.kt)("li",{parentName:"ul"},"error numbers (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<cerrno>")),(0,r.kt)("li",{parentName:"ul"},"system error support (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<system_error>")))),(0,r.kt)("li",{parentName:"ul"},"general utilities (generally useful)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"components ",(0,r.kt)("inlineCode",{parentName:"li"},"<utility>")," - utilities, integer sequences, pairs",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"move()")))),(0,r.kt)("li",{parentName:"ul"},"optional objects (see below) ",(0,r.kt)("inlineCode",{parentName:"li"},"<optional>")," - may contain a value"),(0,r.kt)("li",{parentName:"ul"},"variants (see below) ",(0,r.kt)("inlineCode",{parentName:"li"},"<variant>")," - type-safe union"),(0,r.kt)("li",{parentName:"ul"},"storage for any type ",(0,r.kt)("inlineCode",{parentName:"li"},"<any>")),(0,r.kt)("li",{parentName:"ul"},"smart pointers (see later chapter) ",(0,r.kt)("inlineCode",{parentName:"li"},"<memory>")),(0,r.kt)("li",{parentName:"ul"},"function objects (see later chapter) ",(0,r.kt)("inlineCode",{parentName:"li"},"<functional>"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ref()")))),(0,r.kt)("li",{parentName:"ul"},"time (see later chapter) ",(0,r.kt)("inlineCode",{parentName:"li"},"<chrono>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<ctime>")))),(0,r.kt)("li",{parentName:"ul"},"strings (for manipulating sequences of char-like types)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"character traits (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<string>")),(0,r.kt)("li",{parentName:"ul"},"string classes (see below) ",(0,r.kt)("inlineCode",{parentName:"li"},"<string>")),(0,r.kt)("li",{parentName:"ul"},"string view classes (see below) ",(0,r.kt)("inlineCode",{parentName:"li"},"<string_view>")),(0,r.kt)("li",{parentName:"ul"},"null-terminated sequence utilities ",(0,r.kt)("inlineCode",{parentName:"li"},"<cctype>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<cwctype>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<cstring>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<cwchar>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<cstdlib>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<cuchar>")," - part of the C library"))),(0,r.kt)("li",{parentName:"ul"},"localization (for encapsulating cultural differences)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"locales (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<locale>")," - international support for text processing"),(0,r.kt)("li",{parentName:"ul"},"code conversion facets (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<codecvt>")," - Unicode localization utilities"),(0,r.kt)("li",{parentName:"ul"},"C locales (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<clocale>")," - C library international support for text processing"))),(0,r.kt)("li",{parentName:"ul"},"containers (see below) ",(0,r.kt)("inlineCode",{parentName:"li"},"<array>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<vector>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<list>"),", ... - part of the STL framework"),(0,r.kt)("li",{parentName:"ul"},"iterators (see below) ",(0,r.kt)("inlineCode",{parentName:"li"},"<iterator>")," - part of the STL framework"),(0,r.kt)("li",{parentName:"ul"},"algorithms (see below) ",(0,r.kt)("inlineCode",{parentName:"li"},"<algorithms>")," - part of the STL framework"),(0,r.kt)("li",{parentName:"ul"},"numerics (for seminumerical operations)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"floating-point environment (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<cfenv>")),(0,r.kt)("li",{parentName:"ul"},"complex numbers (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<complex>")),(0,r.kt)("li",{parentName:"ul"},"random number generation (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<random>")),(0,r.kt)("li",{parentName:"ul"},"numeric arrays (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<valarray>")," - class for representing and manipulating arrays of values"),(0,r.kt)("li",{parentName:"ul"},"generalized numeric operations (see later chapter) ",(0,r.kt)("inlineCode",{parentName:"li"},"<numerics>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<numeric>")," ",(0,r.kt)("inlineCode",{parentName:"li"},"<cmath>")," - numeric operations on values in containers"),(0,r.kt)("li",{parentName:"ul"},"mathematical functions ",(0,r.kt)("inlineCode",{parentName:"li"},"<cmath>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<ctgmath>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<cstdlib>")," - common math operations"))),(0,r.kt)("li",{parentName:"ul"},"input/output (for input and output operations)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"standard ",(0,r.kt)("inlineCode",{parentName:"li"},"iostream")," objects (see later chapter) ",(0,r.kt)("inlineCode",{parentName:"li"},"<iostream>")," - primary mechanism for input and output"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"iostream")," base classes (see later chapter) ",(0,r.kt)("inlineCode",{parentName:"li"},"<ios>")," - underlying support for input and output"),(0,r.kt)("li",{parentName:"ul"},"formatting and manipulation (see later chapter) ",(0,r.kt)("inlineCode",{parentName:"li"},"<istream>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<ostream>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<iomanip>")," - helper functions"),(0,r.kt)("li",{parentName:"ul"},"string streams (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<sstream>")),(0,r.kt)("li",{parentName:"ul"},"file streams (see later chapter) ",(0,r.kt)("inlineCode",{parentName:"li"},"<fstream>")),(0,r.kt)("li",{parentName:"ul"},"file systems (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<filesystem>")),(0,r.kt)("li",{parentName:"ul"},"C input and output (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<cstdio>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<cinttypes>")," - primary C mechanism for input and output"))),(0,r.kt)("li",{parentName:"ul"},"regular expressions (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<regex>")," - matching and searching facilities"),(0,r.kt)("li",{parentName:"ul"},"atomic operations (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<atomic>")," - concurrent access to shared data"),(0,r.kt)("li",{parentName:"ul"},"thread support (for multi-threading support)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"threads (see later chapter) ",(0,r.kt)("inlineCode",{parentName:"li"},"<thread>")," - manages threads and inter-thread communications"),(0,r.kt)("li",{parentName:"ul"},"mutual exclusion (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<mutex>"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"<shared_mutex>")),(0,r.kt)("li",{parentName:"ul"},"condition variables (beyond scope) ",(0,r.kt)("inlineCode",{parentName:"li"},"<condition_variable>")),(0,r.kt)("li",{parentName:"ul"},"futures (see later chapter) ",(0,r.kt)("inlineCode",{parentName:"li"},"<future>")," - manages threads and inter-thread communications")))),(0,r.kt)("p",null,"Most library components are declared and defined in the ",(0,r.kt)("inlineCode",{parentName:"p"},"std")," namespace. The filesystem component is declared and defined in the ",(0,r.kt)("inlineCode",{parentName:"p"},"filesystem")," namespace. The library macros are predefined in the global namespace."),(0,r.kt)("p",null,"The C++ Standard Library makes available the facilities of the C Standard Library. A review of the input/output features is in the appendices entitled ",(0,r.kt)("a",{parentName:"p",href:"/Resources-Appendices/c-libraries"},"The C Libraries")," and ",(0,r.kt)("a",{parentName:"p",href:"/Resources-Appendices/c-and-cpp"},"How C++ and C Fit Together"),"."),(0,r.kt)("h2",{id:"string-library"},"String Library"),(0,r.kt)("p",null,"The String Library provides support for three general types of strings:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("inlineCode",{parentName:"li"},"string")," classes"),(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("inlineCode",{parentName:"li"},"string_view")," classes"),(0,r.kt)("li",{parentName:"ul"},"null terminated C-style string functions")),(0,r.kt)("h3",{id:"string-classes"},"String Classes"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," classes store and manipulate sequences of character-like objects. The specializations of the ",(0,r.kt)("inlineCode",{parentName:"p"},"<std::basic_string<CharT>>")," template for specific character types are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::string <std::basic_string<char>>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::wstring <std::basic_string<wchar_t>>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::u16string <std::basic_string<char16_t>>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::u32string <std::basic_string<char32_t>>"))),(0,r.kt)("p",null,"The public member functions include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"operator=")," - assigns a string to the current string"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"operator[]")," - accesses a specified character in the string"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"size()")," - the number of characters in the string"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"substr()")," - returns a substring of the string"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"find(char c)")," - find the first occurrence of ",(0,r.kt)("inlineCode",{parentName:"li"},"c")," in the string"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"rfind(char c)")," - find the last occurrence of ",(0,r.kt)("inlineCode",{parentName:"li"},"c")," in the string"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"find_first_of(char c)")," - find the first occurrence of ",(0,r.kt)("inlineCode",{parentName:"li"},"c")," in the string"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"find_last_of(char c)")," - find the last occurrence of ",(0,r.kt)("inlineCode",{parentName:"li"},"c")," in the string"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"find_first_of(basic_string_view(const CharT* s))")," - find the first occurrence of any character in the sequence ",(0,r.kt)("inlineCode",{parentName:"li"},"s")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"find_last_of(basic_string_view(const CharT* s))")," - find the last occurrence of any character in the sequence ",(0,r.kt)("inlineCode",{parentName:"li"},"s")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"operator+=")," - append a character or a string to the current string")),(0,r.kt)("p",null,"The helper functions include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"operator==")," - equality comparison"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"operator!=")," - inequality comparison"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"operator>>")," - extract the string from the input stream"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"operator<<")," - insert the string into the output stream")),(0,r.kt)("p",null,"Unlike the ",(0,r.kt)("inlineCode",{parentName:"p"},"const char*")," type (a pointer to a C-style null-terminated string), a string type keeps track of the number of characters in the string through an instance variable without using the null byte as a terminator. A string object can include one or more null byte (",(0,r.kt)("inlineCode",{parentName:"p"},"'\\0'"),") characters."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// String Class\n// string.cpp\n\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string str("Hello");\n    str += \'\\0\'; // adds a null byte\n    str += " World"; // adds a string\n\n    int i = 0;\n\n    for (const auto& c : str)\n        if (str[i++] == \'\\0\')\n            std::cout << "Null byte at str[" << i-1 << "]\\n";\n\n    std::cout << str << std::endl;\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Null byte at str[5]\nHello World\n")),(0,r.kt)("h3",{id:"string-view-module"},"String View Module"),(0,r.kt)("p",null,"C++17 introduced the ",(0,r.kt)("inlineCode",{parentName:"p"},"<string_view>")," library to augment the ",(0,r.kt)("inlineCode",{parentName:"p"},"std::string")," class and avoid redundant copying operations. The class template ",(0,r.kt)("inlineCode",{parentName:"p"},"std::basic_string_view")," defines a lightweight non-owning, read-only view into a contiguous sequence of characters with the first element at position zero."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"string_view")," classes refer to sequences of character-like objects. The specializations of the ",(0,r.kt)("inlineCode",{parentName:"p"},"<std::basic_string_view<CharT>>")," template are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::string_view <std::basic_string<char>>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::wstring_view <std::basic_string<wchar_t>>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::u16string_view <std::basic_string<char16_t>>")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::u32string_view <std::basic_string<char32_t>>"))),(0,r.kt)("p",null,"The public member functions include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"operator=")," - assign one view to another"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"operator[]")," - access an element in a view"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"size()")," - the number of characters in the view"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"substr()")," - a substring of the view"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"find(char c)")," - find the first occurrence of ",(0,r.kt)("inlineCode",{parentName:"li"},"c")," in the view"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"find_first_of(char c)")," - find the first occurrence of ",(0,r.kt)("inlineCode",{parentName:"li"},"c")," in the view"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"find_last_of(char c)")," - find the last occurrence of ",(0,r.kt)("inlineCode",{parentName:"li"},"c")," in the view"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"find_first_of(basic_string_view(const char* s))")," - find the first occurrence of any character in the sequence ",(0,r.kt)("inlineCode",{parentName:"li"},"s")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"find_last_of(basic_string_view(const char* s))")," - find the last occurrence of any character in the sequence ",(0,r.kt)("inlineCode",{parentName:"li"},"s"))),(0,r.kt)("p",null,"The helper functions include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"operator==")," - equality comparison"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"operator!=")," - inequality comparison"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"operator<<")," - insert into output stream")),(0,r.kt)("p",null,"Like a ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," object, a ",(0,r.kt)("inlineCode",{parentName:"p"},"string_view")," object can include the null byte (",(0,r.kt)("inlineCode",{parentName:"p"},"'\\0'"),") or several null bytes as a non-terminating character. Both achieve this by storing the number of characters in the string as an instance variable."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// String View Class\n// string_view.cpp\n\n#include <iostream>\n#include <string>\n#include <string_view>\n\nint main()\n{\n    std::string str("Hello");\n    str += \'\\0\'; // adds a null byte\n    str += " World"; // adds a string\n\n    int i = 0;\n\n    std::string_view str_view(str);\n\n    for (const auto& c : str_view)\n        if (str_view[i++] == \'\\0\')\n            std::cout << "Null byte at str_view[" << i-1 << "]\\n";\n\n    std::cout << str_view << std::endl;\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Null byte at str_view[5]\nHello World\n")),(0,r.kt)("p",null,"Since a ",(0,r.kt)("inlineCode",{parentName:"p"},"string_view")," object does not own the characters to which it points, it is the programmer's responsibility to ensure that the object does not outlive the pointed-to character array."),(0,r.kt)("h2",{id:"standard-template-library"},"Standard Template Library"),(0,r.kt)("p",null,"The Standard Template Library (STL) is arguably the most prominent part of the C++ Standard Library. It provides code for managing the elements of a data structure in a generic form, hiding the complex details and allowing re-use. The STL consists of:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"container template classes",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"sequential containers"),(0,r.kt)("li",{parentName:"ul"},"container adapters"),(0,r.kt)("li",{parentName:"ul"},"associative containers (beyond scope)"))),(0,r.kt)("li",{parentName:"ul"},"iterators"),(0,r.kt)("li",{parentName:"ul"},"algorithms"),(0,r.kt)("li",{parentName:"ul"},"function objects")),(0,r.kt)("p",null,"A container class represents the shell of a data structure, manages the memory associated with the elements of that structure and provides member functions to access those elements. Iterators facilitate the traversal of the data structure and provide simple access to range of elements. Algorithms implement solutions for sequences of elements through the use of iterators and function objects."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Standard Template Library",src:n(5384).Z})),(0,r.kt)("p",null,"A complete programming solution to the implementation of a data structure requires:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the definition of the data type of each element in the data structure"),(0,r.kt)("li",{parentName:"ul"},"the choice of the optimal data structure to collect the elements"),(0,r.kt)("li",{parentName:"ul"},"the function object for the algorithm to use on the data structure"),(0,r.kt)("li",{parentName:"ul"},"syntax to accesses the facilities of the STL")),(0,r.kt)("p",null,"This technology is covered in detail in the following two chapters. Parallel versions of the STL algorithms are covered in the chapter entitled ",(0,r.kt)("a",{parentName:"p",href:"/G-Performance/multithreading"},"Multi-Threading"),"."),(0,r.kt)("h2",{id:"recent-facilities"},"Recent Facilities"),(0,r.kt)("h3",{id:"c11-facilities"},"C++11 Facilities"),(0,r.kt)("h4",{id:"lvalue-and-rvalue-distinction"},"lvalue and rvalue Distinction"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::ref()")," (",(0,r.kt)("inlineCode",{parentName:"li"},"<functional>"),") - returns an lvalue reference to its argument"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::move()")," (",(0,r.kt)("inlineCode",{parentName:"li"},"<utility>"),") - returns an rvalue reference to its argument")),(0,r.kt)("h3",{id:"c17-facilities"},"C++17 Facilities"),(0,r.kt)("p",null,"C++17 introduced new library facilities. They include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::string_view")," (",(0,r.kt)("inlineCode",{parentName:"li"},"<string_view>"),") - a read-only contiguous sequence of characters (see above)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::variant<T, ...>()")," (",(0,r.kt)("inlineCode",{parentName:"li"},"<variant>"),") - represents a type-safe union"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::optional<T>")," (",(0,r.kt)("inlineCode",{parentName:"li"},"<optional>"),") - may or may not contain a value (beyond scope)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::any")," (",(0,r.kt)("inlineCode",{parentName:"li"},"<any>"),") - single values of any type (beyond scope)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::uncaught_exceptions")," (",(0,r.kt)("inlineCode",{parentName:"li"},"<exception>"),") - stack is in the process of unwinding"),(0,r.kt)("li",{parentName:"ul"},"Uniform container access ",(0,r.kt)("inlineCode",{parentName:"li"},"std::size")," ",(0,r.kt)("inlineCode",{parentName:"li"},"std::empty")," ",(0,r.kt)("inlineCode",{parentName:"li"},"std::data")," - number of elements, emptiness, direct access to underlying array"),(0,r.kt)("li",{parentName:"ul"},"Special Mathematical Functions (",(0,r.kt)("inlineCode",{parentName:"li"},"<numerics>"),") - (beyond scope)"),(0,r.kt)("li",{parentName:"ul"},"Filesystem Library ",(0,r.kt)("inlineCode",{parentName:"li"},"filesystem")," (",(0,r.kt)("inlineCode",{parentName:"li"},"<filesystem>"),") - facilities for performing operations on file systems and their components including paths, regular files and directories (beyond scope)")),(0,r.kt)("h4",{id:"type-safe-unions"},"Type-Safe Unions"),(0,r.kt)("p",null,"The class template ",(0,r.kt)("inlineCode",{parentName:"p"},"std::variant<T, ...>")," represents a type-safe union. The parameter list specifies the types that may be stored in the union. A type may be repeated. The value of the variant can be accessed using either its type, if unique, or its index."),(0,r.kt)("p",null,"The public member functions include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"operator=(v)")," - assigns value of variant ",(0,r.kt)("inlineCode",{parentName:"li"},"v")," to the left operand"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"index()")," - returns the index I of the variant stored in the current object")),(0,r.kt)("p",null,"The helper functions include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::get<T>(v)")," - returns value of variant ",(0,r.kt)("inlineCode",{parentName:"li"},"v")," given the type ",(0,r.kt)("inlineCode",{parentName:"li"},"T")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::get<I>(v)")," - returns value of variant ",(0,r.kt)("inlineCode",{parentName:"li"},"v")," given the index ",(0,r.kt)("inlineCode",{parentName:"li"},"I"))),(0,r.kt)("p",null,"The helper classes include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"std::bad_variant_access")," - exception thrown on invalid access")),(0,r.kt)("p",null,"For example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// Variant - a type-safe union\n// variant.cpp\n\n#include <iostream>\n#include <variant>\n\nint main()\n{\n    std::variant<long, double> a, b;\n    a = 12l; // a contains a long\n    b = std::get<long>(a);\n    std::cout << b << std::endl;\n\n    try\n    {\n        double c = std::get<double>(b);\n        std::cout << c << std::endl;\n    }\n    catch(std::bad_variant_access& bva)\n    {\n        std::cout << "bad type access" << std::endl;\n    }\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"12\nbad type access\n")),(0,r.kt)("h2",{id:"exercises"},"Exercises"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Read Wikipedia on ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library"},"C++ Standard Library")),(0,r.kt)("li",{parentName:"ul"},"Read Wikipedia on ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Standard_Template_Library"},"C++ Standard Template Library"))))}m.isMDXComponent=!0},5384:function(e,t,n){t.Z=n.p+"assets/images/stl-0ffb9650ff3732ee9e63df830990335d.png"}}]);