"use strict";(self.webpackChunkoop345=self.webpackChunkoop345||[]).push([[373],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return u}});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},l=Object.keys(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var o=i.createContext({}),r=function(e){var n=i.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=r(e.components);return i.createElement(o.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},h=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,o=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),h=r(t),u=a,m=h["".concat(o,".").concat(u)]||h[u]||p[u]||l;return t?i.createElement(m,s(s({ref:n},d),{},{components:t})):i.createElement(m,s({ref:n},d))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,s=new Array(l);s[0]=h;var c={};for(var o in n)hasOwnProperty.call(n,o)&&(c[o]=n[o]);c.originalType=e,c.mdxType="string"==typeof e?e:a,s[1]=c;for(var r=2;r<l;r++)s[r]=t[r];return i.createElement.apply(null,s)}return i.createElement.apply(null,t)}h.displayName="MDXCreateElement"},4574:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return c},contentTitle:function(){return o},metadata:function(){return r},toc:function(){return d},default:function(){return h}});var i=t(7462),a=t(3366),l=(t(7294),t(3905)),s=["components"],c={id:"inheritance-and-inclusion-polymorphism",title:"Inheritance and Inclusion Polymorphism",sidebar_position:1,description:"TBD"},o="Inheritance and Inclusion Polymorphism",r={unversionedId:"C-Class-Relationships/inheritance-and-inclusion-polymorphism",id:"C-Class-Relationships/inheritance-and-inclusion-polymorphism",isDocsHomePage:!1,title:"Inheritance and Inclusion Polymorphism",description:"TBD",source:"@site/docs/C-Class-Relationships/inheritance-and-inclusion-polymorphism.md",sourceDirName:"C-Class-Relationships",slug:"/C-Class-Relationships/inheritance-and-inclusion-polymorphism",permalink:"/C-Class-Relationships/inheritance-and-inclusion-polymorphism",editUrl:"https://github.com/Seneca-ICTOER/AdvOOP/tree/main/docs/C-Class-Relationships/inheritance-and-inclusion-polymorphism.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"inheritance-and-inclusion-polymorphism",title:"Inheritance and Inclusion Polymorphism",sidebar_position:1,description:"TBD"},sidebar:"courseNotesSidebar",previous:{title:"Classes and Scoped Enumerations",permalink:"/B-Types/classes-and-scoped-enumerations"},next:{title:"Class Templates",permalink:"/C-Class-Relationships/class-templates"}},d=[{value:"Inheritance Basics",id:"inheritance-basics",children:[{value:"Abstract and Concrete Classes",id:"abstract-and-concrete-classes",children:[],level:3},{value:"Completing an Abstract Class",id:"completing-an-abstract-class",children:[],level:3},{value:"Application",id:"application",children:[{value:"Good Design Practice",id:"good-design-practice",children:[],level:4}],level:3}],level:2},{value:"Inclusion Polymorphism",id:"inclusion-polymorphism",children:[{value:"Polymorphic Objects",id:"polymorphic-objects",children:[],level:3},{value:"Copying Operations",id:"copying-operations",children:[],level:3},{value:"Specializing an Operation for a Dynamic Type (Optional for OOP345)",id:"specializing-an-operation-for-a-dynamic-type-optional-for-oop345",children:[],level:3},{value:"Dynamic Type Identification (Optional for OOP345)",id:"dynamic-type-identification-optional-for-oop345",children:[],level:3}],level:2},{value:"Liskov Substitution Principle",id:"liskov-substitution-principle",children:[{value:"The Correct Design",id:"the-correct-design",children:[{value:"The Initial Design",id:"the-initial-design",children:[],level:4},{value:"The Upgraded Design",id:"the-upgraded-design",children:[],level:4}],level:3},{value:"An Incorrect Design",id:"an-incorrect-design",children:[{value:"The Initial Design",id:"the-initial-design-1",children:[],level:4},{value:"The Upgraded Design",id:"the-upgraded-design-1",children:[],level:4},{value:"The Design is Still Flawed",id:"the-design-is-still-flawed",children:[],level:4}],level:3}],level:2},{value:"Exercises",id:"exercises",children:[],level:2}],p={toc:d};function h(e){var n=e.components,c=(0,a.Z)(e,s);return(0,l.kt)("wrapper",(0,i.Z)({},p,c,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"inheritance-and-inclusion-polymorphism"},"Inheritance and Inclusion Polymorphism"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Model generalization and specialization using inheritance hierarchies"),(0,l.kt)("li",{parentName:"ul"},"Model polymorphic behavior using interfaces and virtual functions")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},'"Abstract interfaces help you focus on getting an abstraction right without muddling it with implementation or state management details." Sutter, Alexandrescu (2005)')),(0,l.kt)("p",null,"The classes in an object-oriented program stand in a variety of relationships to one another. These relationships exhibit various degrees of coupling. Inheritance is the tightest possible relationship. The classes are highly coupled and part of a hierarchy that supports both abstraction and polymorphism. A derived class in an inheritance hierarchy includes the entire structure of its parent base class and defines only those additional features that specialize the base class. Over the life-cycle of a class hierarchy, programmers add more features that specialize the hierarchy further. This reuse of existing code simplifies the development process over the life cycle of the hierarchy. Such reuse improves substitutability incrementally and constructively. An abstract base class exposes to the program the structure common to all the classes in the hierarchy. The ",(0,l.kt)("strong",{parentName:"p"},"Liskov Substitution Principle")," ensures that the behaviors of the derived classes do not violate constraints on the base classes."),(0,l.kt)("p",null,"This chapter reviews single inheritance and the role of an abstract base class as the interface to an inheritance hierarchy. It also reviews inclusion polymorphism, which distinguishes the functionality of different classes in a hierarchy through type-specific virtual functions. This chapter concludes with a brief discussion of the substitution principle, which advocates proper design of inheritance hierarchies. Inheritance from several bases classes is covered in a later chapter entitled ",(0,l.kt)("a",{parentName:"p",href:"/H-Deeper-Detail/multiple-inheritance"},"Multiple Inheritance"),"."),(0,l.kt)("h2",{id:"inheritance-basics"},"Inheritance Basics"),(0,l.kt)("p",null,"Inheritance is a relationship between user-defined types. These types may be:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"concrete - their representation is part of their definition and is known"),(0,l.kt)("li",{parentName:"ul"},"abstract - their representation is not part of their definition and is unknown")),(0,l.kt)("h3",{id:"abstract-and-concrete-classes"},"Abstract and Concrete Classes"),(0,l.kt)("p",null,"An ",(0,l.kt)("em",{parentName:"p"},"abstract")," class can serve as an interface to an inheritance hierarchy. It is an incomplete class in the hierarchy. We cannot create an instance of an abstract class. We complete its implementation by deriving a new class that adds the missing definitions. We call the completed class a ",(0,l.kt)("em",{parentName:"p"},"concrete")," class."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Abstract and Concrete classes",src:t(3249).Z})),(0,l.kt)("p",null,"As an example of an abstract base class, consider the ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape")," class defined below. All that we know of a ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape")," is that it has a volume."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"// A Shape\n// Shape.h\n#ifndef SHAPE_H\n#define SHAPE_H\n\nclass Shape\n{\npublic:\n    virtual double volume() const = 0;\n};\n#endif\n")),(0,l.kt)("p",null,"The pre-processor guard (",(0,l.kt)("inlineCode",{parentName:"p"},"#ifndef")," ... ",(0,l.kt)("inlineCode",{parentName:"p"},"#endif"),") ensures that the definition of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape")," class occurs only once in a translation unit. Once ",(0,l.kt)("inlineCode",{parentName:"p"},"SHAPE_H")," has been defined, any include directive that specifies insertion of the class definition skips the definition. This implements the one-definition rule of C++."),(0,l.kt)("p",null,"This abstract class identifies the member function that the hierarchy exposes to its clients and guarantees to deliver. The signature of the pure virtual function declares the exposed member function uniquely. The assignment to 0 identifies the function as undefined or ",(0,l.kt)("em",{parentName:"p"},"pure"),"."),(0,l.kt)("h3",{id:"completing-an-abstract-class"},"Completing an Abstract Class"),(0,l.kt)("p",null,"To instantiate a ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape")," object, we need to define a function that returns its volume. We do so by deriving a concrete class from the abstract ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape")," class. The derived class contains the geometric properties needed to determine its volume. If the derived class includes the missing geometric properties needed to define the object's volume, we can create instances of that class."),(0,l.kt)("p",null,"Consider an inheritance hierarchy built around the ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape")," class that consists of two derived classes named ",(0,l.kt)("inlineCode",{parentName:"p"},"Cube")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Sphere"),". Each ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape")," has its own specific calculation of volume. Each classes constructor takes in the required geometric property."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Shape Hierarchy",src:t(6960).Z})),(0,l.kt)("p",null,"Each derived class - ",(0,l.kt)("inlineCode",{parentName:"p"},"Cube")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Sphere")," - defines its own ",(0,l.kt)("inlineCode",{parentName:"p"},"volume()")," query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// A Cube\n// Cube.h\n\n#include "Shape.h"\n\nclass Cube : public Shape\n{\n    double len;\npublic:\n    Cube(double);\n    double volume() const;\n};\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// A Sphere\n// Sphere.h\n\n#include "Shape.h"\n\nclass Sphere : public Shape\n{\n    double rad;\npublic:\n    Sphere(double);\n    double volume() const;\n};\n')),(0,l.kt)("p",null,"The implementation files - ",(0,l.kt)("inlineCode",{parentName:"p"},"Cube.cpp")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Sphere.cpp")," - define the volume calculation:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// A Cube\n// Cube.cpp\n\n#include "Cube.h"\n\nCube::Cube(double l) : len{l} {}\n\ndouble Cube::volume() const\n{\n    return len * len * len;\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// A Sphere\n// Sphere.cpp\n\n#include "Sphere.h"\n\nSphere::Sphere(double r) : rad{r} {}\n\ndouble Sphere::volume() const\n{\n    return 4.18879 * rad * rad * rad;\n}\n')),(0,l.kt)("h3",{id:"application"},"Application"),(0,l.kt)("p",null,"The following example calculates the volume of any ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape")," in the hierarchy. The user selects the type of ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape")," and enters its required dimension. The results for three separate runs are shown below:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Shape Hierarchy\n// Shape.cpp\n\n#include <iostream>\n#include "Cube.h"\n#include "Sphere.h"\n\nvoid displayVolume(const Shape* shape)\n{\n    if (shape)\n        std::cout << shape->volume() << std::endl;\n    else\n        std::err << "ERROR!" << std::endl;\n}\n\nShape* select()\n{\n    Shape* shape;\n    double x;\n    char c;\n    std::cout << "s (sphere), c (cube) : ";\n    std::cin >> c;\n    if (c == \'s\')\n    {\n        std::cout << "dimension : ";\n        std::cin >> x;\n        shape = new Sphere(x);\n    }\n    else if (c == \'c\')\n    {\n        std::cout << "dimension : ";\n        std::cin >> x;\n        shape = new Cube(x);\n    }\n    else\n        shape = nullptr;\n    return shape;\n}\n\nint main()\n{\n    Shape* shape = select();\n    displayVolume(shape);\n    delete shape;\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"First run :\n-----------\ns (sphere), c (cube) : s\ndimension : 1\n4.18879\n\nSecond run :\n------------\ns (sphere), c (cube) : c\ndimension : 2\n8\n\nThird run :\n-----------\ns (sphere), c (cube) : d\nERROR!\n")),(0,l.kt)("p",null,"Adding another derived class to the ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape")," hierarchy will only require an upgrade to the ",(0,l.kt)("inlineCode",{parentName:"p"},"select()")," function. The ",(0,l.kt)("inlineCode",{parentName:"p"},"displayVolume()")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"main()")," functions work with the interface directly and are sufficiently general not to require any upgrade."),(0,l.kt)("h4",{id:"good-design-practice"},"Good Design Practice"),(0,l.kt)("p",null,"Including the header files for the ",(0,l.kt)("inlineCode",{parentName:"p"},"Cube")," class and the ",(0,l.kt)("inlineCode",{parentName:"p"},"Sphere")," class in ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape.cpp")," would lead to a multiple definition of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape")," class if the pre-processor guard was omitted."),(0,l.kt)("p",null,"It is common design practice to wrap each header file in its own pre-processor guard."),(0,l.kt)("h2",{id:"inclusion-polymorphism"},"Inclusion Polymorphism"),(0,l.kt)("h3",{id:"polymorphic-objects"},"Polymorphic Objects"),(0,l.kt)("p",null,"A polymorphic object is an object that can have different dynamic types throughout its lifetime. Consider the function named ",(0,l.kt)("inlineCode",{parentName:"p"},"displayVolume()")," in the ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape.cpp")," example above:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'void displayVolume(const Shape* shape)\n{\n    if (shape)\n        std::cout << shape->volume() << std::endl;\n    else\n        std::err << "ERROR!" << std::endl;\n}\n')),(0,l.kt)("p",null,"The parameter ",(0,l.kt)("inlineCode",{parentName:"p"},"shape")," receives the address of a polymorphic object. In order to determine which of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape")," hierarchy's function definition to call in calculating the volume of the object, the function needs to know the dynamic type of the object to which the parameter points. (",(0,l.kt)("inlineCode",{parentName:"p"},"Shape")," is the static type.)"),(0,l.kt)("p",null,"C++ supplies the dynamic type to the function at run-time."),(0,l.kt)("p",null,"Questions that arise with dynamic typing include:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"how to determine the dynamic type in copying a polymorphic object to another polymorphic object"),(0,l.kt)("li",{parentName:"ul"},"how to specialize an operation for a dynamic type"),(0,l.kt)("li",{parentName:"ul"},"how to exclude a specific type from the default (most derived) selection of a function")),(0,l.kt)("h3",{id:"copying-operations"},"Copying Operations"),(0,l.kt)("p",null,"Copying a polymorphic object at run-time requires knowledge of its dynamic type. In order to allocate memory for the copy, the executable needs to know the dynamic type. For example, the following copy function needs to know which copy constructor to call - ",(0,l.kt)("inlineCode",{parentName:"p"},"Cube")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"Sphere"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Copy a Shape Object\n// copy_shape.cpp\n\n#include "Shape.h"\n\nShape* copy(const Shape& original)\n{\n    Shape* copy = new ???? (original);\n    return copy;\n}\n')),(0,l.kt)("p",null,"To determine the dynamic type at run-time we introduce a cloning member function to the hierarchy."),(0,l.kt)("p",null,"Let us upgrade the ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape")," interface to expose a ",(0,l.kt)("inlineCode",{parentName:"p"},"clone()")," query. This member function returns the address of a copy of the object created using its dynamic type:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"// Polymorphic Objects - Cloning\n// Shape.h\n#ifndef SHAPE_H\n#define SHAPE_H\n\nclass Shape\n{\npublic:\n    virtual double volume() const = 0;\n    virtual Shape* clone()  const = 0;\n};\n#endif\n")),(0,l.kt)("p",null,"The definition of each concrete class declares the ",(0,l.kt)("inlineCode",{parentName:"p"},"clone()")," query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Polymorphic Objects - Cloning\n// Cube.h\n\n#include "Shape.h"\n\nclass Cube : public Shape\n{\n    double len;\npublic:\n    Cube(double);\n    double volume() const;\n    Shape* clone() const;\n};\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Polymorphic Objects - Cloning\n// Sphere.h\n\n#include "Shape.h"\n\nclass Sphere : public Shape\n{\n    double rad;\npublic:\n    Sphere(double);\n    double volume() const;\n    Shape* clone() const;\n};\n')),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"Cube")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Sphere")," implementation files define the class specific versions of the ",(0,l.kt)("inlineCode",{parentName:"p"},"clone()")," member function:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Polymorphic Objects - Cloning\n// Cube.cpp\n\n#include "Cube.h"\n\nCube::Cube(double l) : len(l) {}\n\nShape* Cube::clone() const\n{\n    return new Cube(*this);\n}\n\ndouble Cube::volume() const\n{\n    return len * len * len;\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Polymorphic Objects - Cloning\n// Sphere.cpp\n\n#include "Sphere.h"\n\nSphere::Sphere(double r) : rad(r) {}\n\nShape* Sphere::clone() const\n{\n    return new Sphere(*this);\n}\n\ndouble Sphere::volume() const\n{\n    return 4.18879 * rad * rad * rad;\n}\n')),(0,l.kt)("p",null,"Each query creates a copy of the object by calling the copy constructor for its own class' dynamic type."),(0,l.kt)("p",null,"The following program uses the ",(0,l.kt)("inlineCode",{parentName:"p"},"clone()")," member function to copy the dynamic type and return the address of the copy. The results of two runs are shown below:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Polymorphic Objects - Cloning\n// cloning.cpp\n\n#include <iostream>\n#include "Cube.h"\n#include "Sphere.h"\n\nvoid displayVolume(const Shape* shape)\n{\n    if (shape)\n        std::cout << shape->volume() << std::endl;\n    else\n        std::cerr << "ERROR!" << std::endl;\n}\n\nShape* select()\n{\n    Shape* shape;\n    double x;\n    char c;\n    std::cout << "s (sphere), c (cube) : ";\n    std::cin >> c;\n    if (c == \'s\')\n    {\n        std::cout << "dimension : ";\n        std::cin >> x;\n        shape = new Sphere(x);\n    }\n    else if (c == \'c\')\n    {\n        std::cout << "dimension : ";\n        std::cin >> x;\n        shape = new Cube(x);\n    }\n    else\n        shape = nullptr;\n    return shape;\n}\n\nint main()\n{\n    Shape* shape = select();\n    Shape* clone = shape->clone();\n    displayVolume(shape);\n    displayVolume(clone);\n    delete clone;\n    delete shape;\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"First run :\n-----------\ns (sphere), c (cube) : s\ndimension : 1\n4.18879\n4.18879\n\n\nSecond run :\n------------\ns (sphere), c (cube) : c\ndimension : 2\n8\n8\n")),(0,l.kt)("h3",{id:"specializing-an-operation-for-a-dynamic-type-optional-for-oop345"},"Specializing an Operation for a Dynamic Type (Optional for OOP345)"),(0,l.kt)("p",null,"In expressions that involve operands of polymorphic type, the operator functions require knowledge of the received object's dynamic type. A ",(0,l.kt)("em",{parentName:"p"},"dynamic cast")," returns this type."),(0,l.kt)("p",null,"Let us upgrade the ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape")," interface to expose a query for comparing objects. This function receives the address of an object and return true if the object has the same properties as the current object:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"#ifndef SHAPE_H\n#define SHAPE_H\n// Polymorphic Objects - Dynamic Cast\n// Shape.h\n\nclass Shape\n{\npublic:\n    virtual double volume() const = 0;\n    virtual void display() const = 0;\n    virtual bool operator==(const Shape&) const = 0;\n};\n#endif\n")),(0,l.kt)("p",null,"The comparison will have a different definition in each concrete class and will require access to the instance variables of that class."),(0,l.kt)("p",null,"We declare the query in our definitions of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Cube")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Sphere")," classes:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Polymorphic Objects - Dynamic Cast\n// Cube.h\n\n#include "Shape.h"\n\nclass Cube : public Shape\n{\n    double len;\npublic:\n    Cube(double len);\n    void display() const;\n    double volume() const;\n    bool operator==(const Shape&) const;\n};\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Polymorphic Objects - Dynamic Cast\n// Sphere.h\n\n#include "Shape.h"\n\nclass Sphere : public Shape\n{\n    double rad;\npublic:\n    Sphere(double);\n    void display() const;\n    double volume() const;\n    bool operator==(const Shape&) const;\n};\n')),(0,l.kt)("p",null,"We define each query in the ",(0,l.kt)("inlineCode",{parentName:"p"},"Cube")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Sphere")," implementations and use the ",(0,l.kt)("inlineCode",{parentName:"p"},"dynamic_cast")," template to cast the type of the address received in the parameter to an address of the object's dynamic type:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Polymorphic Objects - Dynamic Cast\n// Cube.cpp\n\n#include <iostream>\n#include "Cube.h"\n\nCube::Cube(double l) : len(l) { }\n\nvoid Cube::display() const\n{\n    std::cout << "length = " << len << std::endl;\n}\n\ndouble Cube::volume() const\n{\n    return len * len * len;\n}\n\nbool Cube::operator==(const Shape& s) const\n{\n    const Cube* c = dynamic_cast<const Cube*>(&s);\n    return c ? len == c->len : false;\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Polymorphic Objects - Dynamic Cast\n// Sphere.cpp\n\n#include <iostream>\n#include "Sphere.h"\n\nSphere::Sphere(double r) : rad(r) { }\n\nvoid Sphere::display() const\n{\n    std::cout << "radius = " << rad << std::endl;\n}\n\ndouble Sphere::volume() const\n{\n    return 4.18879 * rad * rad * rad;\n}\n\nbool Sphere::operator==(const Shape& s) const\n{\n    const Sphere* c = dynamic_cast<const Sphere*>(&s);\n    return c ? rad == c->rad : false;\n}\n')),(0,l.kt)("p",null,"Casting from the abstract ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape*")," type to a concrete ",(0,l.kt)("inlineCode",{parentName:"p"},"Cube*")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"Sphere*")," type enables access to a respective complete object. Without the dynamic cast, the compiler would report an error that the instance variable is not a member of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape")," class:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"bool Cube::operator==(const Shape& s) const\n{\n    return len == s.len; // ERROR because len is not a member of Shape\n}\n")),(0,l.kt)("p",null,"Moreover, receiving an instance of type ",(0,l.kt)("inlineCode",{parentName:"p"},"Cube")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"Sphere")," directly would theoretically enable access to the object's instance variable but would generate an error that the object is incomplete because the ",(0,l.kt)("inlineCode",{parentName:"p"},"bool operator==(const Shape&) const")," is undefined:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"bool Cube::operator==(const Cube& s) const\n{\n    return len == s.len; // ERROR because Cube is not concrete\n}\n")),(0,l.kt)("p",null,"In the following program the user can compare two ",(0,l.kt)("inlineCode",{parentName:"p"},"Shape")," objects. The results for three runs are shown below:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Polymorphic Objects - Dynamic Cast\n// dynamic_casting.cpp\n\n#include <iostream>\n#include "Cube.h"\n#include "Sphere.h"\n\nShape* select()\n{\n    Shape* shape;\n    double x;\n    char c;\n    std::cout << "s (sphere), c (cube) : ";\n    std::cin >> c;\n    if (c == \'s\')\n    {\n        std::cout << "dimension : ";\n        std::cin >> x;\n        shape = new Sphere(x);\n    }\n    else if (c == \'c\')\n    {\n        std::cout << "dimension : ";\n        std::cin >> x;\n        shape = new Cube(x);\n    }\n    else\n        shape = nullptr;\n    return shape;\n}\n\nint main()\n{\n    Shape* s1 = select();\n    Shape* s2 = select();\n    s1->display();\n    s2->display();\n\n    if (*s1==*s2)\n        std::cout << "Same" << std::endl;\n    else\n        std::cout << "Different" << std::endl;\n\n    delete s1;\n    delete s2;\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"First Run\n---------\ns (sphere), c (cube) : c\ndimension : 21\ns (sphere), c (cube) : c\ndimension : 21\nlength = 21\nlength = 21\nSame\n\nSecond Run\n----------\ns (sphere), c (cube) : s\ndimension : 20\ns (sphere), c (cube) : s\ndimension : 21\nradius = 20\nradius = 21\nDifferent\n\nThird Run\n---------\ns (sphere), c (cube) : s\ndimension : 20\ns (sphere), c (cube) : c\ndimension : 20\nradius = 20\nlength = 20\nDifferent\n")),(0,l.kt)("h3",{id:"dynamic-type-identification-optional-for-oop345"},"Dynamic Type Identification (Optional for OOP345)"),(0,l.kt)("p",null,"The C++ language includes two elements that hold run-time information in addition to ",(0,l.kt)("inlineCode",{parentName:"p"},"dynamic_cast")," for identifying a polymorphic object's dynamic type. These elements can be used where type specific coding beyond the virtual mechanism is required."),(0,l.kt)("p",null,"In the following example, the ",(0,l.kt)("inlineCode",{parentName:"p"},"show()")," function calls the ",(0,l.kt)("inlineCode",{parentName:"p"},"display()")," function on all concrete classes except for objects of type ",(0,l.kt)("inlineCode",{parentName:"p"},"C"),", which are considered private. The ",(0,l.kt)("inlineCode",{parentName:"p"},"typeid()")," operator allows the type of an object to be determined at run-time. It receives a type and returns a ",(0,l.kt)("inlineCode",{parentName:"p"},"std::type_info")," object that represents the type received and holds type information. ",(0,l.kt)("inlineCode",{parentName:"p"},"type_info")," is defined in the header file ",(0,l.kt)("inlineCode",{parentName:"p"},"<typeinfo>"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Polymorphic Objects - RTTI\n// rtti.cpp\n\n#include <typeinfo> // for typeid\n#include <iostream>\n\nclass A\n{\n    int x;\npublic:\n    A(int a) : x(a) {}\n\n    virtual void display() const\n    {\n        std::cout << x << std::endl;\n    }\n};\n\nclass B : public A\n{\n    int y;\npublic:\n    B(int a, int b) : A(a), y(b) {}\n\n    void display() const\n    {\n        A::display();\n        std::cout << y << std::endl;\n    }\n};\n\nclass C : public B\n{\n    int z;\npublic:\n    C(int a = 4, int b = 6, int c = 7) : B(a, b), z(c) {}\n\n    void display() const\n    {\n        B::display();\n        std::cout << z << std::endl;\n    }\n};\n\n// show calls display() on all types except C\n//\nvoid show(const A* a)\n{\n    C cref;\n    if (typeid(*a) != typeid(cref))\n    {\n        a->display();\n    }\n    else\n        std::cout << typeid(cref).name() << " objects are private" << std::endl;\n}\n\nint main()\n{\n    A* a[3];\n    a[0] = new A(3);\n    a[1] = new B(2, 5);\n    a[2] = new C(4, 6, 7);\n\n    for(int i = 0; i < 3; i++)\n        show(a[i]);\n\n    for(int i = 0; i < 3; i++)\n        delete a[i];\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"3\n2\n5\nclass C objects are private\n")),(0,l.kt)("p",null,"We determine the type by comparing ",(0,l.kt)("inlineCode",{parentName:"p"},"typeid(*a)")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"typeid(cref)")," where ",(0,l.kt)("inlineCode",{parentName:"p"},"cref")," is the reference type. The ",(0,l.kt)("inlineCode",{parentName:"p"},"name()")," query on the ",(0,l.kt)("inlineCode",{parentName:"p"},"type_info")," object referred to by ",(0,l.kt)("inlineCode",{parentName:"p"},"typeid()")," returns the address of a C-style null-terminated string that holds some description of the type name. The description itself is implementation dependent."),(0,l.kt)("h2",{id:"liskov-substitution-principle"},"Liskov Substitution Principle"),(0,l.kt)("p",null,"Some confusion can arise in distinguishing type from subtypes in inheritance hierarchies. The ",(0,l.kt)("strong",{parentName:"p"},"Liskov Substitution Principle"),' provides guidance that avoids design ambiguity. The principle states that "a function that uses pointers or references to base classes must be able to use objects of derived classes without knowing it". In other words, we should model our classes on their behaviors not their properties and model our data based on properties and not on behaviors.'),(0,l.kt)("h3",{id:"the-correct-design"},"The Correct Design"),(0,l.kt)("p",null,"The classical example involves a square and a rectangle. Each is a kind of the other, but only one design ensures substitutability. That is, a rectangle is less abstract than a square: a rectangle should be derived from a square, since the rectangle adds a new measurement. This design is illustrated in the following 2 programs."),(0,l.kt)("h4",{id:"the-initial-design"},"The Initial Design"),(0,l.kt)("p",null,"The initial version focuses on the square alone:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Liskov Substitution Principle\n// liskov_square.cpp\n#include <iostream>\n\nclass Square\n{\n    double width;\npublic:\n    void setWidth(double w) { width = w; }\n    double getWidth() const { return width; }\n};\n\nvoid set(Square& s, double d)\n{\n    s.setWidth(d);\n}\n\nint main()\n{\n    Square s;\n\n    s.setWidth(20.0);\n    std::cout << "Square : " << s.getWidth() << std::endl;\n\n    set(s, 15.0);\n    std::cout << "Square : " << s.getWidth() << std::endl;\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"Square : 20\nSquare : 15\n")),(0,l.kt)("h4",{id:"the-upgraded-design"},"The Upgraded Design"),(0,l.kt)("p",null,"The upgraded version adds a new dimension for the rectangle without changing any of the original code:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Liskov Substitution Principle - Rectangle\n// liskov_rectangle.cpp\n#include <iostream>\n\nclass Square\n{\n    double width;\npublic:\n    void setWidth(double w) { width = w; }\n    double getWidth() const { return width; }\n};\n\nclass Rectangle : public Square\n{\n    double height;\npublic:\n    void setHeight(double h) { height = h; }\n    double getHeight() const { return height; }\n};\n\nvoid set(Square& s, double d)\n{\n    s.setWidth(d);\n}\n\nint main()\n{\n    Square s;\n\n    s.setWidth(20.0);\n    std::cout << "Square : " << s.getWidth() << std::endl;\n\n    Rectangle r;\n    r.setWidth(10.0);\n    r.setHeight(30.0);\n    std::cout << "Rectangle : " << r.getWidth() << ", " << r.getHeight() << std::endl;\n\n    set(s, 15.0);\n    std::cout << "Square : " << s.getWidth() << std::endl;\n\n    set(r, 25.0);\n    std::cout << "Rectangle : " << r.getWidth() << ", " << r.getHeight() << std::endl;\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"Square : 20\nRectangle : 10, 30\nSquare : 15\nRectangle : 25, 30\n")),(0,l.kt)("h3",{id:"an-incorrect-design"},"An Incorrect Design"),(0,l.kt)("p",null,"In mathematics, a square is a special case of a rectangle: it has equal sides. This might lead us to propose a design in which the square is derived from a rectangle (a special case of it). Consider this alternative design:"),(0,l.kt)("h4",{id:"the-initial-design-1"},"The Initial Design"),(0,l.kt)("p",null,"The initial design focuses on a rectangle alone:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Liskov Substitution Principle - Rectangle\n// liskov_rectangle_.cpp\n#include <iostream>\n\nclass Rectangle\n{\n    double width;\n    double height;\npublic:\n    void setWidth(double w)  { width = w; }\n    void setHeight(double h) { height = h; }\n    double getWidth() const  { return width; }\n    double getHeight() const { return height; }\n};\n\nvoid set(Rectangle& r, double d)\n{\n    r.setWidth(d);\n}\n\nint main()\n{\n    Rectangle r;\n    r.setWidth(10.0);\n    r.setHeight(30.0);\n    std::cout << "Rectangle : " << r.getWidth() << ", " << r.getHeight() << std::endl;\n\n    set(r, 25);\n    std::cout << "Rectangle : " << r.getWidth() << ", " << r.getHeight() << std::endl;\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"Rectangle : 10, 30\nRectangle : 25, 30\n")),(0,l.kt)("h4",{id:"the-upgraded-design-1"},"The Upgraded Design"),(0,l.kt)("p",null,"If we now add a square, derive it from a rectangle and ensure that the invariant of the square is maintained (equal sides), we need to add virtual to the original design (that is, change the original design):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Liskov Substitution Principle - Square from Rectangle\n// liskov_square_.cpp\n#include <iostream>\n\nclass Rectangle\n{\n    double width;\n    double height;\npublic:\n    virtual void setWidth(double w)  { width = w; }\n    virtual void setHeight(double h) { height = h; }\n    double getWidth() const  { return width; }\n    double getHeight() const { return height; }\n};\n\nclass Square : public Rectangle\n{\npublic:\n    void setWidth(double s)\n    {\n        Rectangle::setWidth(s);\n        Rectangle::setHeight(s);\n    }\n\n    void setHeight(double s)\n    {\n        Rectangle::setWidth(s);\n        Rectangle::setHeight(s);\n    }\n};\n\nvoid set(Rectangle& r, double d)\n{\n    r.setWidth(d);\n}\n\nint main()\n{\n    Square s;\n\n    s.set(20.0);\n    std::cout << "Square : " << s.getWidth() << std::endl;\n\n    Rectangle r;\n    r.setWidth(10.0);\n    r.setHeight(30.0);\n    std::cout << "Rectangle : " << r.getWidth() << ", " << r.getHeight() << std::endl;\n\n    set(s, 15.0);\n    std::cout << "Square : " << s.getWidth() << std::endl;\n\n    set(r, 25.0);\n    std::cout << "Rectangle : " << r.getWidth() << ", " << r.getHeight() << std::endl;\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"Square : 20\nRectangle : 10, 30\nSquare : 15\nRectangle : 25, 30\n")),(0,l.kt)("h4",{id:"the-design-is-still-flawed"},"The Design is Still Flawed"),(0,l.kt)("p",null,"Consider the following initial program for a rectangle."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Liskov Substitution Principle - Rectangle\n// liskov_rectangle__.cpp\n#include <iostream>\n\nclass Rectangle\n{\n    double width;\n    double height;\npublic:\n    virtual void setWidth(double w)  { width = w; }\n    virtual void setHeight(double h) { height = h; }\n    double getWidth() const  { return width; }\n    double getHeight() const { return height; }\n};\n\nvoid set(Rectangle& r)\n{\n    r.setWidth(3);\n    r.setHeight(4);\n    if(r.getWidth() * r.getHeight() != 12)\n        std::cerr << "* volume isn\'t 12 *\\n";\n}\n\nint main()\n{\n    Rectangle r;\n\n    r.setWidth(10.0);\n    r.setHeight(30.0);\n    std::cout << "Rectangle : " << r.getWidth() << ", " << r.getHeight() << std::endl;\n\n    set(r);\n    std::cout << "Rectangle : " << r.getWidth() << ", " << r.getHeight() << std::endl;\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"Rectangle : 10, 30\nRectangle : 3, 4\n")),(0,l.kt)("p",null,"Deriving the square from the rectangle makes this obvious. Note the error message from ",(0,l.kt)("inlineCode",{parentName:"p"},"set()"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Liskov Substitution Principle - Square from Rectangle\n// liskov_square__.cpp\n#include <iostream>\n\nclass Rectangle\n{\n    double width;\n    double height;\npublic:\n    virtual void setWidth(double w)  { width = w; }\n    virtual void setHeight(double h) { height = h; }\n    double getWidth() const  { return width; }\n    double getHeight() const { return height; }\n};\n\nclass Square : public Rectangle\n{\npublic:\n    void setWidth(double s)\n    {\n        Rectangle::setWidth(s);\n        Rectangle::setHeight(s);\n    }\n\n    void setHeight(double s)\n    {\n        Rectangle::setWidth(s);\n        Rectangle::setHeight(s);\n    }\n};\n\nvoid set(Rectangle& r)\n{\n    r.setWidth(3);\n    r.setHeight(4);\n    if(r.getWidth() * r.getHeight() != 12)\n        std::cerr << "* volume isn\'t 12 *\\n";\n}\n\nint main()\n{\n    Square s;\n    s.setWidth(20.0);\n    std::cout << "Square : " << s.getWidth() << std::endl;\n\n    Rectangle r;\n    r.setWidth(10.0);\n    r.setHeight(30.0);\n    std::cout << "Rectangle : " << r.getWidth() << ", " << r.getHeight() << std::endl;\n\n    set(s);\n    std::cout << "Square : " << s.getWidth() << std::endl;\n    set(r);\n    std::cout << "Rectangle : " << r.getWidth() << ", " << r.getHeight() << std::endl;\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"Square : 20\nRectangle : 10, 30\nvolume is not 12\nSquare : 4\nRectangle : 3, 4\n")),(0,l.kt)("p",null,"When creating a derived class causes a change to the base class, this is a sign that the design is probably faulty."),(0,l.kt)("h2",{id:"exercises"},"Exercises"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Read Robert Martin on ",(0,l.kt)("a",{parentName:"li",href:"http://web.archive.org/web/20151128004108/http://www.objectmentor.com/resources/articles/lsp.pdf"},"The Liskov Substitution Principle"),";")))}h.isMDXComponent=!0},3249:function(e,n,t){n.Z=t.p+"assets/images/abstract-e87418a3c620d22e45e391431822f4f1.svg"},6960:function(e,n){n.Z="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCEtLSBEbyBub3QgZWRpdCB0aGlzIGZpbGUgd2l0aCBlZGl0b3JzIG90aGVyIHRoYW4gZGlhZ3JhbXMubmV0IC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZlcnNpb249IjEuMSIgd2lkdGg9IjI4MXB4IiBoZWlnaHQ9IjEwMXB4IiB2aWV3Qm94PSItMC41IC0wLjUgMjgxIDEwMSIgY29udGVudD0iJmx0O214ZmlsZSBob3N0PSZxdW90O0VsZWN0cm9uJnF1b3Q7IG1vZGlmaWVkPSZxdW90OzIwMjItMDgtMjBUMTg6NTk6NTguMjE4WiZxdW90OyBhZ2VudD0mcXVvdDs1LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgZHJhdy5pby8yMC4yLjMgQ2hyb21lLzEwMi4wLjUwMDUuMTY3IEVsZWN0cm9uLzE5LjAuMTEgU2FmYXJpLzUzNy4zNiZxdW90OyBldGFnPSZxdW90O0JUaGs4QXlGc1VIQUpBWGFSSnN4JnF1b3Q7IHZlcnNpb249JnF1b3Q7MjAuMi4zJnF1b3Q7IHR5cGU9JnF1b3Q7ZGV2aWNlJnF1b3Q7IHBhZ2VzPSZxdW90OzMmcXVvdDsmZ3Q7Jmx0O2RpYWdyYW0gaWQ9JnF1b3Q7a0RtelFSb1dHd3J1bzN4YklqSkwmcXVvdDsgbmFtZT0mcXVvdDtTaGFwZSBIaWVyYXJjaHkmcXVvdDsmZ3Q7N1ZaZGM1c3dFUHcxZmt4SGdJbmR4d2FiZURweDNkWk5uRHg1VkhNR0pZQVlXUVRJcjYrQTQ4czRqcE4ybXBsT2ViRnVkWGVTZGhlWmdXRUY2YVdna1RmbkR2Z0RuVGpwd0pnTWRGM1R5RkQ5NUVoV0loK0pXUUt1WUE0bU5jQ1NQUUdDQk5HWU9iRHJKRXJPZmNtaUxyamhZUWdiMmNHb0VEenBwbTI1MzEwMW9pNzBnT1dHK24xMHhSenBsZWpZSkEwK0ErWjZzajR3emdTMFNrWmc1MUdISnkzSW1BNE1TM0F1eTFHUVd1RG41Rlc4bEhYMk03UDF4Z1NFOHBTQ2g5QWRYMzArQjllMitmRDdaSDFybjYzUHNNc2o5V004OE5LakVlQ09aVmJSSUhnY09wQjNJZ1BqSXZHWWhHVkVOL2xzb29SWG1DY0RYMFdhR202WjcxdmM1NktvTmFoT2lHN21PQTlsQzk4V2o4SjNVdkFIYU0yYzIwUTlXSUdlME9zWWQxVnRIWVNFOUZsT3RKcHBaVkhnQVVpUnFSUXNHS00yU1NPdFZ1bmx0V1ExRUtQb0pyZnUxQkN1QnNqNVlmNkRHeXUycm9OMDlTV1luOTFmRGgvc3llb0EvMWI4ODgvU1Q4aVlGbVQyYUNiRUhOVTBIeExtR1Aza2Qrakh5MkQwRitsZkpMQ1llN05vTHRkazlHUlBxYjRZSGJKLzVJSDQ5d1dvQ3M2eHl6c0lNc3RZY0h2RHYwMHV6RjA2VHA3V1A5YXNFcVRGUERqcVBzYVFDK2x4bDRmVW56Ym9SVmViSnVlSzh3Z1Z1UWNwTXlTU3hwSjM5ZXJwTWlvZU5RTXBrN2Q1NHc4bVJuZTRURDZlcE8wZ3E0SlFFZEVxeXNNN1hLa0ltcklpcXVyS2srZkhQUzZtWW9mSFlnTXYzeXFTQ2hma1M3ZC8zeHdDZkNyWlkzY2ZoNlRHMHErY3FSM1dwdEpKMTFTYXVlZVdjdjlZMWY3SDJtczA3UGJaYjFNZXI5ZW04RjE5bXJkYlVmOXZ4ZGRaOGRnTiswNVcxUGFzMkx1NFRyV2k5all2ZmhLQ1pxMjBLRS9ZSFhsMTlJUEx2SEpYell0UXJuL2lhNkhDNW11MFRHKys2WTNwTHc9PSZsdDsvZGlhZ3JhbSZndDsmbHQ7ZGlhZ3JhbSBpZD0mcXVvdDtDNVJCczQzb0RhLUtkelplTnR1eSZxdW90OyBuYW1lPSZxdW90O0Fic3RyYWN0IENsYXNzZXMmcXVvdDsmZ3Q7N1poZGQ1cEFFSVovalpmdDJROFFjeGsxWDIyYWs1NjB0YjNjd0Nva0swdVhKVWgvZlJjWkJJU2FtSnFZOXNpTnpNdnNzanZQN0RqYW82UDU0a3l4eVA4a1BTNTZCSG1MSGgzM0NNRVlXZVlqVjdKQ09VSjJJY3hVNElGVEpkd0V2emlJQ05RazhIamNjTlJTQ2gxRVRkR1ZZY2hkM2RDWVVqSnR1azJsYUw0MVlqUGVFbTVjSnRycUpQQzBYNmdENGxUNk9ROW1mdmxtM0Q4cW5zeFo2UXc3aVgzbXliUW0wWk1lSFNrcGRYRTNYNHk0eUlOWHhtVnlrVTNFNVgzLzdNUG4rQ2Y3T3Z6NDVlcmJ1Mkt5MDIyR3JMYWdlS2lmUFhYa0RvYkRxeVMxcm9tVGpKT0xvL01Vd1JEMHdFUUM4VHEramJWaUJrU3haNTJWZ1ZReUNUMmVUNFo2ZEpqNmdlWTNFWFB6cDZsSkhhUDVlaTZNaGMzdE5CQmlKSVZVeTdHVUVZU0luZXN5MURWOXVyeU1idDRwNzNudFNmOFVtUXRHUUZhUmxRMnJnc0E4Y0tYNVlnMzNJN0hDSzRBbTg3bWNjNjB5TXc1bUlSWUVKcTFTQnBkNTROZlNoWUxHSUV0bnE2a3FFdVlHWUd3QnhtN0ZuM3NtcjhHVVN2dHlKa01tVGlwMTJDUlUrVnhLR1FHWE82NTFCdUZraVpaTmFpMEt6dkl5VDRyVjVFdDRScGpOTm1TaVhMNWh1eFFxQTFNenJoL0wxelkyeFFYVHdVTnpjVnN3a2JkM2VlMGhTTEJiTG9waFVKWUVpMkVlRVlTOEVEZVM2OWVXQ0tSZmw2SWhvckx2K2ZqM2RtbitnT21XeG5qUnNES3czajU5NnkvcEw0Y2VLOFd5bWtNa2cxREh0Wm12YzZHcUJSVEJHWWN2UUd5dDFkazEvLzVHZDNOVExLQkt3OVZPdWpMVG1KQ2NXeFNQd2FGNGRQazVMMU04bnNZRTAzMUErWDlyQWY3RE4vZ3IwYlFPUjZ3ekx1UmZLTkcydGRNYS9iU1VvYTFXZXlSRFYzSE5kOXBxSXpSZ3FQTUlJMlE3cTVhNnF3bmYxR3FYUHhSZXJ0VUdGczYrTzIrcnhla2lqRFVMM1YxenNoR2ZicURSd1ErUGg2TkhPSkdkY3lyUHlHRGZZSndEbUs0RGhOY2J6cjJEd3ZoQXFvc1VKVytPRkRtUTZpSmxEVjZQbERHci94Q0xacVA2SjVhZS9BWT0mbHQ7L2RpYWdyYW0mZ3Q7Jmx0O2RpYWdyYW0gaWQ9JnF1b3Q7MnVvZ0hXWFI3MmQ3czROaHJfOF8mcXVvdDsgbmFtZT0mcXVvdDtQYWdlLTImcXVvdDsmZ3Q7N1Z0Yms5b2dHUDAxZVZ5SEJPUGxzYXZieTg3c3RGTWYyajd0b0VHVE5nWUhjVFg5OVVVRG1uaUROU3BLNDhOTytNSWxuSFA0Rms3VWdaM3g0aE5Gay9DRkJEaDJQQkFzSE5oMVBBOENqLzlkQnRJczROVmJXV0JFb3lBTHVadEFML3FMUlJDSTZDd0s4TFJRa1JFU3MyaFNEQTVJa3VBQks4UVFwV1JlckRZa2NYSFVDUnJoblVCdmdPTGQ2SThvWUdFV2JmbGdFLytNbzFFb1IzYUJ1RE5Hc3JJSVRFTVVrSGt1Qko4YzJLR0VzT3hxdk9qZ2VJbWR4Q1ZyOS9IQTNmV0RVWnd3blFaK3J4Ky8wTDcvNWZVaGdlM243MC9QYlByZzFyTnUzbEE4RXpNV1Q4dFNDY0dJa3RuRWdZK2lKcVlNTC9aaGovcXlCZGg5Tm5jOVk2NFVUTWFZMFpSWFdVaFZpQ1pTSlpMK2VRNXpFUXB6Y011UmtHQjV0TzU1QXdTL0VGaThCeGRmalF1SEpRbndzaGZBMFptSEVjTzlDUm9zNzg3NVd1Q3hrSTM1cUYyWFh3NUp3b1M2UFhBTXpEeG9SeWpiaGRJWVZBMDFWRGdKUGl3WEl5OGxKTUZGYUlvNGJnUDFlemFlaUhLREYzbFB1ZEtVVWZJSGYrV29SeXd0UW91RG5ZVmRIbGgvRDdBeVJuR01XUFJXSEhRZjJtS0VieVRpajdOZUF1NFdQMU15b3dNc0t1V1g5WUYyNlg2YUdhSWp6SGE2V1RHOW5tTUo4cHNYSlg4dnY1eEZtdjVjdHFoNXZpei9FajJzQ3QxRm9aU0tVamxoOEg4OEt5eVZXY09VZ3J6alN0QVYxRlkzMjdxOHRLQmExeGZVZlNZTWVDSy8wR3pDYUJ0TkdGVyt5QW1oWFdzMTI3bVBmNWI4b2VqMnl2bEV6cUxLSnlvNStDZnk3UnZOSjNLZUZiOHFmaHNuOHRzd3k2OVg4YXZIYi9ORWZwdG0rZFhZRDJRR3hLRURjM24zb2JXRmdHbnpRUnNTcnVjb2pqc2tKcFNIQXp4RXM1aVZkV3FPMEhSRHBvTWFvbEwyVEI1WHg0TkRnQ0JBb2w0dURsYWZkUjdKM1huc05yTTdCN2xRWW41amtNUHJKK0tUVC9vcU90NmYyOVZrVkNmNzQvclJjSnJQclIvTFpBQ1A4M2NmQm9DR3NWN0pRSFZ1Yjd2NkIyeGRXZFJCRGRSTkt1T3lPLzMzdjBld1REYnVlYktIMmZjTmwzM1hkQ1VaYUd5bXIrRHpsTlNCV2R2SHdHc24yM1RRT0k4T3pOcERCdDRXMmFhRDVubDBZTlpHa250YWt6YVN1NzBVVFB0SVVNTWx1YmFSQk1GK0RJMWhwTEhydkhzbkNSNFFyakhRLzI4dlNZT095a3hTS01nS044bXNFS3l3azZBVmZwSmhJVmhxS01GYisyYXFiY0t4d2xLQ1ZuZ0pHdnZxeWxOU0NNRUtNOEdzRUt3d2xhQ0I3NmphSm9RYmQ1VjRjZlBMcTZ6NjV1ZHI4T2tmJmx0Oy9kaWFncmFtJmd0OyZsdDsvbXhmaWxlJmd0OyI+PGRlZnMvPjxnPjxyZWN0IHg9IjgwIiB5PSIwIiB3aWR0aD0iMTIwIiBoZWlnaHQ9IjMwIiBmaWxsPSIjYTIwMDI1IiBzdHJva2U9IiM2ZjAwMDAiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMC41IC0wLjUpIj48c3dpdGNoPjxmb3JlaWduT2JqZWN0IHBvaW50ZXItZXZlbnRzPSJub25lIiB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiIHN0eWxlPSJvdmVyZmxvdzogdmlzaWJsZTsgdGV4dC1hbGlnbjogbGVmdDsiPjxkaXYgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiIHN0eWxlPSJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogdW5zYWZlIGNlbnRlcjsganVzdGlmeS1jb250ZW50OiB1bnNhZmUgY2VudGVyOyB3aWR0aDogMTE4cHg7IGhlaWdodDogMXB4OyBwYWRkaW5nLXRvcDogMTVweDsgbWFyZ2luLWxlZnQ6IDgxcHg7Ij48ZGl2IGRhdGEtZHJhd2lvLWNvbG9ycz0iY29sb3I6ICNmZmZmZmY7ICIgc3R5bGU9ImJveC1zaXppbmc6IGJvcmRlci1ib3g7IGZvbnQtc2l6ZTogMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGZvbnQtc2l6ZTogMjBweDsgZm9udC1mYW1pbHk6IEhlbHZldGljYTsgY29sb3I6IHJnYigyNTUsIDI1NSwgMjU1KTsgbGluZS1oZWlnaHQ6IDEuMjsgcG9pbnRlci1ldmVudHM6IGFsbDsgZm9udC13ZWlnaHQ6IGJvbGQ7IHdoaXRlLXNwYWNlOiBub3JtYWw7IG92ZXJmbG93LXdyYXA6IG5vcm1hbDsiPlNoYXBlPC9kaXY+PC9kaXY+PC9kaXY+PC9mb3JlaWduT2JqZWN0Pjx0ZXh0IHg9IjE0MCIgeT0iMjEiIGZpbGw9IiNmZmZmZmYiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMjBweCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC13ZWlnaHQ9ImJvbGQiPlNoYXBlPC90ZXh0Pjwvc3dpdGNoPjwvZz48cmVjdCB4PSIwIiB5PSI3MCIgd2lkdGg9IjEyMCIgaGVpZ2h0PSIzMCIgZmlsbD0iIzAwOGEwMCIgc3Ryb2tlPSIjMDA1NzAwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTAuNSAtMC41KSI+PHN3aXRjaD48Zm9yZWlnbk9iamVjdCBwb2ludGVyLWV2ZW50cz0ibm9uZSIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5IiBzdHlsZT0ib3ZlcmZsb3c6IHZpc2libGU7IHRleHQtYWxpZ246IGxlZnQ7Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IHVuc2FmZSBjZW50ZXI7IGp1c3RpZnktY29udGVudDogdW5zYWZlIGNlbnRlcjsgd2lkdGg6IDExOHB4OyBoZWlnaHQ6IDFweDsgcGFkZGluZy10b3A6IDg1cHg7IG1hcmdpbi1sZWZ0OiAxcHg7Ij48ZGl2IGRhdGEtZHJhd2lvLWNvbG9ycz0iY29sb3I6ICNmZmZmZmY7ICIgc3R5bGU9ImJveC1zaXppbmc6IGJvcmRlci1ib3g7IGZvbnQtc2l6ZTogMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGZvbnQtc2l6ZTogMjBweDsgZm9udC1mYW1pbHk6IEhlbHZldGljYTsgY29sb3I6IHJnYigyNTUsIDI1NSwgMjU1KTsgbGluZS1oZWlnaHQ6IDEuMjsgcG9pbnRlci1ldmVudHM6IGFsbDsgd2hpdGUtc3BhY2U6IG5vcm1hbDsgb3ZlcmZsb3ctd3JhcDogbm9ybWFsOyI+Q3ViZTwvZGl2PjwvZGl2PjwvZGl2PjwvZm9yZWlnbk9iamVjdD48dGV4dCB4PSI2MCIgeT0iOTEiIGZpbGw9IiNmZmZmZmYiIGZvbnQtZmFtaWx5PSJIZWx2ZXRpY2EiIGZvbnQtc2l6ZT0iMjBweCIgdGV4dC1hbmNob3I9Im1pZGRsZSI+Q3ViZTwvdGV4dD48L3N3aXRjaD48L2c+PHJlY3QgeD0iMTYwIiB5PSI3MCIgd2lkdGg9IjEyMCIgaGVpZ2h0PSIzMCIgZmlsbD0iIzAwOGEwMCIgc3Ryb2tlPSIjMDA1NzAwIiBwb2ludGVyLWV2ZW50cz0iYWxsIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTAuNSAtMC41KSI+PHN3aXRjaD48Zm9yZWlnbk9iamVjdCBwb2ludGVyLWV2ZW50cz0ibm9uZSIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgcmVxdWlyZWRGZWF0dXJlcz0iaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNFeHRlbnNpYmlsaXR5IiBzdHlsZT0ib3ZlcmZsb3c6IHZpc2libGU7IHRleHQtYWxpZ246IGxlZnQ7Ij48ZGl2IHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzdHlsZT0iZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IHVuc2FmZSBjZW50ZXI7IGp1c3RpZnktY29udGVudDogdW5zYWZlIGNlbnRlcjsgd2lkdGg6IDExOHB4OyBoZWlnaHQ6IDFweDsgcGFkZGluZy10b3A6IDg1cHg7IG1hcmdpbi1sZWZ0OiAxNjFweDsiPjxkaXYgZGF0YS1kcmF3aW8tY29sb3JzPSJjb2xvcjogI2ZmZmZmZjsgIiBzdHlsZT0iYm94LXNpemluZzogYm9yZGVyLWJveDsgZm9udC1zaXplOiAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IGlubGluZS1ibG9jazsgZm9udC1zaXplOiAyMHB4OyBmb250LWZhbWlseTogSGVsdmV0aWNhOyBjb2xvcjogcmdiKDI1NSwgMjU1LCAyNTUpOyBsaW5lLWhlaWdodDogMS4yOyBwb2ludGVyLWV2ZW50czogYWxsOyB3aGl0ZS1zcGFjZTogbm9ybWFsOyBvdmVyZmxvdy13cmFwOiBub3JtYWw7Ij5TcGhlcmU8L2Rpdj48L2Rpdj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PHRleHQgeD0iMjIwIiB5PSI5MSIgZmlsbD0iI2ZmZmZmZiIgZm9udC1mYW1pbHk9IkhlbHZldGljYSIgZm9udC1zaXplPSIyMHB4IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5TcGhlcmU8L3RleHQ+PC9zd2l0Y2g+PC9nPjxwYXRoIGQ9Ik0gNjAgNzAgTCA2MCA1MCBMIDE0MCA1MCBMIDE0MCAzNi4zNyIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNzc3Nzc3IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiLz48cGF0aCBkPSJNIDE0MCAzMS4xMiBMIDE0My41IDM4LjEyIEwgMTQwIDM2LjM3IEwgMTM2LjUgMzguMTIgWiIgZmlsbD0iIzc3Nzc3NyIgc3Ryb2tlPSIjNzc3Nzc3IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48cGF0aCBkPSJNIDIyMCA3MCBMIDIyMCA1MCBMIDE0MCA1MCBMIDE0MCAzNi4zNyIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjNzc3Nzc3IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJzdHJva2UiLz48cGF0aCBkPSJNIDE0MCAzMS4xMiBMIDE0My41IDM4LjEyIEwgMTQwIDM2LjM3IEwgMTM2LjUgMzguMTIgWiIgZmlsbD0iIzc3Nzc3NyIgc3Ryb2tlPSIjNzc3Nzc3IiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHBvaW50ZXItZXZlbnRzPSJhbGwiLz48L2c+PHN3aXRjaD48ZyByZXF1aXJlZEZlYXR1cmVzPSJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0V4dGVuc2liaWxpdHkiLz48YSB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLC01KSIgeGxpbms6aHJlZj0iaHR0cHM6Ly93d3cuZGlhZ3JhbXMubmV0L2RvYy9mYXEvc3ZnLWV4cG9ydC10ZXh0LXByb2JsZW1zIiB0YXJnZXQ9Il9ibGFuayI+PHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIxMHB4IiB4PSI1MCUiIHk9IjEwMCUiPlRleHQgaXMgbm90IFNWRyAtIGNhbm5vdCBkaXNwbGF5PC90ZXh0PjwvYT48L3N3aXRjaD48L3N2Zz4="}}]);