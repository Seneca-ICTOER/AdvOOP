"use strict";(self.webpackChunkoop345=self.webpackChunkoop345||[]).push([[426],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return u}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=p(n),u=a,f=m["".concat(l,".").concat(u)]||m[u]||d[u]||r;return n?i.createElement(f,s(s({ref:t},c),{},{components:n})):i.createElement(f,s({ref:t},c))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var p=2;p<r;p++)s[p]=n[p];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},434:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return c},default:function(){return m}});var i=n(7462),a=n(3366),r=(n(7294),n(3905)),s=["components"],o={id:"file-stream-objects",title:"File Stream Objects",sidebar_position:4,description:"TBD"},l="File Stream Objects",p={unversionedId:"E-STL/file-stream-objects",id:"E-STL/file-stream-objects",isDocsHomePage:!1,title:"File Stream Objects",description:"TBD",source:"@site/docs/E-STL/file-stream-objects.md",sourceDirName:"E-STL",slug:"/E-STL/file-stream-objects",permalink:"/E-STL/file-stream-objects",editUrl:"https://github.com/Seneca-ICTOER/AdvOOP/tree/main/docs/E-STL/file-stream-objects.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"file-stream-objects",title:"File Stream Objects",sidebar_position:4,description:"TBD"},sidebar:"courseNotesSidebar",previous:{title:"Algorithms",permalink:"/E-STL/algorithms"},next:{title:"Raw Pointers",permalink:"/F-MemoryModel/raw-pointers"}},c=[{value:"Class Hierarchy",id:"class-hierarchy",children:[{value:"Two Class Hierarchies",id:"two-class-hierarchies",children:[{value:"<code>ios</code> Class Hierarchy",id:"ios-class-hierarchy",children:[],level:4},{value:"<code>wios</code> Hierarchy",id:"wios-hierarchy",children:[],level:4}],level:3},{value:"<code>ios_base</code> Class",id:"ios_base-class",children:[{value:"State Flags",id:"state-flags",children:[],level:4},{value:"Stream Seeking Direction",id:"stream-seeking-direction",children:[],level:4}],level:3},{value:"<code>basic_ios</code> Template",id:"basic_ios-template",children:[{value:"Member Functions",id:"member-functions",children:[],level:4},{value:"Open mode Flags",id:"open-mode-flags",children:[],level:4}],level:3},{value:"<code>ios</code> Classes",id:"ios-classes",children:[{value:"Output Stream",id:"output-stream",children:[],level:4},{value:"Input Stream",id:"input-stream",children:[],level:4}],level:3},{value:"<code>wios</code> Class",id:"wios-class",children:[{value:"Output Stream",id:"output-stream-1",children:[],level:4},{value:"Input Stream",id:"input-stream-1",children:[],level:4}],level:3}],level:2},{value:"File Objects",id:"file-objects",children:[{value:"Connections",id:"connections",children:[{value:"File Buffer",id:"file-buffer",children:[],level:4}],level:3},{value:"Close a Connection",id:"close-a-connection",children:[],level:3},{value:"Direct Access",id:"direct-access",children:[],level:3},{value:"Writing and Reading",id:"writing-and-reading",children:[],level:3}],level:2},{value:"Binary Access",id:"binary-access",children:[{value:"Input",id:"input",children:[],level:3},{value:"Output",id:"output",children:[],level:3},{value:"Binary versus Text",id:"binary-versus-text",children:[],level:3}],level:2},{value:"Exercises",id:"exercises",children:[],level:2}],d={toc:c};function m(e){var t=e.components,o=(0,a.Z)(e,s);return(0,r.kt)("wrapper",(0,i.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"file-stream-objects"},"File Stream Objects"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Describe the file objects for streaming sequences of data"),(0,r.kt)("li",{parentName:"ul"},"Describe how to write to and read from the same file object"),(0,r.kt)("li",{parentName:"ul"},"Describe how to store and retrieve images of memory without loss of information")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},'"Files are examples of containers that you can both read from and write to.  Consequently, you can have a stream that supports both ',(0,r.kt)("inlineCode",{parentName:"p"},"<<")," and ",(0,r.kt)("inlineCode",{parentName:"p"},">>"),".  Such a stream is called an ",(0,r.kt)("inlineCode",{parentName:"p"},"iostream"),'." Stroustrup (1997)')),(0,r.kt)("p",null,"The streaming facilities for transfers to and from memory are defined in the input/output category of the Standard Library.  A ",(0,r.kt)("strong",{parentName:"p"},"stream")," is defined as a sequence of items of unspecified size, while a byte stream is a sequence of bytes of unspecified size."),(0,r.kt)("p",null,"This chapter outlines the input-output stream class hierarchy of the C++ Standard Library, describes the file-stream classes in detail and introduces the member functions that access byte data within a file."),(0,r.kt)("h2",{id:"class-hierarchy"},"Class Hierarchy"),(0,r.kt)("p",null,"The input-output stream class hierarchy supports streaming to and from the standard console devices, files, and string streams.  The base class for this hierarchy is called ",(0,r.kt)("inlineCode",{parentName:"p"},"ios_base"),".  It defines components that are independent of the direction of the stream.  The ",(0,r.kt)("inlineCode",{parentName:"p"},"basic_ios")," class template holds the type-dependent information."),(0,r.kt)("h3",{id:"two-class-hierarchies"},"Two Class Hierarchies"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"basic_ios")," class template supports streams of char objects and ",(0,r.kt)("inlineCode",{parentName:"p"},"wchar_t")," objects through separate hierarchies. "),(0,r.kt)("h4",{id:"ios-class-hierarchy"},(0,r.kt)("inlineCode",{parentName:"h4"},"ios")," Class Hierarchy"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ios")," class is the instance of the ",(0,r.kt)("inlineCode",{parentName:"p"},"basic_ios")," template for streams of type ",(0,r.kt)("inlineCode",{parentName:"p"},"char"),".  The input (",(0,r.kt)("inlineCode",{parentName:"p"},"istream"),") and output (",(0,r.kt)("inlineCode",{parentName:"p"},"ostream"),") classes are abstract classes derived from this ",(0,r.kt)("inlineCode",{parentName:"p"},"ios")," class.  Furthermore, the file input stream class (",(0,r.kt)("inlineCode",{parentName:"p"},"ifstream"),") derives from the ",(0,r.kt)("inlineCode",{parentName:"p"},"istream")," class and the file output stream class (",(0,r.kt)("inlineCode",{parentName:"p"},"ofstream"),") derives from the ",(0,r.kt)("inlineCode",{parentName:"p"},"ostream")," class.  The ",(0,r.kt)("inlineCode",{parentName:"p"},"fstream")," class combines the input and output functionality and derives from the ",(0,r.kt)("inlineCode",{parentName:"p"},"iostream")," class, which derives from the ",(0,r.kt)("inlineCode",{parentName:"p"},"istream")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ostream")," classes."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"IOS Hierarchy",src:n(3079).Z})),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"<fstream>")," header file contains the definitions of all three file stream classes. All of the classes in this hierarchy are defined in the ",(0,r.kt)("inlineCode",{parentName:"p"},"std")," namespace."),(0,r.kt)("h4",{id:"wios-hierarchy"},(0,r.kt)("inlineCode",{parentName:"h4"},"wios")," Hierarchy"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"wios")," class is an instance of the ",(0,r.kt)("inlineCode",{parentName:"p"},"basic_ios")," template for streams of type ",(0,r.kt)("inlineCode",{parentName:"p"},"wchar_t"),".  The input (",(0,r.kt)("inlineCode",{parentName:"p"},"wistream"),") and output (",(0,r.kt)("inlineCode",{parentName:"p"},"wostream"),") classes are abstract classes derived from this ",(0,r.kt)("inlineCode",{parentName:"p"},"wios")," class.  The file input stream class (",(0,r.kt)("inlineCode",{parentName:"p"},"wifstream"),") derives from the ",(0,r.kt)("inlineCode",{parentName:"p"},"wistream")," class and the file output stream class (",(0,r.kt)("inlineCode",{parentName:"p"},"wofstream"),") derives from the ",(0,r.kt)("inlineCode",{parentName:"p"},"wostream")," class.  The ",(0,r.kt)("inlineCode",{parentName:"p"},"wfstream")," class combines the input and output functionality and derives from the ",(0,r.kt)("inlineCode",{parentName:"p"},"wiostream")," class, which derives from the ",(0,r.kt)("inlineCode",{parentName:"p"},"wistream")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"wostream")," classes. "),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"WIOS Hierarchy",src:n(4891).Z})),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"<wfstream>")," header file contains the definitions of all three file stream classes. All of the classes in this hierarchy are defined in the ",(0,r.kt)("inlineCode",{parentName:"p"},"std")," namespace."),(0,r.kt)("h3",{id:"ios_base-class"},(0,r.kt)("inlineCode",{parentName:"h3"},"ios_base")," Class"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ios_base")," class shared by both hierarchies holds formatting information, stream state flags, stream opening mode flags and the stream seeking direction flag.  Its member functions provide access to these flags. "),(0,r.kt)("h4",{id:"state-flags"},"State Flags"),(0,r.kt)("p",null,"Four flags identify a stream's current state:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ios_base::goodbit")," is true if the next operation ",(0,r.kt)("em",{parentName:"li"},"may")," succeed"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ios_base::failbit")," is true if the latest operation failed"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ios_base::eofbit")," is true if the stream object encountered an end of data mark"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ios_base::badbit")," is true if the stream object encountered a serious error, possibly with the internal buffer")),(0,r.kt)("p",null,"A stream is in a ready state if the first flag is true or the other three flags are false. "),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"eofbit")," flag is set only after an attempt to read the stream has been made to read data when there is no more data to be read.  Just having finished accessing the last byte in a stream does not set this ",(0,r.kt)("inlineCode",{parentName:"p"},"eofbit")," flag: it is the subsequent attempt to access a further byte that sets this bit."),(0,r.kt)("h4",{id:"stream-seeking-direction"},"Stream Seeking Direction"),(0,r.kt)("p",null,"Three enumeration constants identify the seeking direction in a stream seeking operation"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ios_base::beg")," - beginning of the stream"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ios_base::end")," - end of the stream"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ios_base::cur")," - current position within the stream")),(0,r.kt)("p",null,"These are public member constants and can be referred to throughout the inherited classes (",(0,r.kt)("inlineCode",{parentName:"p"},"ios::beg"),") or their instantiated objects (",(0,r.kt)("inlineCode",{parentName:"p"},"cin.beg"),")."),(0,r.kt)("h3",{id:"basic_ios-template"},(0,r.kt)("inlineCode",{parentName:"h3"},"basic_ios")," Template"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"basic_ios")," template adds the fill character and holds the current state.  Its member functions provide access to the state flags. "),(0,r.kt)("h4",{id:"member-functions"},"Member Functions"),(0,r.kt)("p",null,"Six public member functions query the current state of the stream:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool basic_ios::good() const")," - none of the flags is set"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool basic_ios::fail() const")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"ios::failbit")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"ios::badbit")," is ",(0,r.kt)("inlineCode",{parentName:"li"},"true")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool basic_ios::eof() const")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"ios::eofbit")," is ",(0,r.kt)("inlineCode",{parentName:"li"},"true")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool basic_ios::bad() const")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"ios::badbit")," is ",(0,r.kt)("inlineCode",{parentName:"li"},"true")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"bool basic_ios::operator!() const")," - same result as ",(0,r.kt)("inlineCode",{parentName:"li"},"fail()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"basic_ios::operator bool() const")," - same result as ",(0,r.kt)("inlineCode",{parentName:"li"},"!fail()"))),(0,r.kt)("p",null,"Note that the logical negation operator (",(0,r.kt)("inlineCode",{parentName:"p"},"!"),") is overloaded as an alternative to ",(0,r.kt)("inlineCode",{parentName:"p"},"fail()"),".  This operator reports ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the latest operation failed or if the stream has encountered a serious error.  We can use it on a stream object to check the success of the most recent action:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'if (std::cin.fail())\n{\n    std::cerr << "Read error" << std::endl; \n    std::cin.clear();\n}\n\n// ... may also be written as ...\n\nif (!std::cin)\n{\n    std::cerr << "Read error" << std::endl;\n    std::cin.clear();\n}\n')),(0,r.kt)("p",null,"One member function resets the state of the stream:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"void basic_ios::clear()")," - clears all flags")),(0,r.kt)("h4",{id:"open-mode-flags"},"Open mode Flags"),(0,r.kt)("p",null,"Six member constants identify the open mode of a stream:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ios_base::in")," open for reading"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ios_base::out")," open for writing"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ios_base::app")," open for appending"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ios_base::trunc")," open for writing, but truncate if file exists"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ios_base::ate")," move to the end of the file when the file is opened"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ios_base::binary")," access the file as a binary file")),(0,r.kt)("h3",{id:"ios-classes"},(0,r.kt)("inlineCode",{parentName:"h3"},"ios")," Classes"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ios")," instance of the ",(0,r.kt)("inlineCode",{parentName:"p"},"basic_ios")," template defines the base class for narrow character (",(0,r.kt)("inlineCode",{parentName:"p"},"char"),") input and output."),(0,r.kt)("p",null,"Practical bit-wise combinations of the openmode flags include"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ios::in | ios::out")," open for reading and writing (default)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ios::in | ios::out | ios::trunc")," open for reading and overwriting"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ios::in | ios::out | ios::app")," open for reading and appending"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ios::out | ios::trunc")," open for overwriting")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ostream")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"istream")," bases classes for the ",(0,r.kt)("inlineCode",{parentName:"p"},"ofstream"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ifstream"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"fstream")," classes provide access to bytes within a narrow character stream through a buffer."),(0,r.kt)("p",null,"A data member of type ",(0,r.kt)("inlineCode",{parentName:"p"},"streampos")," holds the byte position value within the stream.  Numbering starts at ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," for the first byte in the stream."),(0,r.kt)("h4",{id:"output-stream"},"Output Stream"),(0,r.kt)("p",null,"The member functions for accessing a byte within an output stream are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"streampos tellp()")," - returns the current position in the output stream"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ostream& seekp(streampos pos)")," - sets the current position in the output stream to ",(0,r.kt)("inlineCode",{parentName:"li"},"pos")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ostream& seekp(long offset, ios_base::seekdir dir)")," - sets the current position in the output stream to offset from ",(0,r.kt)("inlineCode",{parentName:"li"},"dir"))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"pos")," refers to the number of bytes from the beginning of the stream, ",(0,r.kt)("inlineCode",{parentName:"p"},"offset")," refers to the number of bytes from the seeking direction, and ",(0,r.kt)("inlineCode",{parentName:"p"},"dir")," refers to one of the three enumeration constants (see above)."),(0,r.kt)("p",null,"Note that the single argument version of ",(0,r.kt)("inlineCode",{parentName:"p"},"seekp()")," accepts the absolute position, while the two argument version accepts the relative position with respect to the specified seeking direction."),(0,r.kt)("h4",{id:"input-stream"},"Input Stream"),(0,r.kt)("p",null,"The member functions for accessing a byte within an input stream are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"streampos tellg()")," - returns the current position in the input stream"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"istream& seekg(streampos pos)")," - sets the current position in the input stream to ",(0,r.kt)("inlineCode",{parentName:"li"},"pos")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"istream& seekg(long offset, ios_base::seekdir dir)")," - sets the current position in the input stream to offset from ",(0,r.kt)("inlineCode",{parentName:"li"},"dir"))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"pos")," refers to the number of bytes from the beginning of the stream, offset refers to the number of bytes from the seeking direction, and ",(0,r.kt)("inlineCode",{parentName:"p"},"dir")," refers to one of three enumeration constants (see ",(0,r.kt)("inlineCode",{parentName:"p"},"ios")," class above)."),(0,r.kt)("p",null,"Note that the single argument version of ",(0,r.kt)("inlineCode",{parentName:"p"},"seekg()")," accepts the absolute position, while the two argument version accepts the relative position with respect to the specified seeking direction. "),(0,r.kt)("h3",{id:"wios-class"},(0,r.kt)("inlineCode",{parentName:"h3"},"wios")," Class"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"wios")," instance of the ",(0,r.kt)("inlineCode",{parentName:"p"},"basic_ios")," template defines the base class for wide character (",(0,r.kt)("inlineCode",{parentName:"p"},"wchar_t"),") input and output. "),(0,r.kt)("p",null,"Practical bit-wise combinations of the openmode flags include"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"wios::in | wios::out")," open for reading and writing (default)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"wios::in | wios::out | wios::trunc")," open for reading and overwriting"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"wios::in | wios::out | wios::app")," open for reading and appending"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"wios::out | wios::trunc")," open for overwriting")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"wostream")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"wistream")," base classes for the ",(0,r.kt)("inlineCode",{parentName:"p"},"wofstream"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"wifstream"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"wfstream")," classes provide access to bytes within a wide character stream through a buffer. "),(0,r.kt)("p",null,"A data member of type ",(0,r.kt)("inlineCode",{parentName:"p"},"wstreampos")," holds the wide-character position value within the stream.  Numbering starts at ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," for the first wide character in the stream. "),(0,r.kt)("h4",{id:"output-stream-1"},"Output Stream"),(0,r.kt)("p",null,"The member functions for accessing a wide-character within an output stream are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"wstreampos tellp()")," - returns the current position in the output stream"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"wostream& seekp(wstreampos pos)")," - sets the current position in the output stream to ",(0,r.kt)("inlineCode",{parentName:"li"},"pos")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"wostream& seekp(long offset, ios_base::seekdir dir)")," - sets the current position in the output stream to offset from ",(0,r.kt)("inlineCode",{parentName:"li"},"dir"))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"pos")," refers to the number of bytes from the beginning of the stream, offset refers to the number of bytes from the reference position, and ",(0,r.kt)("inlineCode",{parentName:"p"},"dir")," refers one of the three seeking directions."),(0,r.kt)("p",null,"Note that the single argument version of ",(0,r.kt)("inlineCode",{parentName:"p"},"seekp()")," accepts the absolute position, while the two argument version accepts the relative position with respect to the specified seeking direction."),(0,r.kt)("h4",{id:"input-stream-1"},"Input Stream"),(0,r.kt)("p",null,"The member functions for accessing a wide-character within an input stream are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"wstreampos tellg()")," - returns the current position in the input stream"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"wistream& seekg(wstreampos pos)")," - sets the current position in the input stream to ",(0,r.kt)("inlineCode",{parentName:"li"},"pos")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"wistream& seekg(long offset, ios_base::seekdir dir)")," - sets the current position in the input stream to offset from ",(0,r.kt)("inlineCode",{parentName:"li"},"dir"))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"pos")," refers to the number of wide-characters from the beginning of the stream, offset refers to the number of wide-characters from the seeking direction, and ",(0,r.kt)("inlineCode",{parentName:"p"},"dir")," refers to one of three enumeration constants (see ",(0,r.kt)("inlineCode",{parentName:"p"},"wios")," class above)."),(0,r.kt)("p",null,"Note that the single argument version of ",(0,r.kt)("inlineCode",{parentName:"p"},"seekg()")," accepts the absolute position, while the two argument version accepts the relative position with respect to the specified seeking direction. "),(0,r.kt)("h2",{id:"file-objects"},"File Objects"),(0,r.kt)("p",null,"File stream objects manage the transfer of data between program memory and files through buffers.  A file object can connect to a stream in either of two access modes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"text mode - the stream consists of characters interpreted using an encoding sequence and has a record structure with a terminator that identifies the end of each record"),(0,r.kt)("li",{parentName:"ul"},"binary mode - the stream consists of characters without any interpretation or structure.")),(0,r.kt)("p",null,"We specify the access mode on opening the file.  Text mode is the default mode. "),(0,r.kt)("h3",{id:"connections"},"Connections"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ofstream")," objects manage writing to a file, while ",(0,r.kt)("inlineCode",{parentName:"p"},"ifstream")," objects manage reading from a file.  Both classes have default constructors and constructors that receive the name of the file to be opened.  The constructors are overloaded to receive the address of a C-style null-terminated string and a reference to a ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," object.  For file objects created using the default constructor, the ",(0,r.kt)("inlineCode",{parentName:"p"},"open()")," member function connects to the file itself.  For example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <fstream>\n\nstd::ofstream fout("output.txt");  // opens output.txt for output\nstd::ifstream fin ("input.txt");   // opens input.txt for input\n\nstd::ofstream fo;                  // declares an output file named fo \nfo.open("moreOutput.txt");         // connect fo to moreOutput.txt\n\nstd::ifstream fi;                  // declares an input file named fi\nfi.open("moreInput.txt");          // connects fi to moreInput.txt\n')),(0,r.kt)("p",null,"The logical negation operator (",(0,r.kt)("inlineCode",{parentName:"p"},"!"),") on the file object returns the current state of the object:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <fstream>\n\nstd::ofstream fout("output.txt");  // opens output.txt for output \n\nif (!fout)\n{\n    std::cerr << "File failed to open" << std::endl;\n}\nelse\n{\n    // opened successfully\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"is_open()")," query on the file object returns the success of a connection attempt:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <fstream>\n\nstd::ofstream fout("output.txt");  // opens output.txt for output \n\nif (!fout.is_open())\n{\n    std::cerr << "File failed to open" << std::endl;\n}\nelse\n{\n    // opened successfully\n}\n')),(0,r.kt)("p",null,"The open-mode flags listed above, if passed to the constructor or ",(0,r.kt)("inlineCode",{parentName:"p"},"open()")," specify the connection mode."),(0,r.kt)("h4",{id:"file-buffer"},"File Buffer"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"rdbuf()")," member function on a file object returns the address of the object's buffer.  The insertion operator (",(0,r.kt)("inlineCode",{parentName:"p"},"<<"),") is overloaded for a pointer to this buffer.  To copy the contents of a file (say, source) to another file (say, destination) we can call this member function directly:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// Copying Files\n// fileCopy.cpp\n\n#include <fstream>\n\nint main(int argc, char agrv[])\n{\n    std::ifstream source(argv[1]);\n    std::ofstream destination(argv[2]); \n\n    destination << source.rdbuf();\n}\n")),(0,r.kt)("h3",{id:"close-a-connection"},"Close a Connection"),(0,r.kt)("p",null,"The destructor for a file object flushes the buffer and closes the file when the object goes out of scope.  To close a file connection before the file object goes out of scope, we call the ",(0,r.kt)("inlineCode",{parentName:"p"},"close()")," member function on the object itself: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// Closing a connection early\n// fileCopy2.cpp\n\n#include <fstream>\n\nint main(int argc, char agrv[])\n{\n    std::ifstream source;\n    std::ofstream destination(argv[3]);\n\n    source.open(argv[1]); // open first file\n\n    destination << source.rdbuf(); // copy\n\n    source.close();       // close first file \n    source.open(argv[2]); // open second file\n\n    destination << source.rdbuf(); // copy\n}\n")),(0,r.kt)("h3",{id:"direct-access"},"Direct Access"),(0,r.kt)("p",null,"A file object can access the contents of its stream either sequentially or directly.  Sequential access progresses from the beginning of the stream to its end.  Direct access starts at a specified position in the stream.  The ",(0,r.kt)("inlineCode",{parentName:"p"},"seek?()")," member functions on the file object set the starting position.  That position is the next to be accessed within the stream. The program below"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// File Objects - Direct Access\n// direct.cpp\n\n#include <iostream>\n#include <fstream>\n\nint main(int argc, char* argv[])\n{\n    std::ofstream fo(argv[1]);      // open for output\n\n    fo << "Line 1" << std::endl;    // line 1\n    fo << "Line 2" << std::endl;    // line 2\n    fo << "Line 3" << std::endl;    // line 3\n\n    fo.seekp(0, std::ios::beg);     // go to the start of the file\n    fo << "****";                   // overwrite four characters\n\n    fo.seekp(4, std::ios::cur);     // go 4 char\'s beyond current\n    fo << \'#\';                      // overwrite one character\n\n    std::streampos p = fo.tellp();  // remember current position \n    fo.seekp(0, std::ios::end);     // go to end of the file\n    fo << "The last line\\n";        // add a line\n\n    fo.seekp(p);                    // jump back to pos\n    fo << \'^\';                      // overwrite one character\n    fo.close();                     // close file\n\n    std::ifstream fi(argv[1]);      // open for reading\n    char c;\n\n    while (fi.get(c))               // read 1 character at a time \n        std::cout << c;             // display the character\n\n    fi.clear();                     // clear failed (eof) state\n    fi.seekg(-8, std::ios::end);    // move 8 bytes from end\n\n    while (fi.get(c))               // read 1 character at a time\n        std::cout << c;             // display the character read\n}\n')),(0,r.kt)("p",null,"outputs in Windows"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"**** 1\n#^ne 2\nLine 3\nThe last line\nt line\n")),(0,r.kt)("p",null,"and in Linux"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"**** 1\nL#^e 2\nLine 3\nThe last line \nst line\n")),(0,r.kt)("p",null,"The output on a Windows platform differs from that on a Linux platform because the record terminator consists of two characters on Windows - a carriage return and a newline (",(0,r.kt)("inlineCode",{parentName:"p"},"\\r\\n"),") - while the record terminator on Linux is a single character - a newline (",(0,r.kt)("inlineCode",{parentName:"p"},"\\n"),")."),(0,r.kt)("h3",{id:"writing-and-reading"},"Writing and Reading"),(0,r.kt)("p",null,"A file object of the ",(0,r.kt)("inlineCode",{parentName:"p"},"fstream")," class can manage both writing to and reading from a file.  Instead of creating separate objects for reading and writing, we can create a single instance of the ",(0,r.kt)("inlineCode",{parentName:"p"},"fstream")," class for writing to and reading from the same file."),(0,r.kt)("p",null,"The program below"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// File Objects - writing and reading\n// fstream.cpp\n\n#include <iostream>\n#include <fstream>\n\nint main(int argc, char* argv[])\n{\n    std::fstream f(argv[1], std::ios::in | std::ios::out | std::ios::trunc);\n\n    f << "Line 1" << std::endl;   // line 1\n    f << "Line 2" << std::endl;   // line 2\n    f << "Line 3" << std::endl;   // line 3\n\n    f.seekp(0, std::ios::beg);    // go to the start of the file\n    f << "****";                  // overwrite four characters\n\n    f.seekp(4, std::ios::cur);    // go 4 bytes beyond current\n    f << \'#\';                     // overwrite one character\n\n    std::streampos p = f.tellp(); // remember current position\n    f.seekp(0, std::ios::end);    // go to end of the file\n    f << "The last line\\n";       // add a line\n\n    f.seekp(p);                   // jump back to pos\n    f << \'^\';                     // overwrite one character\n\n    char c;\n    f.seekg(0, std::ios::beg);    // to the start of the file\n\n    while (f.get(c))              // read 1 character at a time \n        std::cout << c;           // display the character\n    \n    f.clear();                    // clear failed (eof) state\n    f.seekg(-8, std::ios::end);   // move 8 bytes from end\n    \n    while (f.get(c))              // read 1 character at a time\n        std::cout << c;           // display the character read\n}\n')),(0,r.kt)("p",null,"outputs in Windows"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"**** 1\n#^ne 2\nLine 3\nThe last line\nt line\n")),(0,r.kt)("p",null,"and in Linux"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"**** 1\nL#^e 2\nLine 3\nThe last line \nst line\n")),(0,r.kt)("p",null,"Note the open-mode flag settings for writing to and reading from the file."),(0,r.kt)("h2",{id:"binary-access"},"Binary Access"),(0,r.kt)("p",null,"Binary access transfers data to and from memory without any formatting; there is no conversion, insertion, or extraction of record or field separators.  Binary access lets us save the image of the contents of memory without any loss of information.  The contents of a file opened for binary access is typically indecipherable when viewed within a text editor. "),(0,r.kt)("p",null,"An application that reads or writes in binary access mode is responsible for keeping track of any structure that the data may have. "),(0,r.kt)("h3",{id:"input"},"Input"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"istream")," class of the input-output hierarchy includes a member function that reads a stream in binary mode.  The prototype for this function is"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::istream& read(char* data, std::streamsize nb);\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"data")," is the address of the destination in memory where the file data is to be copied and ",(0,r.kt)("inlineCode",{parentName:"p"},"nb")," is the number of bytes to be copied.  ",(0,r.kt)("inlineCode",{parentName:"p"},"std::streamsize")," is an integral type typically type defined as a ",(0,r.kt)("inlineCode",{parentName:"p"},"signed long"),"."),(0,r.kt)("p",null,"The program on the left reads from the file named on the command line, stores the data in ",(0,r.kt)("inlineCode",{parentName:"p"},"str")," and displays the stored string on standard output"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// Binary Access - Reading\n// readBinary.cpp\n\n#include <iostream>\n#include <fstream>\n\nint main(int argc, char* argv[])\n{\n    char str[1025];\n    char* p = str;\n\n    std::ifstream f(argv[1], std::ios::in | std::ios::binary); \n\n    while(f)\n        f.read(p++, 1);\n\n    *--p = '\\0'; // adds the null terminator\n\n    std::cout << str << std::endl;\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Hello World\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"std::ios::binary")," flag in the constructor call specifies binary access mode."),(0,r.kt)("h3",{id:"output"},"Output"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ostream")," class of the input-output hierarchy includes a member function for writing to a file in binary mode.  The prototype for this function is"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::ostream& write(const char* data, std::streamsize nb);\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"data")," is the address of the data to be copied to the file and ",(0,r.kt)("inlineCode",{parentName:"p"},"nb")," is the number of bytes to be copied. "),(0,r.kt)("p",null,"The following program writes the string ",(0,r.kt)("inlineCode",{parentName:"p"},"str")," to the file named on the command line"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// Binary Access - Writing\n// writeBinary.cpp\n\n#include <fstream>\n\nint main(int argc, char* argv[])\n{\n    char str[] = "Hello World";\n\n    std::ofstream f(argv[1], std::ios::out | std::ios::binary | std::ios::trunc); \n\n    f.write(str, sizeof str - 1);\n}\n')),(0,r.kt)("h3",{id:"binary-versus-text"},"Binary versus Text"),(0,r.kt)("p",null,"The program below compares binary and text access with respect to the same value stored in memory (1.0/3.0).  The file object opened under binary access preserves the original precision so that the value returned to memory is the same as originally stored.  The file object opened under text access discards some of the precision as it formats the value for output to 6 decimal places. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// Binary Access - Binary or Text\n// binary.cpp\n\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n\nint main(int argc, char* argv[])\n{\n    std::cout << std::fixed << std::setprecision(15);\n\n    {\n        // binary access\n        double x = 1.0/3.0;\n\n        std::fstream f(argv[1], std::ios::in | std::ios::out | std::ios::trunc | std::ios::binary);\n\n        f.write(reinterpret_cast<char*>(&x), sizeof(x));\n        f.seekg(0, std::ios::beg);\n        f.read(reinterpret_cast<char*>(&x), sizeof(x));\n\n        std::cout << x << std::endl;\n    }\n\n    {\n        // text access\n        double x = 1.0/3.0;\n\n        std::fstream t(argv[2], std::ios::in | std::ios::out | std::ios::trunc);\n\n        t << x;\n        t.seekg(0, std::ios::beg);\n        t >> x;\n\n        std::cout << x << std::endl;\n    }\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0.333333333333333\n0.333333000000000\n")),(0,r.kt)("p",null,"Note the cast to a ",(0,r.kt)("inlineCode",{parentName:"p"},"char*")," type in the ",(0,r.kt)("inlineCode",{parentName:"p"},"read()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"write()")," member functions."),(0,r.kt)("h2",{id:"exercises"},"Exercises"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Read Wikipedia on ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Stream_%28computing%29"},"streams"))))}m.isMDXComponent=!0},3079:function(e,t,n){t.Z=n.p+"assets/images/fstream-bac67f50faf8263a32fbe36433c9796d.png"},4891:function(e,t,n){t.Z=n.p+"assets/images/wfstream-53fbaf4079267b3eb80fb27b42adf75a.png"}}]);