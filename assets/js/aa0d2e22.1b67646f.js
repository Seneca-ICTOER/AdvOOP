"use strict";(self.webpackChunkoop345=self.webpackChunkoop345||[]).push([[512],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return d}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=n.createContext({}),s=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},m=function(e){var t=s(e.components);return n.createElement(o.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,l=e.originalType,o=e.parentName,m=p(e,["components","mdxType","originalType","parentName"]),u=s(a),d=i,f=u["".concat(o,".").concat(d)]||u[d]||c[d]||l;return a?n.createElement(f,r(r({ref:t},m),{},{components:a})):n.createElement(f,r({ref:t},m))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=a.length,r=new Array(l);r[0]=u;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p.mdxType="string"==typeof e?e:i,r[1]=p;for(var s=2;s<l;s++)r[s]=a[s];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},4356:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return p},contentTitle:function(){return o},metadata:function(){return s},toc:function(){return m},default:function(){return u}});var n=a(7462),i=a(3366),l=(a(7294),a(3905)),r=["components"],p={id:"class-templates",title:"Class Templates",sidebar_position:2,description:"TBD"},o="Class Templates",s={unversionedId:"C-Class-Relationships/class-templates",id:"C-Class-Relationships/class-templates",isDocsHomePage:!1,title:"Class Templates",description:"TBD",source:"@site/docs/C-Class-Relationships/class-templates.md",sourceDirName:"C-Class-Relationships",slug:"/C-Class-Relationships/class-templates",permalink:"/C-Class-Relationships/class-templates",editUrl:"https://github.com/Seneca-ICTOER/AdvOOP/tree/main/docs/C-Class-Relationships/class-templates.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"class-templates",title:"Class Templates",sidebar_position:2,description:"TBD"},sidebar:"courseNotesSidebar",previous:{title:"Inheritance and Inclusion Polymorphism",permalink:"/C-Class-Relationships/inheritance-and-inclusion-polymorphism"},next:{title:"Compositions, Aggregations and Associations",permalink:"/C-Class-Relationships/compositions-aggregations-and-associations"}},m=[{value:"Template Syntax",id:"template-syntax",children:[{value:"Template Parameters",id:"template-parameters",children:[{value:"Type Template Parameter",id:"type-template-parameter",children:[],level:4},{value:"Non-Type Template Parameter",id:"non-type-template-parameter",children:[],level:4},{value:"Template Template Parameter",id:"template-template-parameter",children:[],level:4}],level:3},{value:"Template Body",id:"template-body",children:[],level:3}],level:2},{value:"Function Templates",id:"function-templates",children:[{value:"Specialization",id:"specialization",children:[],level:3},{value:"Overloading versus Specialization",id:"overloading-versus-specialization",children:[],level:3},{value:"Resolving Ambiguities",id:"resolving-ambiguities",children:[],level:3}],level:2},{value:"Class Templates",id:"class-templates-1",children:[{value:"Non-Type Template Parameters",id:"non-type-template-parameters",children:[],level:3},{value:"Default Template Parameter Values",id:"default-template-parameter-values",children:[],level:3},{value:"Static Data Member Declarations in a Class Template",id:"static-data-member-declarations-in-a-class-template",children:[],level:3},{value:"Templates and Inheritance",id:"templates-and-inheritance",children:[],level:3}],level:2},{value:"Variadic Templates (optional for OOP345)",id:"variadic-templates-optional-for-oop345",children:[],level:2},{value:"Exercises",id:"exercises",children:[],level:2}],c={toc:m};function u(e){var t=e.components,a=(0,i.Z)(e,r);return(0,l.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"class-templates"},"Class Templates"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Model polymorphic behavior using templates (generics)"),(0,l.kt)("li",{parentName:"ul"},"Specialize a template for a particular type")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},'"Templates supports generic programming, template metaprogramming, etc. through a combination of features such as integer template arguments, specialization, and uniform treatment of built-in and user-defined types. The result is flexibility, generality, and performance unmatched by "generics". The STL is the prime example." Stroustrup (2014)')),(0,l.kt)("p",null,"In programming languages and type theory, polymorphism provides a unique interface to entities of different types. The three categories of polymorphism are ad-hoc, inclusion and parametric. C++ implements ad hoc polymorphism by overloading a function name for different parameter types, inclusion polymorphism by using the same function signature across different classes in an inheritance hierarchy and parametric polymorphism by using the same name for classes or functions that share the same structure. C++ implements parametric (or generic) polymorphism through templates."),(0,l.kt)("p",null,"The structure of each templated class or function is independent of the type(s) involved. By defining that structure in a generic form we can reduce code duplication significantly. The compiler generates the class and function definitions from our templates for the types that we specify explicitly."),(0,l.kt)("p",null,"This chapter describes template syntax for function and class definitions, introduces class template specialization, discusses inheritance in the context of templates and describes templates that can take variable numbers of arguments."),(0,l.kt)("h2",{id:"template-syntax"},"Template Syntax"),(0,l.kt)("p",null,"A template defines one of the following"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"a family of functions, classes or nested classes"),(0,l.kt)("li",{parentName:"ul"},"a family of member functions, member classes, member enumerations, or variables"),(0,l.kt)("li",{parentName:"ul"},"an alias to a family of types")),(0,l.kt)("p",null,"A template declaration or definition begins with the keyword ",(0,l.kt)("inlineCode",{parentName:"p"},"template"),", followed by a parameter list enclosed in a single chevron pair ",(0,l.kt)("inlineCode",{parentName:"p"},"<")," ",(0,l.kt)("inlineCode",{parentName:"p"},">")," and then the template body. Example forms for a template declaration are"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"template < template-parameter-list > // template header\nreturn-type function-name( ... )\n{\n    // template body for a family of functions\n    // ...\n}\n\ntemplate < template-parameter-list > // template header\nclass-key Class-name\n{\n    // template body for a family of classes\n    // ...\n};\n\ntemplate < template-parameter-list > // template header\ntype variable_name; // template body for a family of variables\n")),(0,l.kt)("p",null,"The template parameter list consists of a comma-separated set of template parameters."),(0,l.kt)("h3",{id:"template-parameters"},"Template Parameters"),(0,l.kt)("p",null,"A template parameter may be:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"a type template parameter"),(0,l.kt)("li",{parentName:"ul"},"a non-type template parameter"),(0,l.kt)("li",{parentName:"ul"},"a template template parameter")),(0,l.kt)("h4",{id:"type-template-parameter"},"Type Template Parameter"),(0,l.kt)("p",null,"A type template parameter declaration takes the form"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"typename identifier[=default]")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"class identifier[=default]"))),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"typename")," keyword identifies a template type. The ",(0,l.kt)("inlineCode",{parentName:"p"},"class")," keyword is an alternative identifier for a template type. ",(0,l.kt)("inlineCode",{parentName:"p"},"identifier")," is a placeholder for the parameter type throughout the template body. ",(0,l.kt)("inlineCode",{parentName:"p"},"default")," is an optional default value for the parameter type. ",(0,l.kt)("inlineCode",{parentName:"p"},"[ ]")," identifies an optional element."),(0,l.kt)("p",null,"An argument corresponding to a type template parameter in a template instantiation should be a recognized type."),(0,l.kt)("h4",{id:"non-type-template-parameter"},"Non-Type Template Parameter"),(0,l.kt)("p",null,"A non-type template parameter is a template parameter that is not a placeholder for a type. That is, its type is declared explicitly. A non-type template parameter declaration takes the form"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"type identifier[=default]"))),(0,l.kt)("p",null,"A non-type template parameter may be one of the following types"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"an integral or enumeration type - a non-floating-point fundamental type"),(0,l.kt)("li",{parentName:"ul"},"a pointer to a object or a function"),(0,l.kt)("li",{parentName:"ul"},"an lvalue reference to an object or a function"),(0,l.kt)("li",{parentName:"ul"},"a pointer to a member"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"std::nullptr_t")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"auto"))),(0,l.kt)("p",null,"Note that a non-type template parameter may not be a floating-point type (before C++20)."),(0,l.kt)("p",null,"An argument corresponding to a non-type template parameter in a templated instantiation should be a constant or constant expression."),(0,l.kt)("h4",{id:"template-template-parameter"},"Template Template Parameter"),(0,l.kt)("p",null,"A template template parameter is a template parameter that is a placeholder for a template. The declaration of a template template parameter takes the form"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"template< parameter-list > typename identifier[=default]")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"template< parameter-list > class identifier[=default]"))),(0,l.kt)("h3",{id:"template-body"},"Template Body"),(0,l.kt)("p",null,"We code a template body using the parameter names declared in the template header. The identifiers serve as placeholders throughout the template body for the arguments specified in the template instantiation. For every instantiation, the compiler generates code in which it replaces the placeholders with the arguments specified in the instantiation. For example, the program"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n\ntemplate <typename T> // template header\nvoid foo()\n{\n    T value;\n    value = 1.5;\n    std::cout << value << '\\n';\n}\n\nint main()\n{\n    foo<int>();    // template instantiation\n    foo<double>(); // template instantiation\n}\n")),(0,l.kt)("p",null,"outputs"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"1\n1.5\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"T")," is a type template parameter. The compiler replaces ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," with the type specified in the instantiation (here, ",(0,l.kt)("inlineCode",{parentName:"p"},"int")," and then ",(0,l.kt)("inlineCode",{parentName:"p"},"double"),")."),(0,l.kt)("p",null,"A template identifier or name has linkage. A non-member function template can have internal linkage. Any other template name has external linkage."),(0,l.kt)("h2",{id:"function-templates"},"Function Templates"),(0,l.kt)("p",null,"The following function template defines a family of functions that swap two values of type ",(0,l.kt)("inlineCode",{parentName:"p"},"T"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"// Function Template\n// swap.h\n\ntemplate <typename T>\nvoid swap(T& a, T& b)\n{\n    T c;\n    c = a;\n    a = b;\n    b = c;\n}\n")),(0,l.kt)("p",null,"The following program uses this template to swap two ",(0,l.kt)("inlineCode",{parentName:"p"},"double"),"s and two ",(0,l.kt)("inlineCode",{parentName:"p"},"long"),"s:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Function Template\n// swap.cpp\n\n#include <iostream>\n#include "swap.h"\n\nint main(int argc, char* argv[])\n{\n    if (argc > 4)\n    {\n        double a = atof(argv[1]);\n        double b = atof(argv[2]);\n        long   d = atol(argv[3]);\n        long   e = atol(argv[4]);\n\n        swap(a, b);\n\n        std::cout << "Swapped values are " <<  a << " and " << b << std::endl;\n\n        swap(d, e);\n\n        std::cout << "Swapped values are " << d << " and " << e << std::endl;\n    }\n}\n')),(0,l.kt)("p",null,"If the program is started with the command"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"> swap 2.3 4.5 78 567\n")),(0,l.kt)("p",null,"the output is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"Swapped values are 4.5 and 2.3\nSwapped values are 567 and 78\n")),(0,l.kt)("p",null,"The compiler uses the argument types in the function calls to generate the two function definitions."),(0,l.kt)("h3",{id:"specialization"},"Specialization"),(0,l.kt)("p",null,"A template ",(0,l.kt)("em",{parentName:"p"},"specialization")," of a function defines an exception to a template definition of that function."),(0,l.kt)("p",null,"Consider a function template for returning the maximum value of two arguments:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"// Template Specialization\n// maximum.h\n\ntemplate <typename T>\nT maximum(T a, T b)\n{\n    return a > b ? a : b;\n}\n")),(0,l.kt)("p",null,"Practically, this definition applies to all fundamental types, but not to pointers to those types; for instance, not to the ",(0,l.kt)("inlineCode",{parentName:"p"},"const char*")," type. To create an exception for the ",(0,l.kt)("inlineCode",{parentName:"p"},"const char*")," type, we define the following template specialization:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"// Template Specialization\n// maximum.h\n\n#include <cstring>\n\ntemplate <typename T>\nT maximum(T a, T b)\n{\n    return a > b ? a : b;\n}\n\n// specialization for char* types\n//\ntemplate <> // denotes specialization\nconst char* maximum<const char*>(const char* a, const char* b)\n{\n    return std::strcmp(a, b) > 0 ? a : b;\n}\n")),(0,l.kt)("p",null,"The empty parameter list identifies a specialization. A specialization does not use template parameters, but declares the specialized type(s) explicitly."),(0,l.kt)("p",null,"The following example determines the maximum of two ",(0,l.kt)("inlineCode",{parentName:"p"},"double"),"s and two C-style strings:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Template Specialization\n// maximum.cpp\n\n#include <iostream>\n#include "maximum.h"\n\nint main(int argc, char* argv[])\n{\n    if (argc > 4)\n    {\n        double a = atof(argv[1]);\n        double b = atof(argv[2]);\n        const char* d = argv[3];\n        const char* e = argv[4];\n\n        double c = maximum(a, b);\n\n        std::cout << "Greater of " << a << ", " << b << " is " << c << std::endl;\n\n        const char* f = maximum(d, e);\n\n        std::cout << "Greater of " << d << ", " << e << " is " << f << std::endl;\n    }\n}\n')),(0,l.kt)("p",null,"If the program is started with the command"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},">maximum 2.3 4.5 abc def\n")),(0,l.kt)("p",null,"the output is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"Greater of 2.3, 4.5 is 4.5\nGreater of abc, def is def\n")),(0,l.kt)("h3",{id:"overloading-versus-specialization"},"Overloading versus Specialization"),(0,l.kt)("p",null,"As an alternative to specialization we could overload the function for the ",(0,l.kt)("inlineCode",{parentName:"p"},"const char*")," type. Since the compiler resolves overloading before instantiating any specialization, the specialization would be redundant. In principle, good design prefers overloading to the equivalent specialization, and only specializes when it is required."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Template Specialization\n// maximum.h\n\n#include <iostream>\n#include <cstring>\n\ntemplate <template T>\nT maximum(T a, T b)\n{\n    std::cout << "in template body\\n";\n    return a > b ? a : b;\n}\n\n// specialization for char* types\n//\ntemplate <> // denotes specialization\nconst char* maximum<const char*>(const char* a, const char* b)\n{\n    std::cout << "in specialization\\n";\n    return std::strcmp(a, b) > 0 ? a : b;\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Template Specialization\n// maximum_overload.cpp\n\n#include <iostream>\n#include "maximum.h"\n\nconst char* maximum(const char* a, const char* b)\n{\n    std::cout << "in overloaded function\\n";\n    return std::strcmp(a, b) > 0 ? a : b;\n}\n\nint main(int argc, char* argv[])\n{\n    if (argc > 4)\n    {\n        double a = atof(argv[1]);\n        double b = atof(argv[2]);\n        const char* d = argv[3];\n        const char* e = argv[4];\n\n        double c = maximum(a, b);\n\n        std::cout << "Greater of " << a << ", " << b << " is " << c << std::endl;\n\n        const char* f = maximum(d, e);\n\n        std::cout << "Greater of " << d << ", " << e << " is " << f << std::endl;\n    }\n}\n')),(0,l.kt)("p",null,"If the program is started with the command"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},">maximum 2.3 4.5 abc def\n")),(0,l.kt)("p",null,"the output is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"in template\nGreater of 2.3, 4.5 is 4.5\nin overloaded function\nGreater of abc, def is def\n")),(0,l.kt)("h3",{id:"resolving-ambiguities"},"Resolving Ambiguities"),(0,l.kt)("p",null,"If the arguments in a function call are ambiguous in type, the compiler requires an explicit specification of the type for which to generate the definition. We specify the type explicitly before the opening parenthesis of the function call:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Resolving Ambiguities\n// ambiguities.cpp\n\n#include <iostream>\n#include "swap.h"\n\nint main(int argc, char* argv[])\n{\n    if (argc > 4)\n    {\n        double a = atof(argv[1]);\n        double b = atof(argv[2]);\n        float  d = atof(argv[3]);\n        float  e = atof(argv[4]);\n\n        double c = maximum<double>(a, d);\n\n        std::cout << "Greater of " << a << ", " << d << " is " << c << std::endl;\n\n        float f = maximum<float>(b, e);\n\n        std::cout << "Greater of " << b << ", " << e << " is " << f << std::endl;\n    }\n}\n')),(0,l.kt)("p",null,"If the program is started with the command"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},">ambiguities 2.3 4.5 3.4 2.1\n")),(0,l.kt)("p",null,"the output is"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"Greater of 2.3, 3.4 is 3.4\nGreater of 4.5, 2.1 is 4.5\n")),(0,l.kt)("h2",{id:"class-templates-1"},"Class Templates"),(0,l.kt)("p",null,"A template declaration for a family of classes follows the same rules as a template declaration for a family of functions. Consider a class that contains an array of up to 50 ",(0,l.kt)("inlineCode",{parentName:"p"},"int"),"s:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"// Array\n// array.h\n\nclass Array\n{\n    int a[50];\n    unsigned n;\n    int dummy;\npublic:\n    Array() : n{0u}, dummy{0} {}\n    int& operator[](unsigned i)\n    {\n        return i < 50u ? a[i] : dummy;\n    }\n};\n")),(0,l.kt)("p",null,"When used with the following client application, the ",(0,l.kt)("inlineCode",{parentName:"p"},"Array")," objects yield the results on the below"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"// Array\n// array.cpp\n\n#include <iostream>\n#include \"array.h\"\n\nint main()\n{\n    Array a, b;\n\n    for (int i = 0; i < 5; i++)\n        a[i] = i * i;\n\n    b = a;\n\n    for (int i = 0; i < 5; i++)\n        std::cout << b[i] << ' ';\n    std::cout << endl;\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"0 1 4 9 16\n")),(0,l.kt)("p",null,"The template declaration for a family of ",(0,l.kt)("inlineCode",{parentName:"p"},"Array")," classes with elements of type ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," is simply:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"// Class Template - Array\n// array.h\n\ntemplate <typename T>\nclass Array\n{\n    T a[50];\n    unsigned n;\n    T dummy;\npublic:\n    Array() : n{0u}, dummy{0} {}\n    T& operator[](unsigned i)\n    {\n        return i < 50u ? a[i] : dummy;\n    }\n};\n")),(0,l.kt)("p",null,"The compiler generates class definitions for each template instantiation and replaces type ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," with the argument specified in the instantiation of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Array")," template. The following application generates a class named ",(0,l.kt)("inlineCode",{parentName:"p"},"Array")," that holds elements of type ",(0,l.kt)("inlineCode",{parentName:"p"},"long"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"// Class Template\n// array.cpp\n\n#include <iostream>\n#include \"array.h\"\n\nint main()\n{\n    Array<long> a, b;\n\n    for (int i = 0; i < 5; i++)\n        a[i] = i * i;\n\n    b = a;\n\n    for (int i = 0; i < 5; i++)\n        std::cout << b[i] << ' ';\n    std::cout << endl;\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"0 1 4 9 16\n")),(0,l.kt)("h3",{id:"non-type-template-parameters"},"Non-Type Template Parameters"),(0,l.kt)("p",null,"Non-type template parameters can receive the size of an array. For example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"// Non-Type Template Parameters\n// array.h\n\ntemplate <typename T, int SIZE>\nclass Array\n{\n    T a[SIZE];\n    unsigned n;\n    T dummy;\npublic:\n    Array() : n{0u}, dummy{} {}\n    T& operator[](unsigned i)\n    {\n        return i < SIZE ? a[i] : dummy;\n    }\n};\n")),(0,l.kt)("p",null,"The argument corresponding to the non-type parameter must be a constant or a constant expression:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"// Non-Type Template Parameters\n// array.cpp\n\n#include <iostream>\n#include \"array.h\"\n\nint main()\n{\n    Array <int, 50> a, b;\n\n    for (int i = 0; i < 5; i++)\n        a[i] = i * i;\n\n    b = a;\n\n    for (int i = 0; i < 5; i++)\n        std::cout << b[i] << ' ';\n    std::cout << std::endl;\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"0 1 4 9 16\n")),(0,l.kt)("h3",{id:"default-template-parameter-values"},"Default Template Parameter Values"),(0,l.kt)("p",null,"A template declaration for a family of classes accepts default parameter values. We specify the default value in the same way that we specify a default value for a function parameter in a function declaration:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"// Default Template Parameter Values\n// array.h\n\ntemplate <typename T = int, int SIZE = 50>\nclass Array\n{\n    T a[SIZE];\n    unsigned n;\n    T dummy;\npublic:\n    Array() : n(0), dummy() {}\n    T& operator[](unsigned i)\n    {\n        return i < SIZE ? a[i] : dummy;\n    }\n};\n")),(0,l.kt)("p",null,"If all of the template parameters have default values, we can create a class without supplying any arguments:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"// Default Template Parameter Values\n// array.cpp\n\n#include <iostream>\n#include \"array.h\"\n\nint main()\n{\n    Array <> a, b;\n\n    for (int i = 0; i < 5; i++)\n        a[i] = i * i;\n\n    b = a;\n\n    for (int i = 0; i < 5; i++)\n        std::cout << b[i] << ' ';\n    std::cout << endl;\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"0 1 4 9 16\n")),(0,l.kt)("h3",{id:"static-data-member-declarations-in-a-class-template"},"Static Data Member Declarations in a Class Template"),(0,l.kt)("p",null,"A template declaration for a family of classes that include a class variable requires a complementary template declaration to define and initialize the family of class variables."),(0,l.kt)("p",null,"Into our ",(0,l.kt)("inlineCode",{parentName:"p"},"Array")," example, let us insert a class variable named ",(0,l.kt)("inlineCode",{parentName:"p"},"count")," to count the number of objects of the ",(0,l.kt)("inlineCode",{parentName:"p"},"Array")," class that currently exist. We add the template declaration for the family of the class variables to the header file that contains the template declaration for the class and modify the constructor and destructor definitions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"// Static Data Member Declaration\n// array.h\n\ntemplate <typename T = int, int SIZE = 50>\nclass Array\n{\n    T a[SIZE];\n    unsigned n;\n    T dummy;\n    static unsigned m_count;               // <-- class member (aka type member)\n\npublic:\n    Array() : n{0}, dummy{} { ++m_count; }\n    ~Array() { --m_count; }\n\n    T& operator[](unsigned i)\n    {\n        return i < SIZE ? a[i] : dummy;\n    }\n\n    static unsigned getCount();           // <-- class member (aka type member)\n};\n\ntemplate <typename T, int SIZE>\nunsigned Array<T, SIZE>::m_count = 0u;\n\ntemplate <typename T, int SIZE>\nunsigned Array<T, SIZE>::getCount()\n{\n    return Array<T, SIZE>::m_count;\n}\n")),(0,l.kt)("p",null,"Note that the parameter list following the ",(0,l.kt)("inlineCode",{parentName:"p"},"template")," keyword for the family of class variables is identical to the list for the family of classes."),(0,l.kt)("p",null,"The following example displays the number of objects of each type that have been instantiated:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"objects of the default type for an array of default size"),(0,l.kt)("li",{parentName:"ul"},"objects of the ",(0,l.kt)("inlineCode",{parentName:"li"},"double")," type for an array with the default size"),(0,l.kt)("li",{parentName:"ul"},"objects of the ",(0,l.kt)("inlineCode",{parentName:"li"},"int")," type for an array with a size of ",(0,l.kt)("inlineCode",{parentName:"li"},"40"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Static Data Member Declaration\n// array.cpp\n\n#include <iostream>\n#include "array.h"\n\nint main()\n{\n    Array<> s, t;\n    Array<double> u;\n    Array<int, 40> v;\n\n    std::cout << Array<>::getCount()        << std::endl;\n    std::cout << Array<double>::getCount()  << std::endl;\n    std::cout << Array<int, 40>::getCount() << std::endl;\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"2\n1\n1\n")),(0,l.kt)("p",null,"Note that the three class definitions generated from the template for their family are definitions distinct from one another"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"s")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"t")," are instances of class ",(0,l.kt)("inlineCode",{parentName:"li"},"Array<>")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"u")," is an instance of the separate class ",(0,l.kt)("inlineCode",{parentName:"li"},"Array<double>")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"v")," is an instance of the separate class ",(0,l.kt)("inlineCode",{parentName:"li"},"Array<int, 40>"))),(0,l.kt)("p",null,"The first and third class definitions differ only in the number of elements allocated."),(0,l.kt)("h3",{id:"templates-and-inheritance"},"Templates and Inheritance"),(0,l.kt)("p",null,"A class can be derived directly from a templated family of classes. All the usual rules of inheritance and polymorphism apply. In the following example, we need to pass the template parameter ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," from the ",(0,l.kt)("inlineCode",{parentName:"p"},"Derived")," class to the ",(0,l.kt)("inlineCode",{parentName:"p"},"Base")," class template since the base template requires that type:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"// Templates and Inheritance\n// templates_inheritance.h\n#include <iostream>\n\ntemplate<typename T>\nclass Base\n{\n    T value;\npublic:\n    void set(const T& v) { value = v; }\n    void display() const { std::cout << value << std::endl; }\n};\n\ntemplate<typename T>\nclass Derived : public Base<T>\n{\npublic:\n    void set(const T& v) { Base<T>::set(v); }\n};\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Templates and Inheritance\n// templates_inheritance.cpp\n\n#include "templates_inheritance.h"\n\nint main()\n{\n    Derived<double> d;\n    d.set(12);\n    d.display();\n}\n')),(0,l.kt)("p",null,"The derived class template can include template parameters of its own. In the following example, we add a the template parameter ",(0,l.kt)("inlineCode",{parentName:"p"},"S")," to the ",(0,l.kt)("inlineCode",{parentName:"p"},"Derived")," family of classes:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"// Templates and Inheritance\n// templates_inheritance_.h\n#include <iostream>\n\ntemplate<typename T>\nclass Base\n{\n    T value;\npublic:\n    void set(const T& v) { value = v; }\n    void display() const { std::cout << value << std::endl; }\n};\n\ntemplate<typename S, typename T>\nclass Derived : public Base<T>\n{\n    S value;\npublic:\n    Derived(const S& v) : value{v}{}\n    void set(const T& v) { Base<T>::set(v + value); }\n};\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Templates and Inheritance\n// templates_inheritance_.cpp\n\n#include "templates_inheritance.h"\n\nint main()\n{\n    Derived<int, double> d(4);\n    d.set(12);\n    d.display();\n}\n')),(0,l.kt)("h2",{id:"variadic-templates-optional-for-oop345"},"Variadic Templates (optional for OOP345)"),(0,l.kt)("p",null,"A template that accepts an arbitrary number of arguments is called a ",(0,l.kt)("strong",{parentName:"p"},"variadic")," template. A declaration of a variadic template includes a ",(0,l.kt)("em",{parentName:"p"},"parameter-pack")," as one of its parameters. An ellipsis to the left of the parameter name identifies a parameter-pack. A parameter-pack is either a ",(0,l.kt)("em",{parentName:"p"},"template parameter-pack")," or a ",(0,l.kt)("em",{parentName:"p"},"function parameter-pack"),". For example, the following declares a class named ",(0,l.kt)("inlineCode",{parentName:"p"},"Variadic")," that takes at least one argument:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename T, typename... parameter-pack>\nclass Variadic;\n")),(0,l.kt)("p",null,"All of the following are valid instantiations of this class template:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"Variadic<double> a;                      // 1 argument (minimum)\nVariadic<double, int> b;                 // 2 arguments\nVariadic<double, int, int> c;            // 3 arguments\nVariadic<double, double, int, double> d; // 4 arguments\n")),(0,l.kt)("p",null,"Variadic templates are used with inheritance hierarchies"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename... BaseClasses>\nclass Variadic : public BaseClasses...\n{\n\n};\n")),(0,l.kt)("p",null,"and with initialization lists"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename... TT>\nvoid foo(TT... args)\n{\n    const int size = sizeof...(args) + 1; // number of arguments + 1\n    int x[size] = {args..., 0};\n    // ...\n};\n")),(0,l.kt)("p",null,"An ellipsis to the right of the parameter name identifies a pack-expansion. A pack-expansion consists of a pattern and an ellipsis. Note the parameter-pack and the pack-expansion in the following program:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'// Variadic Templates\n// variadic.cpp\n\n#include <iostream>\n\ntemplate <typename T>\nvoid print(const T& t)\n{\n    std::cout << t << std::endl;\n}\n\ntemplate <typename T, typename... etc>\nvoid print(const T& t,const etc&... pp)\n{\n    std::cout << t << " | ";\n    print(pp...);\n}\n\nint main()\n{\n    print(100);\n    print("abcd", 100, 34.56);\n}\n')),(0,l.kt)("p",null,"outputs"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"100\nabcd | 100 | 34.56\n")),(0,l.kt)("h2",{id:"exercises"},"Exercises"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Read Wikipedia on ",(0,l.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Template_(C++)"},"Templates"))))}u.isMDXComponent=!0}}]);